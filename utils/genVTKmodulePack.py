import re
import vtk

# parameters that need to be filled in:
# moduleName, vtkObjectName, progressText, inputDescriptions, outputDescrs
moduleSkeleton1 = "# class generated by " \
                  "DeVIDE::createDeVIDEModuleFromVTKObject\n" \
                  "from module_kits.vtk_kit.mixins " \
                  "import SimpleVTKClassModuleBase\n" \
                  "import vtk\n\n" \
                  "class %s(SimpleVTKClassModuleBase):\n" \
                  "    def __init__(self, moduleManager):\n" \
                  "        SimpleVTKClassModuleBase.__init__(\n" \
                  "            self, moduleManager,\n" \
                  "            vtk.%s(), '%s',\n" \
                  "            %s, %s,\n" \
                  "            replaceDoc=True,\n" \
                  "            inputFunctions=%s, outputFunctions=%s)\n"

excludeList = ['vtkDataWriter', 'vtkDataReader', # two helper classes
               'vtkStructuredPointsGeometryFilter', # deprecated after 4.0
               'vtkDemandDrivenPipeline', # CRASH
               'vtkStreamingDemandDrivenPipeline', # CRASH
               'vtkAlgorithm', # abstract (kinda)
               'vtkPExodusReader', # cannot instantiate in VTK5.0 linux
               'vtkHierarchicalPolyDataMapper', # no SetInput attribute
               'vtkMaskFields', # GetCopyAll attribute error
               'vtkCursor3D', # attribute error
               'vtkPCAAnalysisFilter', # this has an non-normal SetInput iface
               'vtkImageStencilSource', # no SetInput method
               'vtkVolumeTextureMapper2D',
               'vtkVolumeTextureMapper3D',
               'vtkProcrustesAlignmentFilter', # non-standard SetInput iface
               'vtkRectilinearGridToTetrahedra', # non-standard SetInput iface
               'vtkImageCanvasSource2D'
               ]

# regular expression pattern objects that should be excluded as well
# these make no sense to be wrapped in modules.
exclude_pos = [
        re.compile('.*Mapper[2,3]*[D]*$'),
        re.compile('.*Representation[2,3,D]*$'),
        re.compile('.*Widget$'),
        re.compile('.*InteractorStyle.*$'),
        re.compile('.*Abstract.*$')
        ]

# these are for filters that take multiple connections on the same
# input port.  We're kludging this at the moment by making use of the
# legacy SetInput(idx, input_data) method (see vtk_kit/mixins/
# SimpleVTKClassModuleBase). This kludge only works in some cases...
# (e.g. vtkAppendPolyData doesn't like SetInput(idx, blaat), but
# vtkImageAppendComponents does - thanks Stef Busking!)
multi_input_connection_filters = {
        'vtkImageAppendComponents' : 5
        }

def createDeVIDEModuleFromVTKObject(vtkObjName):
    """Returns tuple with first element the name of the module,
    the second element a string representing the complete code, the third
    element a tuple of categories to which the module belongs.
    """

    # instantiate it
    vtkObj = getattr(vtk, vtkObjName)()

    
    if vtkObjName.endswith('Writer'):
        moduleName = vtkObjName

        # with moduleName[:-6] we snip off the 'Writer'
        moduleText = moduleSkeleton1 % (moduleName, vtkObjName,
                                        'Writing %s.' % (moduleName[:-6],),
                                        (vtkObjName[:-6],), (),
                                        None, None)
        return (moduleName, moduleText, 'VTK basic writer', vtkObj.__doc__)
        
    elif vtkObjName.endswith('Reader'):
        moduleName = vtkObjName

        # with moduleName[:-6] we snip off the 'Reader'
        moduleText = moduleSkeleton1 % (moduleName, vtkObjName,
                                        'Reading %s.' % (moduleName[:-6],),
                                        (), (vtkObjName[:-6],),
                                        None, None)
        return (moduleName, moduleText, 'VTK basic readers', vtkObj.__doc__)

    else:

        # determine number and types of inputs, building up list of
        # input types as we go along
        num_i = vtkObj.GetNumberOfInputPorts()
        ip_types = []
        for i in range(num_i):
            ip_inf = vtkObj.GetInputPortInformation(i)
            ip_typ = ip_inf.Get(vtk.vtkAlgorithm.INPUT_REQUIRED_DATA_TYPE())
            ip_types.append(ip_typ)

        # kludge to support some multi-input-connection filters
        input_conns = multi_input_connection_filters.get(vtkObjName, 1)
        if num_i == 1 and input_conns > 1:
            ip_types = input_conns * [ip_typ]

        # we need a tuple for creating the DeVIDE module
        ip_types = tuple(ip_types)

        # do the same for the outputs
        num_o = vtkObj.GetNumberOfOutputPorts()
        op_types = []
        for i in range(num_o):
            op_inf = vtkObj.GetOutputPortInformation(i)
            op_typ = op_inf.Get(vtk.vtkDataObject.DATA_TYPE_NAME())
            op_types.append(op_typ)

        op_types = tuple(op_types)

        # and create the module
        moduleName = vtkObjName
        moduleText = moduleSkeleton1 % (moduleName, vtkObjName,
                                        'Processing.',
                                        ip_types, op_types,
                                        None, None)

        return (moduleName, moduleText, 'VTK basic filters', vtkObj.__doc__)


def main():
    list1 = [i for i in dir(vtk)
             if i.startswith('vtk') and i not in excludeList]

    # handle exclusion regular expression pattern objects here
    list1b = []
    for i in list1:
        exclude = False
        for po in exclude_pos:
            if po.match(i):
                exclude = True
                break

        if not exclude:
            list1b.append(i)

    # bind the old list name to the new list
    list1 = list1b
            
    
    # start second phase of checking
    list2 = []
    # objects that can be instantiated 
    for vtkobj in list1:
        try:
            print vtkobj
            a = getattr(vtk, vtkobj)()
        except:
            # if it can't be instantiated, we can't use it
            pass
        else:
            if a.IsA('vtkAlgorithm'):
                list2.append(vtkobj)

    # list2 will now be parsed and modules will be generated
    # we have to start our conditionals with the most specific cases
    # and work down to the more general cases.
    moduleListStrings = ['# Generated by '\
                         'DeVIDE::createDeVIDEModuleFromVTKObject\n']

    for vtkObjName in list2:
        moduleName, moduleText, moduleCats, module_doc = \
                    createDeVIDEModuleFromVTKObject(vtkObjName)
        
        if moduleName:
            f = open('%s.py' % (moduleName,), 'w')
            f.write(moduleText)

            moduleListStrings.append("class %s:" % (moduleName,))
            moduleListStrings.append("    kits = ['vtk_kit']")
            moduleListStrings.append("    cats = ['%s']\n" % (moduleCats,))
            moduleListStrings.append("    help = \\")
            moduleListStrings.append(
                "         \"\"\"%s\n\"\"\"" % (module_doc,))

            #moduleListStrings.append("'%s' : %s," % (moduleName, moduleCats))
            f.close()
            print "Wrote %s.py." % (moduleName,)

    if len(moduleListStrings):
        # snip off the last ,
        #moduleListStrings[-1] = moduleListStrings[-1][:-1]
        moduleListString = '\n'.join(moduleListStrings)

        f = open('module_index.py', 'w')
        f.write(moduleListString)
        f.close()
        print "\nWrote module_index.py.\n"


if __name__ == '__main__':
    main()
