# Generated by DeVIDE::createDeVIDEModuleFromVTKObject

class vtkAVIWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkAVIWriter - Writes Windows AVI files.

Super Class:

 vtkGenericMovieWriter

 vtkAVIWriter writes AVI files. The data type
 of the file is unsigned char regardless of the input type.

See Also:

 vtkGenericMovieWriter vtkMPEG2Writer


"""
class vtkAVSucdReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkAVSucdReader - reads a dataset in AVS "UCD" format

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkAVSucdReader creates an unstructured grid dataset. It reads binary or
 ASCII files stored in UCD format, with optional data stored at the nodes
 or at the cells of the model. A cell-based fielddata stores the material
 id. The class can automatically detect the endian-ness of the binary files.

See Also:

 vtkGAMBITReader


"""
class vtkAppendFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkAppendFilter - appends one or more datasets together into a single unstructured grid

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkAppendFilter is a filter that appends one of more datasets into a single
 unstructured grid. All geometry is extracted and appended, but point 
 attributes (i.e., scalars, vectors, normals, field data, etc.) are extracted 
 and appended only if all datasets have the point attributes available. 
 (For example, if one dataset has scalars but another does not, scalars will 
 not be appended.)

See Also:

 vtkAppendPolyData


"""
class vtkAppendPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkAppendPolyData - appends one or more polygonal datasets together

Super Class:

 vtkPolyDataAlgorithm

 
 vtkAppendPolyData is a filter that appends one of more polygonal datasets
 into a single polygonal dataset. All geometry is extracted and appended,
 but point and cell attributes (i.e., scalars, vectors, normals) are
 extracted and appended only if all datasets have the point and/or cell
 attributes available.  (For example, if one dataset has point scalars but
 another does not, point scalars will not be appended.)

See Also:

 vtkAppendFilter


"""
class vtkAppendSelection:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkAppendSelection - appends one or more selections together

Super Class:

 vtkSelectionAlgorithm

 vtkAppendSelection is a filter that appends one of more selections into
 a single selection.  All selections must have the same content type.


"""
class vtkArcPlotter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkArcPlotter - plot data along an arbitrary polyline

Super Class:

 vtkPolyDataAlgorithm

 vtkArcPlotter performs plotting of attribute data along polylines defined
 with an input vtkPolyData data object. Any type of attribute data can be
 plotted including scalars, vectors, tensors, normals, texture coordinates,
 and field data. Either one or multiple data components can be plotted.
 
 To use this class you must specify an input data set that contains one or
 more polylines, and some attribute data including which component of the
 attribute data. (By default, this class processes the first component of
 scalar data.) You will also need to set an offset radius (the distance
 of the polyline to the median line of the plot), a width for the plot
 (the distance that the minimum and maximum plot values are mapped into),
 an possibly an offset (used to offset attribute data with multiple
 components).
 
 Normally the filter automatically computes normals for generating the
 offset arc plot. However, you can specify a default normal and use that
 instead.

See Also:

 vtkXYPlotActor


"""
class vtkArrayCalculator:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkArrayCalculator - perform mathematical operations on data in field data arrays

Super Class:

 vtkDataSetAlgorithm

 vtkArrayCalculator performs operations on vectors or scalars in field
 data arrays.  It uses vtkFunctionParser to do the parsing and to
 evaluate the function for each entry in the input arrays.  The arrays
 used in a given function must be all in point data or all in cell data.
 The resulting array will be stored as a field data array.  The result
 array can either be stored in a new array or it can overwrite an existing
 array.

 The functions that this array calculator understands is:
 <pre>
 standard operations: + - * / ^ .
 access vector components: iHat, jHat, kHat
 abs
 acos
 asin
 atan
 ceil
 cos
 cosh
 exp
 floor
 log
 mag
 min
 max
 norm
 sign
 sin
 sinh
 sqrt
 tan
 tanh
 </pre>
 Note that some of these operations work on scalars, some on vectors, and some on
 both (e.g., you can multiply a scalar times a vector). The operations are performed
 tuple-wise (i.e., tuple-by-tuple). The user must specify which arrays to use as
 vectors and/or scalars, and the name of the output data array.


See Also:

 vtkFunctionParser


"""
class vtkArrowSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkArrowSource - Appends a cylinder to a cone to form an arrow.

Super Class:

 vtkPolyDataAlgorithm

 vtkArrowSource was intended to be used as the source for a glyph.
 The shaft base is always at (0,0,0). The arrow tip is always at (1,0,0).
 The resolution of the cone and shaft can be set and default to 6.
 The radius of the cone and shaft can be set and default to 0.03 and 0.1.
 The length of the tip can also be set, and defaults to 0.35.


"""
class vtkAssignAttribute:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkAssignAttribute - Labels a field as an attribute

Super Class:

 vtkDataSetAlgorithm

 vtkAssignAttribute is use to label a field (vtkDataArray) as an attribute.
 A field name or an attribute to labeled can be specified. For example:
 @verbatim
 aa->Assign("foo", vtkDataSetAttributes::SCALARS, 
            vtkAssignAttribute::POINT_DATA);
 @endverbatim
 tells vtkAssignAttribute to make the array in the point data called
 "foo" the active scalars. On the other hand,
 @verbatim
 aa->Assign(vtkDataSetAttributes::VECTORS, vtkDataSetAttributes::SCALARS, 
            vtkAssignAttribute::POINT_DATA);
 @endverbatim
 tells vtkAssignAttribute to make the active vectors also the active
 scalars. The same can be done more easily from Tcl by using the Assign()
 method which takes strings:
 @verbatim
 aa Assign "foo" SCALARS POINT_DATA 
 or
 aa Assign SCALARS VECTORS POINT_DATA

 AttributeTypes: SCALARS, VECTORS, NORMALS, TCOORDS, TENSORS
 Attribute locations: POINT_DATA, CELL_DATA
 @endverbatim

Caveats:

 When using Tcl, Java, Python or Visual Basic bindings, the array name 
 can not be one of the  AttributeTypes when calling Assign() which takes
 strings as arguments. The Tcl (Java etc.) command will
 always assume the string corresponds to an attribute type when
 the argument is one of the AttributeTypes. In this situation,
 use the Assign() which takes enums.

See Also:

 vtkFieldData vtkDataSet vtkDataObjectToDataSetFilter
 vtkDataSetAttributes vtkDataArray vtkRearrangeFields
 vtkSplitField vtkMergeFields


"""
class vtkAttributeDataToFieldDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkAttributeDataToFieldDataFilter - map attribute data to field data

Super Class:

 vtkDataSetAlgorithm

 vtkAttributeDataToFieldDataFilter is a class that maps attribute data into
 field data. Since this filter is a subclass of vtkDataSetAlgorithm,
 the output dataset (whose structure is the same as the input dataset),
 will contain the field data that is generated. The filter will convert
 point and cell attribute data to field data and assign it as point and
 cell field data, replacing any point or field data that was there
 previously. By default, the original non-field point and cell attribute
 data will be passed to the output of the filter, although you can shut
 this behavior down.

Caveats:

 Reference counting the underlying data arrays is used to create the field
 data.  Therefore, no extra memory is utilized.

 The original field data (if any) associated with the point and cell
 attribute data is placed into the generated fields along with the scalars,
 vectors, etc.

See Also:

 vtkFieldData vtkDataObject vtkDataSet vtkFieldDataToAttributeDataFilter


"""
class vtkAxes:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkAxes - create an x-y-z axes

Super Class:

 vtkPolyDataAlgorithm

 vtkAxes creates three lines that form an x-y-z axes. The origin of the
 axes is user specified (0,0,0 is default), and the size is specified with
 a scale factor. Three scalar values are generated for the three lines and
 can be used (via color map) to indicate a particular coordinate axis.


"""
class vtkBMPReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkBMPReader - read Windows BMP files

Super Class:

 vtkImageReader

 vtkBMPReader is a source object that reads Windows BMP files.
 This includes indexed and 24bit bitmaps
 Usually, all BMPs are converted to 24bit RGB, but BMPs may be output
 as 8bit images with a LookupTable if the Allow8BitBMP flag is set.

 BMPReader creates structured point datasets. The dimension of the 
 dataset depends upon the number of files read. Reading a single file 
 results in a 2D image, while reading more than one file results in a 
 3D volume.

 To read a volume, files must be of the form "FileName.<number>"
 (e.g., foo.bmp.0, foo.bmp.1, ...). You must also specify the image 
 range. This range specifies the beginning and ending files to read (range
 can be any pair of non-negative numbers). 

 The default behavior is to read a single file. In this case, the form
 of the file is simply "FileName" (e.g., foo.bmp).

See Also:

 vtkBMPWriter


"""
class vtkBMPWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkBMPWriter - Writes Windows BMP files.

Super Class:

 vtkImageWriter

 vtkBMPWriter writes BMP files. The data type
 of the file is unsigned char regardless of the input type.

See Also:

 vtkBMPReader


"""
class vtkBYUReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkBYUReader - read MOVIE.BYU polygon files

Super Class:

 vtkPolyDataAlgorithm

 vtkBYUReader is a source object that reads MOVIE.BYU polygon files.
 These files consist of a geometry file (.g), a scalar file (.s), a 
 displacement or vector file (.d), and a 2D texture coordinate file
 (.t).


"""
class vtkBYUWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkBYUWriter - write MOVIE.BYU files

Super Class:

 vtkPolyDataWriter

 vtkBYUWriter writes MOVIE.BYU polygonal files. These files consist 
 of a geometry file (.g), a scalar file (.s), a displacement or 
 vector file (.d), and a 2D texture coordinate file (.t). These files 
 must be specified to the object, the appropriate boolean 
 variables must be true, and data must be available from the input
 for the files to be written.
 WARNING: this writer does not currently write triangle strips. Use
 vtkTriangleFilter to convert strips to triangles.


"""
class vtkBandedPolyDataContourFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkBandedPolyDataContourFilter - generate filled contours for vtkPolyData

Super Class:

 vtkPolyDataAlgorithm

 vtkBandedPolyDataContourFilter is a filter that takes as input vtkPolyData
 and produces as output filled contours (also represented as vtkPolyData).
 Filled contours are bands of cells that all have the same cell scalar
 value, and can therefore be colored the same. The method is also referred
 to as filled contour generation.

 To use this filter you must specify one or more contour values.  You can
 either use the method SetValue() to specify each contour value, or use
 GenerateValues() to generate a series of evenly spaced contours.  Each
 contour value divides (or clips) the data into two pieces, values below
 the contour value, and values above it. The scalar values of each
 band correspond to the specified contour value.  Note that if the first and
 last contour values are not the minimum/maximum contour range, then two
 extra contour values are added corresponding to the minimum and maximum
 range values. These extra contour bands can be prevented from being output
 by turning clipping on.


See Also:

 vtkClipDataSet vtkClipPolyData vtkClipVolume vtkContourFilter



"""
class vtkBlankStructuredGrid:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkBlankStructuredGrid - translate point attribute data into a blanking field

Super Class:

 vtkStructuredGridAlgorithm

 vtkBlankStructuredGrid is a filter that sets the blanking field in a 
 vtkStructuredGrid dataset. The blanking field is set by examining a
 specified point attribute data array (e.g., scalars) and converting
 values in the data array to either a "1" (visible) or "0" (blanked) value
 in the blanking array. The values to be blanked are specified by giving
 a min/max range. All data values in the data array indicated and laying
 within the range specified (inclusive on both ends) are translated to 
 a "off" blanking value.

See Also:

 vtkStructuredGrid


"""
class vtkBlankStructuredGridWithImage:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkBlankStructuredGridWithImage - blank a structured grid with an image

Super Class:

 vtkStructuredGridAlgorithm

 This filter can be used to set the blanking in a structured grid with 
 an image. The filter takes two inputs: the structured grid to blank, 
 and the image used to set the blanking. Make sure that the dimensions of
 both the image and the structured grid are identical.

 Note that the image is interpreted as follows: zero values indicate that
 the structured grid point is blanked; non-zero values indicate that the
 structured grid point is visible. The blanking data must be unsigned char.

See Also:

 vtkStructuredGrid


"""
class vtkBooleanTexture:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkBooleanTexture - generate 2D texture map based on combinations of inside, outside, and on region boundary

Super Class:

 vtkImageAlgorithm

 vtkBooleanTexture is a filter to generate a 2D texture map based on 
 combinations of inside, outside, and on region boundary. The "region" is
 implicitly represented via 2D texture coordinates. These texture 
 coordinates are normally generated using a filter like 
 vtkImplicitTextureCoords, which generates the texture coordinates for 
 any implicit function.

 vtkBooleanTexture generates the map according to the s-t texture
 coordinates plus the notion of being in, on, or outside of a
 region. An in region is when the texture coordinate is between
 (0,0.5-thickness/2).  An out region is where the texture coordinate
 is (0.5+thickness/2). An on region is between
 (0.5-thickness/2,0.5+thickness/2). The combination in, on, and out
 for each of the s-t texture coordinates results in 16 possible
 combinations (see text). For each combination, a different value of 
 intensity and transparency can be assigned. To assign maximum intensity
 and/or opacity use the value 255. A minimum value of 0 results in
 a black region (for intensity) and a fully transparent region (for
 transparency).

See Also:

 vtkImplicitTextureCoords vtkThresholdTextureCoords


"""
class vtkBoxClipDataSet:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkBoxClipDataSet - clip an unstructured grid

Super Class:

 vtkUnstructuredGridAlgorithm

 Clipping means that is actually 'cuts' through the cells of the dataset,
 returning tetrahedral cells inside of the box.
 The output of this filter is an unstructured grid.

 This filter can be configured to compute a second output. The
 second output is the part of the cell that is clipped away. Set the
 GenerateClippedData boolean on if you wish to access this output data.

 The vtkBoxClipDataSet will triangulate all types of 3D cells (i.e, create tetrahedra).
 This is necessary to preserve compatibility across face neighbors.

 To use this filter,you can decide if you will be clipping with a box or a hexahedral box.
 1) Set orientation 
    if(SetOrientation(0)): box (parallel with coordinate axis)
       SetBoxClip(xmin,xmax,ymin,ymax,zmin,zmax)  
    if(SetOrientation(1)): hexahedral box (Default)
       SetBoxClip(n[0],o[0],n[1],o[1],n[2],o[2],n[3],o[3],n[4],o[4],n[5],o[5])  
       PlaneNormal[] normal of each plane
       PlanePoint[] point on the plane 
 2) Apply the GenerateClipScalarsOn() 
 3) Execute clipping  Update();


"""
class vtkBrownianPoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkBrownianPoints - assign random vector to points

Super Class:

 vtkDataSetAlgorithm

 vtkBrownianPoints is a filter object that assigns a random vector (i.e.,
 magnitude and direction) to each point. The minimum and maximum speed
 values can be controlled by the user.


"""
class vtkButterflySubdivisionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkButterflySubdivisionFilter - generate a subdivision surface using the Butterfly Scheme

Super Class:

 vtkInterpolatingSubdivisionFilter

 vtkButterflySubdivisionFilter is an interpolating subdivision scheme
 that creates four new triangles for each triangle in the mesh. The
 user can specify the NumberOfSubdivisions. This filter implements the
 8-point butterfly scheme described in: Zorin, D., Schroder, P., and
 Sweldens, W., "Interpolating Subdivisions for Meshes with Arbitrary
 Topology," Computer Graphics Proceedings, Annual Conference Series,
 1996, ACM SIGGRAPH, pp.189-192. This scheme improves previous
 butterfly subdivisions with special treatment of vertices with valence
 other than 6.
 
 Currently, the filter only operates on triangles. Users should use the
 vtkTriangleFilter to triangulate meshes that contain polygons or
 triangle strips.
 
 The filter interpolates point data using the same scheme. New
 triangles created at a subdivision step will have the cell data of
 their parent cell.

See Also:

 vtkInterpolatingSubdivisionFilter vtkLinearSubdivisionFilter


"""
class vtkCGMWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkCGMWriter - write polygonal data as a CGM file

Super Class:

 vtkPolyDataWriter

 vtkCGMWriter writes CGM (Computer Graphics Metafile) output. CGM is a 2D
 graphics vector format typically used by large plotters. This writer can 
 handle vertices, lines, polygons, and triangle strips in any combination. 
 Colors are specified either 1) from cell scalars (assumed to be RGB or 
 RGBA color specification), 2) from a specified color; or 3) randomly 
 assigned colors.

 Note: During output of the polygonal data, triangle strips are converted
 to triangles, and polylines to lines. Also, due to limitations in the CGM 
 color model, only 256 colors are available to the color palette.

Caveats:

 The class vtkImageToPolyDataFilter is convenient for converting a raster
 image into polygons (and color map) suitable for plotting with CGM.

See Also:

 vtkPolyDataWriter vtkPointDataToCellData


"""
class vtkCastToConcrete:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCastToConcrete - works around type-checking limitations

Super Class:

 vtkDataSetAlgorithm

 vtkCastToConcrete is a filter that works around type-checking limitations
 in the filter classes. Some filters generate abstract types on output, 
 and cannot be connected to the input of filters requiring a concrete
 input type. For example, vtkElevationFilter generates vtkDataSet for output,
 and cannot be connected to vtkDecimate, because vtkDecimate requires 
 vtkPolyData as input. This is true even though (in this example) the input 
 to vtkElevationFilter is of type vtkPolyData, and you know the output of 
 vtkElevationFilter is the same type as its input.

 vtkCastToConcrete performs run-time checking to insure that output type
 is of the right type. An error message will result if you try to cast
 an input type improperly. Otherwise, the filter performs the appropriate
 cast and returns the data.

Caveats:

 You must specify the input before you can get the output. Otherwise an
 error results.

See Also:

 vtkDataSetAlgorithm vtkPointSetToPointSetFilter


"""
class vtkCellCenters:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCellCenters - generate points at center of cells

Super Class:

 vtkPolyDataAlgorithm

 vtkCellCenters is a filter that takes as input any dataset and 
 generates on output points at the center of the cells in the dataset.
 These points can be used for placing glyphs (vtkGlyph3D) or labeling 
 (vtkLabeledDataMapper). (The center is the parametric center of the
 cell, not necessarily the geometric or bounding box center.) The cell
 attributes will be associated with the points on output.
 

Caveats:

 You can choose to generate just points or points and vertex cells.
 Vertex cells are drawn during rendering; points are not. Use the ivar
 VertexCells to generate cells.

See Also:

 vtkGlyph3D vtkLabeledDataMapper


"""
class vtkCellDataToPointData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCellDataToPointData - map cell data to point data

Super Class:

 vtkDataSetAlgorithm

 vtkCellDataToPointData is a filter that transforms cell data (i.e., data
 specified per cell) into point data (i.e., data specified at cell
 points). The method of transformation is based on averaging the data
 values of all cells using a particular point. Optionally, the input cell
 data can be passed through to the output as well.

Caveats:

 This filter is an abstract filter, that is, the output is an abstract type
 (i.e., vtkDataSet). Use the convenience methods (e.g.,
 GetPolyDataOutput(), GetStructuredPointsOutput(), etc.) to get the type
 of output you want.

See Also:

 vtkPointData vtkCellData vtkPointDataToCellData


"""
class vtkCellDerivatives:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCellDerivatives - compute derivatives of scalars and vectors

Super Class:

 vtkDataSetAlgorithm

 vtkCellDerivatives is a filter that computes derivatives of scalars
 and vectors at the center of cells. You can choose to generate
 different output including the scalar gradient (a vector), computed
 tensor vorticity (a vector), gradient of input vectors (a tensor),
 and strain matrix of the input vectors (a tensor); or you may
 choose to pass data through to the output.

 Note that it is assumed that on input scalars and vector point data
 is available, which are then used to generate cell vectors and tensors.
 (The interpolation functions of the cells are used to compute the
 derivatives which is why point data is required.)

Caveats:

 The computed derivatives are cell attribute data; you can convert them to
 point attribute data by using the vtkCellDataToPointData filter.
 Note that, due to the interpolation function used (obtained using 
 1/r**2 normalized sum), the derivatives calculated for polygons
 with more than 4 vertices are inaccurate in most cases.

 The point data is passed through the filter to the output.

See Also:

 vtkVectorNorm


"""
class vtkChacoReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkChacoReader - Read a Chaco file and create a vtkUnstructuredGrid. 

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkChacoReader is an unstructured grid source object that reads Chaco
 files.  The reader DOES NOT respond to piece requests. Chaco
 is a graph partitioning package developed at Sandia National Laboratories
 in the early 1990s.  (http://www.cs.sandia.gov/~bahendr/chaco.html)

 Note that the Chaco "edges" become VTK "cells", and the Chaco
 "vertices" become VTK "points".


"""
class vtkCleanPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCleanPolyData - merge duplicate points, and/or remove unused points and/or remove degenerate cells

Super Class:

 vtkPolyDataAlgorithm

 vtkCleanPolyData is a filter that takes polygonal data as input and
 generates polygonal data as output. vtkCleanPolyData can merge duplicate
 points (within specified tolerance and if enabled), eliminate points
 that are not used, and if enabled, transform degenerate cells into
 appropriate forms (for example, a triangle is converted into a line
 if two points of triangle are merged).

 Conversion of degenerate cells is controlled by the flags
 ConvertLinesToPoints, ConvertPolysToLines, ConvertStripsToPolys which act
 cumulatively such that a degenerate strip may become a poly.
 The full set is
 Line with 1 points -> Vert (if ConvertLinesToPoints)
 Poly with 2 points -> Line (if ConvertPolysToLines)
 Poly with 1 points -> Vert (if ConvertPolysToLines && ConvertLinesToPoints)
 Strp with 3 points -> Poly (if ConvertStripsToPolys)
 Strp with 2 points -> Line (if ConvertStripsToPolys && ConvertPolysToLines)
 Strp with 1 points -> Vert (if ConvertStripsToPolys && ConvertPolysToLines
   && ConvertLinesToPoints)

 If tolerance is specified precisely=0.0, then vtkCleanPolyData will use
 the vtkMergePoints object to merge points (which is faster). Otherwise the
 slower vtkPointLocator is used.  Before inserting points into the point
 locator, this class calls a function OperateOnPoint which can be used (in
 subclasses) to further refine the cleaning process. See
 vtkQuantizePolyDataPoints.

 Note that merging of points can be disabled. In this case, a point locator
 will not be used, and points that are not used by any cells will be
 eliminated, but never merged.

Caveats:

 Merging points can alter topology, including introducing non-manifold
 forms. The tolerance should be chosen carefully to avoid these problems.
 Subclasses should handle OperateOnBounds as well as OperateOnPoint
 to ensure that the locator is correctly initialized (i.e. all modified
 points must lie inside modified bounds).


See Also:

 vtkQuantizePolyDataPoints


"""
class vtkClipDataSet:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkClipDataSet - clip any dataset with user-specified implicit function or input scalar data

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkClipDataSet is a filter that clips any type of dataset using either
 any subclass of vtkImplicitFunction, or the input scalar
 data. Clipping means that it actually "cuts" through the cells of
 the dataset, returning everything inside of the specified implicit
 function (or greater than the scalar value) including "pieces" of
 a cell. (Compare this with vtkExtractGeometry, which pulls out
 entire, uncut cells.) The output of this filter is an unstructured
 grid.

 To use this filter, you must decide if you will be clipping with an
 implicit function, or whether you will be using the input scalar
 data.  If you want to clip with an implicit function, you must:
 1) define an implicit function
 2) set it with the SetClipFunction method
 3) apply the GenerateClipScalarsOn method
 If a ClipFunction is not specified, or GenerateClipScalars is off
 (the default), then the input's scalar data will be used to clip
 the polydata.

 You can also specify a scalar value, which is used to decide what is
 inside and outside of the implicit function. You can also reverse the
 sense of what inside/outside is by setting the InsideOut instance
 variable. (The clipping algorithm proceeds by computing an implicit
 function value or using the input scalar data for each point in the
 dataset. This is compared to the scalar value to determine
 inside/outside.)

 This filter can be configured to compute a second output. The
 second output is the part of the cell that is clipped away. Set the
 GenerateClippedData boolean on if you wish to access this output data.

Caveats:

 vtkClipDataSet will triangulate all types of 3D cells (i.e., create
 tetrahedra). This is true even if the cell is not actually cut. This
 is necessary to preserve compatibility across face neighbors. 2D cells
 will only be triangulated if the cutting function passes through them.

See Also:

 vtkImplicitFunction vtkCutter vtkClipVolume vtkClipPolyData


"""
class vtkClipHyperOctree:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkClipHyperOctree - clip an hyperoctree with user-specified implicit function or input scalar data

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkClipHyperOctree is a filter that clips an hyperoctree using either
 any subclass of vtkImplicitFunction, or the input scalar
 data. Clipping means that it actually "cuts" through the leaves (cells) of
 the hyperoctree, returning everything inside of the specified implicit
 function (or greater than the scalar value) including "pieces" of
 a cell. (Compare this with vtkExtractGeometry, which pulls out
 entire, uncut cells.) The output of this filter is an unstructured
 grid.

 To use this filter, you must decide if you will be clipping with an
 implicit function, or whether you will be using the input scalar
 data.  If you want to clip with an implicit function, you must:
 1) define an implicit function
 2) set it with the SetClipFunction method
 3) apply the GenerateClipScalarsOn method
 If a ClipFunction is not specified, or GenerateClipScalars is off
 (the default), then the input's scalar data will be used to clip
 the polydata.

 You can also specify a scalar value, which is used to decide what is
 inside and outside of the implicit function. You can also reverse the
 sense of what inside/outside is by setting the InsideOut instance
 variable. (The clipping algorithm proceeds by computing an implicit
 function value or using the input scalar data for each point in the
 dataset. This is compared to the scalar value to determine
 inside/outside.)

 This filter can be configured to compute a second output. The
 second output is the part of the cell that is clipped away. Set the
 GenerateClippedData boolean on if you wish to access this output data.

Caveats:

 vtkClipHyperOctree will triangulate all types of 3D cells (i.e., create
 tetrahedra). This is true even if the cell is not actually cut. This
 is necessary to preserve compatibility across face neighbors. 2D cells
 will only be triangulated if the cutting function passes through them.

See Also:

 vtkImplicitFunction vtkCutter vtkClipVolume vtkClipPolyData


"""
class vtkClipPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkClipPolyData - clip polygonal data with user-specified implicit function or input scalar data

Super Class:

 vtkPolyDataAlgorithm

 vtkClipPolyData is a filter that clips polygonal data using either
 any subclass of vtkImplicitFunction, or the input scalar
 data. Clipping means that it actually "cuts" through the cells of
 the dataset, returning everything inside of the specified implicit
 function (or greater than the scalar value) including "pieces" of
 a cell. (Compare this with vtkExtractGeometry, which pulls out
 entire, uncut cells.) The output of this filter is polygonal data.

 To use this filter, you must decide if you will be clipping with an
 implicit function, or whether you will be using the input scalar
 data.  If you want to clip with an implicit function, you must:
 1) define an implicit function
 2) set it with the SetClipFunction method
 3) apply the GenerateClipScalarsOn method
 If a ClipFunction is not specified, or GenerateClipScalars is off
 (the default), then the input's scalar data will be used to clip
 the polydata.

 You can also specify a scalar value, which is used to
 decide what is inside and outside of the implicit function. You can
 also reverse the sense of what inside/outside is by setting the
 InsideOut instance variable. (The cutting algorithm proceeds by
 computing an implicit function value or using the input scalar data
 for each point in the dataset. This is compared to the scalar value
 to determine inside/outside.)

 This filter can be configured to compute a second output. The
 second output is the polygonal data that is clipped away. Set the
 GenerateClippedData boolean on if you wish to access this output data.

Caveats:

 In order to cut all types of cells in polygonal data, vtkClipPolyData
 triangulates some cells, and then cuts the resulting simplices
 (i.e., points, lines, and triangles). This means that the resulting 
 output may consist of different cell types than the input data.

See Also:

 vtkImplicitFunction vtkCutter vtkClipVolume


"""
class vtkClipVolume:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkClipVolume - clip volume data with user-specified implicit function or input scalar data

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkClipVolume is a filter that clips volume data (i.e., vtkImageData)
 using either: any subclass of vtkImplicitFunction or the input scalar
 data. The clipping operation cuts through the cells of the
 dataset--converting 3D image data into a 3D unstructured grid--returning
 everything inside of the specified implicit function (or greater than the
 scalar value). During the clipping the filter will produce pieces of a
 cell. (Compare this with vtkExtractGeometry or vtkGeometryFilter, which
 produces entire, uncut cells.) The output of this filter is a 3D
 unstructured grid (e.g., tetrahedra or other 3D cell types).

 To use this filter, you must decide if you will be clipping with an
 implicit function, or whether you will be using the input scalar data.  If
 you want to clip with an implicit function, you must first define and then
 set the implicit function with the SetClipFunction() method. Otherwise,
 you must make sure input scalar data is available. You can also specify a
 scalar value, which is used to decide what is inside and outside of the
 implicit function. You can also reverse the sense of what inside/outside
 is by setting the InsideOut instance variable. (The cutting algorithm
 proceeds by computing an implicit function value or using the input scalar
 data for each point in the dataset. This is compared to the scalar value
 to determine inside/outside.)

 This filter can be configured to compute a second output. The
 second output is the portion of the volume that is clipped away. Set the
 GenerateClippedData boolean on if you wish to access this output data.

 The filter will produce an unstructured grid of entirely tetrahedra or a
 mixed grid of tetrahedra and other 3D cell types (e.g., wedges). Control
 this behavior by setting the Mixed3DCellGeneration. By default the
 Mixed3DCellGeneration is on and a combination of cell types will be
 produced. Note that producing mixed cell types is a faster than producing
 only tetrahedra.

Caveats:

 This filter is designed to function with 3D structured points. Clipping
 2D images should be done by converting the image to polygonal data
 and using vtkClipPolyData,

See Also:

 vtkImplicitFunction vtkClipPolyData vtkGeometryFilter vtkExtractGeometry


"""
class vtkConeSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkConeSource - generate polygonal cone 

Super Class:

 vtkPolyDataAlgorithm

 vtkConeSource creates a cone centered at a specified point and pointing in
 a specified direction. (By default, the center is the origin and the
 direction is the x-axis.) Depending upon the resolution of this object,
 different representations are created. If resolution=0 a line is created;
 if resolution=1, a single triangle is created; if resolution=2, two
 crossed triangles are created. For resolution > 2, a 3D cone (with
 resolution number of sides) is created. It also is possible to control
 whether the bottom of the cone is capped with a (resolution-sided)
 polygon, and to specify the height and radius of the cone.


"""
class vtkConnectivityFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkConnectivityFilter - extract data based on geometric connectivity

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkConnectivityFilter is a filter that extracts cells that share common
 points and/or meet other connectivity criterion. (Cells that share
 vertices and meet other connectivity criterion such as scalar range are
 known as a region.)  The filter works in one of six ways: 1) extract the
 largest connected region in the dataset; 2) extract specified region
 numbers; 3) extract all regions sharing specified point ids; 4) extract
 all regions sharing specified cell ids; 5) extract the region closest to
 the specified point; or 6) extract all regions (used to color the data by
 region).

 vtkConnectivityFilter is generalized to handle any type of input dataset.
 It generates output data of type vtkUnstructuredGrid. If you know that
 your input type is vtkPolyData, you may wish to use
 vtkPolyDataConnectivityFilter.

 The behavior of vtkConnectivityFilter can be modified by turning on the
 boolean ivar ScalarConnectivity. If this flag is on, the connectivity
 algorithm is modified so that cells are considered connected only if 1)
 they are geometrically connected (share a point) and 2) the scalar values
 of one of the cell's points falls in the scalar range specified. This use
 of ScalarConnectivity is particularly useful for volume datasets: it can
 be used as a simple "connected segmentation" algorithm. For example, by
 using a seed voxel (i.e., cell) on a known anatomical structure,
 connectivity will pull out all voxels "containing" the anatomical
 structure. These voxels can then be contoured or processed by other
 visualization filters.

See Also:

 vtkPolyDataConnectivityFilter


"""
class vtkContourFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkContourFilter - generate isosurfaces/isolines from scalar values

Super Class:

 vtkPolyDataAlgorithm

 vtkContourFilter is a filter that takes as input any dataset and 
 generates on output isosurfaces and/or isolines. The exact form 
 of the output depends upon the dimensionality of the input data. 
 Data consisting of 3D cells will generate isosurfaces, data 
 consisting of 2D cells will generate isolines, and data with 1D 
 or 0D cells will generate isopoints. Combinations of output type 
 are possible if the input dimension is mixed.

 To use this filter you must specify one or more contour values.
 You can either use the method SetValue() to specify each contour
 value, or use GenerateValues() to generate a series of evenly
 spaced contours. It is also possible to accelerate the operation of
 this filter (at the cost of extra memory) by using a
 vtkScalarTree. A scalar tree is used to quickly locate cells that
 contain a contour surface. This is especially effective if multiple
 contours are being extracted. If you want to use a scalar tree,
 invoke the method UseScalarTreeOn().

Caveats:

 For unstructured data or structured grids, normals and gradients
 are not computed. Use vtkPolyDataNormals to compute the surface
 normals.

See Also:

 vtkMarchingContourFilter vtkMarchingCubes vtkSliceCubes
 vtkMarchingSquares vtkImageMarchingCubes


"""
class vtkContourGrid:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkContourGrid - generate isosurfaces/isolines from scalar values (specialized for unstructured grids)

Super Class:

 vtkPolyDataAlgorithm

 vtkContourGrid is a filter that takes as input datasets of type
 vtkUnstructuredGrid and generates on output isosurfaces and/or
 isolines. The exact form of the output depends upon the dimensionality of
 the input data.  Data consisting of 3D cells will generate isosurfaces,
 data consisting of 2D cells will generate isolines, and data with 1D or 0D
 cells will generate isopoints. Combinations of output type are possible if
 the input dimension is mixed.

 To use this filter you must specify one or more contour values.
 You can either use the method SetValue() to specify each contour
 value, or use GenerateValues() to generate a series of evenly
 spaced contours. It is also possible to accelerate the operation of
 this filter (at the cost of extra memory) by using a
 vtkScalarTree. A scalar tree is used to quickly locate cells that
 contain a contour surface. This is especially effective if multiple
 contours are being extracted. If you want to use a scalar tree,
 invoke the method UseScalarTreeOn().


Caveats:

 For unstructured data or structured grids, normals and gradients
 are not computed. Use vtkPolyDataNormals to compute the surface
 normals of the resulting isosurface.

See Also:

 vtkMarchingContourFilter vtkKitwareContourFilter
 vtkMarchingCubes vtkSliceCubes vtkDividingCubes vtkMarchingSquares
 vtkImageMarchingCubes


"""
class vtkConvertSelection:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkConvertSelection - 

Super Class:

 vtkSelectionAlgorithm

 vtkConvertSelection

 .SECTION Thanks


See Also:



"""
class vtkCubeSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCubeSource - create a polygonal representation of a cube

Super Class:

 vtkPolyDataAlgorithm

 vtkCubeSource creates a cube centered at origin. The cube is represented
 with four-sided polygons. It is possible to specify the length, width, 
 and height of the cube independently.


"""
class vtkCursor2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCursor2D - generate a 2D cursor representation

Super Class:

 vtkPolyDataAlgorithm

 vtkCursor2D is a class that generates a 2D cursor representation.
 The cursor consists of two intersection axes lines that meet at the
 cursor focus. Several optional features are available as well. An 
 optional 2D bounding box may be enabled. An inner radius, centered at
 the focal point, can be set that erases the intersecting lines (e.g.,
 it leaves a clear area under the focal point so you can see
 what you are selecting). And finally, an optional point can be
 enabled located at the focal point. All of these features can be turned
 on and off independently.



"""
class vtkCurvatures:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCurvatures - compute curvatures (Gauss and mean) of a Polydata object

Super Class:

 vtkPolyDataAlgorithm

 vtkCurvatures takes a polydata input and computes the curvature of the
 mesh at each point. Four possible methods of computation are available :

 Gauss Curvature
 discrete Gauss curvature (K) computation,
 \f$K(vertex v) = 2*PI-\sum_{facet neighbs f of v} (angle_f at v)\f$
 The contribution of every facet is for the moment weighted by \f$Area(facet)/3\f$
 The units of Gaussian Curvature are \f$[1/m^2]\f$

 Mean Curvature
 \f$H(vertex v) = average over edges neighbs e of H(e)\f$
 \f$H(edge e) = length(e)*dihedral_angle(e)\f$
 NB: dihedral_angle is the ORIENTED angle between -PI and PI,
 this means that the surface is assumed to be orientable
 the computation creates the orientation
 The units of Mean Curvature are [1/m]

 Maximum (\f$k_max\f$) and Minimum (\f$k_min\f$) Principal Curvatures
 \f$k_max = H + sqrt(H^2 - K)\f$
 \f$k_min = H - sqrt(H^2 - K)\f$
 Excepting spherical and planar surfaces which have equal principal curvatures,
 the curvature at a point on a surface varies with the direction one "sets off"
 from the point. For all directions, the curvature will pass through two extrema:
 a minimum (\f$k_min\f$) and a maximum (\f$k_max\f$) which occur at mutually orthogonal
 directions to each other.

 NB. The sign of the Gauss curvature is a geometric ivariant, it should be +ve
 when the surface looks like a sphere, -ve when it looks like a saddle,
 however, the sign of the Mean curvature is not, it depends on the
 convention for normals - This code assumes that normals point outwards (ie
 from the surface of a sphere outwards). If a given mesh produces curvatures
 of opposite senses then the flag InvertMeanCurvature can be set and the
 Curvature reported by the Mean calculation will be inverted.

 .SECTION Thanks
 Philip Batchelor philipp.batchelor@kcl.ac.uk for creating and contributing
 the class and Andrew Maclean a.maclean@acfr.usyd.edu.au for cleanups and 
 fixes. Thanks also to Goodwin Lawlor for contributing patch to calculate
 principal curvatures

See Also:

 


"""
class vtkCutter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCutter - Cut vtkDataSet with user-specified implicit function

Super Class:

 vtkPolyDataAlgorithm

 vtkCutter is a filter to cut through data using any subclass of 
 vtkImplicitFunction. That is, a polygonal surface is created
 corresponding to the implicit function F(x,y,z) = value(s), where
 you can specify one or more values used to cut with.

 In VTK, cutting means reducing a cell of dimension N to a cut surface
 of dimension N-1. For example, a tetrahedron when cut by a plane (i.e.,
 vtkPlane implicit function) will generate triangles. (In comparison,
 clipping takes a N dimensional cell and creates N dimension primitives.)

 vtkCutter is generally used to "slice-through" a dataset, generating
 a surface that can be visualized. It is also possible to use vtkCutter
 to do a form of volume rendering. vtkCutter does this by generating
 multiple cut surfaces (usually planes) which are ordered (and rendered)
 from back-to-front. The surfaces are set translucent to give a 
 volumetric rendering effect.

 Note that data can be cut using either 1) the scalar values associated
 with the dataset or 2) an implicit function associated with this class.
 By default, if an implicit function is set it is used to clip the data
 set, otherwise the dataset scalars are used to perform the clipping.

See Also:

 vtkImplicitFunction vtkClipPolyData


"""
class vtkCylinderSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkCylinderSource - generate a cylinder centered at origin

Super Class:

 vtkPolyDataAlgorithm

 vtkCylinderSource creates a polygonal cylinder centered at Center;
 The axis of the cylinder is aligned along the global y-axis.
 The height and radius of the cylinder can be specified, as well as the
 number of sides. It is also possible to control whether the cylinder is
 open-ended or capped.


"""
class vtkDEMReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkDEMReader - read a digital elevation model (DEM) file

Super Class:

 vtkImageAlgorithm

 vtkDEMReader reads digital elevation files and creates image data.
 Digital elevation files are produced by the
 <A HREF="http://www.usgs.gov">US Geological Survey</A>. 
 A complete description of the DEM file is located at the USGS site.
 The reader reads the entire dem file and create a vtkImageData that
 contains a single scalar component that is the elevation in meters.
 The spacing is also expressed in meters. A number of get methods
 provide access to fields on the header.


"""
class vtkDICOMImageReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkDICOMImageReader - Reads some DICOM images

Super Class:

 vtkImageReader2

 DICOM (stands for Digital Imaging in COmmunications and Medicine)
 is a medical image file format widely used to exchange data, provided
 by various modalities.
 .SECTION Warnings
 This reader might eventually handle ACR-NEMA file (predecessor of the DICOM
 format for medical images).
 This reader does not handle encapsulated format, only plain raw file are
 handled. This reader also does not handle multi-frames DICOM datasets.

See Also:

 vtkBMPReader vtkPNMReader vtkTIFFReader


"""
class vtkDashedStreamLine:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDashedStreamLine - generate constant-time dashed streamline in arbitrary dataset

Super Class:

 vtkStreamLine

 vtkDashedStreamLine is a filter that generates a "dashed" streamline for 
 an arbitrary dataset. The streamline consists of a series of dashes, each 
 of which represents (approximately) a constant time increment. Thus, in the
 resulting visual representation, relatively long dashes represent areas of 
 high velocity, and small dashes represent areas of low velocity.

 vtkDashedStreamLine introduces the instance variable DashFactor. 
 DashFactor interacts with its superclass' instance variable StepLength to
 create the dashes. DashFactor is the percentage of the StepLength line 
 segment that is visible. Thus, if the DashFactor=0.75, the dashes will be 
 "three-quarters on" and "one-quarter off".

See Also:

 vtkStreamer vtkStreamLine vtkStreamPoints


"""
class vtkDataObjectAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataObjectAlgorithm - Superclass for algorithms that produce only data object as output

Super Class:

 vtkAlgorithm


"""
class vtkDataObjectReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkDataObjectReader - read vtk field data file

Super Class:

 vtkDataReader

 vtkDataObjectReader is a source object that reads ASCII or binary field
 data files in vtk format. Fields are general matrix structures used
 represent complex data. (See text for format details).  The output of this
 reader is a single vtkDataObject.  The superclass of this class,
 vtkDataReader, provides many methods for controlling the reading of the
 data file, see vtkDataReader for more information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkFieldData vtkDataObjectWriter


"""
class vtkDataObjectToDataSetFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataObjectToDataSetFilter - map field data to concrete dataset

Super Class:

 vtkDataSetAlgorithm

 vtkDataObjectToDataSetFilter is an class that maps a data object (i.e., a field)
 into a concrete dataset, i.e., gives structure to the field by defining a
 geometry and topology.

 To use this filter you associate components in the input field data with
 portions of the output dataset. (A component is an array of values from
 the field.) For example, you would specify x-y-z points by assigning 
 components from the field for the x, then y, then z values of the points.
 You may also have to specify component ranges (for each z-y-z) to make 
 sure that the number of x, y, and z values is the same. Also, you may 
 want to normalize the components which helps distribute the data 
 uniformly. Once you've setup the filter to combine all the pieces of 
 data into a specified dataset (the geometry, topology, point and cell 
 data attributes), the various output methods (e.g., GetPolyData()) are
 used to retrieve the final product.

 This filter is often used in conjunction with
 vtkFieldDataToAttributeDataFilter.  vtkFieldDataToAttributeDataFilter
 takes field data and transforms it into attribute data (e.g., point and
 cell data attributes such as scalars and vectors).  To do this, use this
 filter which constructs a concrete dataset and passes the input data
 object field data to its output. and then use
 vtkFieldDataToAttributeDataFilter to generate the attribute data associated
 with the dataset.

Caveats:

 Make sure that the data you extract is consistent. That is, if you have N
 points, extract N x, y, and z components. Also, all the information
 necessary to define a dataset must be given. For example, vtkPolyData
 requires points at a minimum; vtkStructuredPoints requires setting the
 dimensions; vtkStructuredGrid requires defining points and dimensions;
 vtkUnstructuredGrid requires setting points; and vtkRectilinearGrid
 requires that you define the x, y, and z-coo ...
 [Truncated]

See Also:

 vtkDataObject vtkFieldData vtkDataSet vtkPolyData vtkStructuredPoints 
 vtkStructuredGrid vtkUnstructuredGrid vtkRectilinearGrid
 vtkDataSetAttributes vtkDataArray


"""
class vtkDataObjectToTable:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataObjectToTable - extract field data as a table

Super Class:

 vtkTableAlgorithm

 This filter cen extrac the field, cell or point data of any data object
 as a table.


"""
class vtkDataObjectWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkDataObjectWriter - write vtk field data

Super Class:

 vtkWriter

 vtkDataObjectWriter is a source object that writes ASCII or binary 
 field data files in vtk format. Field data is a general form of data in
 matrix form.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkFieldData vtkFieldDataReader


"""
class vtkDataSetAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataSetAlgorithm - Superclass for algorithms that produce output of the same type as input

Super Class:

 vtkAlgorithm

 vtkDataSetAlgorithm is a convenience class to make writing algorithms
 easier. It is also designed to help transition old algorithms to the new
 pipeline architecture. Ther are some assumptions and defaults made by this
 class you should be aware of. This class defaults such that your filter
 will have one input port and one output port. If that is not the case
 simply change it with SetNumberOfInputPorts etc. See this classes
 contstructor for the default. This class also provides a FillInputPortInfo
 method that by default says that all inputs will be DataSet. If that isn't
 the case then please override this method in your subclass. This class
 breaks out the downstream requests into seperate functions such as
 RequestDataObject RequestData and RequestInformation. The default
 implementation of RequestDataObject will create an output data of the 
 same type as the input.


"""
class vtkDataSetReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkDataSetReader - class to read any type of vtk dataset

Super Class:

 vtkDataReader

 vtkDataSetReader is a class that provides instance variables and methods
 to read any type of dataset in Visualization Toolkit (vtk) format.  The
 output type of this class will vary depending upon the type of data
 file. Convenience methods are provided to keep the data as a particular
 type. (See text for format description details).
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkDataReader vtkPolyDataReader vtkRectilinearGridReader 
 vtkStructuredPointsReader vtkStructuredGridReader vtkUnstructuredGridReader


"""
class vtkDataSetSurfaceFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataSetSurfaceFilter - Extracts outer (polygonal) surface.

Super Class:

 vtkPolyDataAlgorithm

 vtkDataSetSurfaceFilter is a faster version of vtkGeometry filter, but it 
 does not have an option to select bounds.  It may use more memory than
 vtkGeometryFilter.  It only has one option: whether to use triangle strips 
 when the input type is structured.

See Also:

 vtkGeometryFilter vtkStructuredGridGeometryFilter.


"""
class vtkDataSetToDataObjectFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataSetToDataObjectFilter - map dataset into data object (i.e., a field)

Super Class:

 vtkDataObjectAlgorithm

 vtkDataSetToDataObjectFilter is an class that transforms a dataset into
 data object (i.e., a field). The field will have labeled data arrays
 corresponding to the topology, geometry, field data, and point and cell
 attribute data.

 You can control what portions of the dataset are converted into the
 output data object's field data. The instance variables Geometry,
 Topology, FieldData, PointData, and CellData are flags that control
 whether the dataset's geometry (e.g., points, spacing, origin);
 topology (e.g., cell connectivity, dimensions); the field data
 associated with the dataset's superclass data object; the dataset's
 point data attributes; and the dataset's cell data attributes. (Note:
 the data attributes include scalars, vectors, tensors, normals, texture
 coordinates, and field data.)

 The names used to create the field data are as follows. For vtkPolyData, 
 "Points", "Verts", "Lines", "Polys", and "Strips". For vtkUnstructuredGrid,
 "Cells" and "CellTypes". For vtkStructuredPoints, "Dimensions", "Spacing", 
 and "Origin". For vtkStructuredGrid, "Points" and "Dimensions". For
 vtkRectilinearGrid, "XCoordinates", "YCoordinates", and "ZCoordinates".
 for point attribute data, "PointScalars", "PointVectors", etc. For cell
 attribute data, "CellScalars", "CellVectors", etc. Field data arrays retain
 their original name.

See Also:

 vtkDataObject vtkFieldData vtkDataObjectToDataSetFilter


"""
class vtkDataSetTriangleFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDataSetTriangleFilter - triangulate any type of dataset

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkDataSetTriangleFilter generates n-dimensional simplices from any input
 dataset. That is, 3D cells are converted to tetrahedral meshes, 2D cells
 to triangles, and so on. The triangulation is guaranteed to be compatible.

 This filter uses simple 1D and 2D triangulation techniques for cells
 that are of topological dimension 2 or less. For 3D cells--due to the
 issue of face compatibility across quadrilateral faces (which way to
 orient the diagonal?)--a fancier ordered Delaunay triangulation is used.
 This approach produces templates on the fly for triangulating the
 cells. The templates are then used to do the actual triangulation.


See Also:

 vtkOrderedTriangulator vtkTriangleFilter


"""
class vtkDataSetWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkDataSetWriter - write any type of vtk dataset to file

Super Class:

 vtkDataWriter

 vtkDataSetWriter is an abstract class for mapper objects that write their 
 data to disk (or into a communications port). The input to this object is
 a dataset of any type.


"""
class vtkDecimatePro:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDecimatePro - reduce the number of triangles in a mesh

Super Class:

 vtkPolyDataAlgorithm

 vtkDecimatePro is a filter to reduce the number of triangles in a triangle 
 mesh, forming a good approximation to the original geometry. The input to 
 vtkDecimatePro is a vtkPolyData object, and only triangles are treated. If 
 you desire to decimate polygonal meshes, first triangulate the polygons
 with vtkTriangleFilter object.
 
 The implementation of vtkDecimatePro is similar to the algorithm
 originally described in "Decimation of Triangle Meshes", Proc Siggraph
 `92, with three major differences. First, this algorithm does not
 necessarily preserve the topology of the mesh. Second, it is guaranteed to
 give the a mesh reduction factor specified by the user (as long as certain
 constraints are not set - see Caveats). Third, it is set up generate
 progressive meshes, that is a stream of operations that can be easily
 transmitted and incrementally updated (see Hugues Hoppe's Siggraph '96
 paper on progressive meshes).
 
 The algorithm proceeds as follows. Each vertex in the mesh is classified
 and inserted into a priority queue. The priority is based on the error to
 delete the vertex and retriangulate the hole. Vertices that cannot be
 deleted or triangulated (at this point in the algorithm) are
 skipped. Then, each vertex in the priority queue is processed (i.e.,
 deleted followed by hole triangulation using edge collapse). This
 continues until the priority queue is empty. Next, all remaining vertices
 are processed, and the mesh is split into separate pieces along sharp
 edges or at non-manifold attachment points and reinserted into the
 priority queue. Again, the priority queue is processed until empty. If
 the desired reduction is still not achieved, the remaining vertices are
 split as necessary (in a recursive fashion) so that it is possible to
 eliminate every triangle as necessary.
 
 To use this object, at a minimum you need to specify the ivar
 TargetReduction. The algorithm is guaranteed to generate a reduced mesh
 at this level as long as the following four conditions are met: 1)
 topology modification is allowed (i.e., the ivar PreserveTopology is off);
 2) mesh splitting is enabled (i.e., the ivar Splitting is on); 3) the
 algorithm is allowed to modify the boundary of the mesh (i.e., the ivar
 BoundaryVertexDeletion is on); and 4) the maximum allowable error (i.e.,
 the ivar MaximumError) is set to VTK_DOUBLE_MAX.  Other important
 parameters to adjust include the FeatureAngle and SplitAngle ivars, since
 these can impact the quality of the final mesh. Also, you can set the
 ivar AccumulateError to force incremental error update and distribution
 to surrounding vertices as each vertex is deleted. The accumulated error
 is a conservative global error bounds and decimation error, but requires
 additional memory and time to compute.

Caveats:

 To guarantee a given level of reduction, the ivar PreserveTopology must
 be off; the ivar Splitting is on; the ivar BoundaryVertexDeletion is on;
 and the ivar MaximumError is set to VTK_DOUBLE_MAX.

 If PreserveTopology is off, and SplitEdges is off; the mesh topology may
 be modified by closing holes.

 Once mesh splitting begins, the feature angle is set to the split angle.

See Also:

 vtkDecimate vtkQuadricClustering vtkQuadricDecimation


"""
class vtkDelaunay2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDelaunay2D - create 2D Delaunay triangulation of input points

Super Class:

 vtkPolyDataAlgorithm

 vtkDelaunay2D is a filter that constructs a 2D Delaunay triangulation from
 a list of input points. These points may be represented by any dataset of
 type vtkPointSet and subclasses. The output of the filter is a polygonal
 dataset. Usually the output is a triangle mesh, but if a non-zero alpha
 distance value is specified (called the "alpha" value), then only
 triangles, edges, and vertices lying within the alpha radius are
 output. In other words, non-zero alpha values may result in arbitrary
 combinations of triangles, lines, and vertices. (The notion of alpha value
 is derived from Edelsbrunner's work on "alpha shapes".) Also, it is
 possible to generate "constrained triangulations" using this filter.
 A constrained triangulation is one where edges and loops (i.e., polygons)
 can be defined and the triangulation will preserve them (read on for 
 more information).

 The 2D Delaunay triangulation is defined as the triangulation that 
 satisfies the Delaunay criterion for n-dimensional simplexes (in this case
 n=2 and the simplexes are triangles). This criterion states that a 
 circumsphere of each simplex in a triangulation contains only the n+1 
 defining points of the simplex. (See "The Visualization Toolkit" text 
 for more information.) In two dimensions, this translates into an optimal 
 triangulation. That is, the maximum interior angle of any triangle is less 
 than or equal to that of any possible triangulation.
 
 Delaunay triangulations are used to build topological structures
 from unorganized (or unstructured) points. The input to this filter
 is a list of points specified in 3D, even though the triangulation
 is 2D. Thus the triangulation is constructed in the x-y plane, and
 the z coordinate is ignored (although carried through to the
 output). If you desire to triangulate in a different plane, you
 can use the vtkTransformFilter to transform the points into and
 out of the x-y plane or you can specify a transform to the Delaunay2D
 directly.  In the latter case, the input points are transformed, the
 transformed points are triangulated, and the output will use the
 triangulated topology for the original (non-transformed) points.  This
 avoids transforming the data back as would be required when using the
 vtkTransformFilter method.  Specifying a transform directly also allows
 any transform to be used: rigid, non-rigid, non-invertible, etc.

 If an input transform is used, then alpha values are applied (for the
 most part) in the original data space.  The exception is when
 BoundingTriangulation is on.  In this case, alpha values are applied in
 the original data space unless a cell uses a bounding vertex.  
 
 The Delaunay triangulation can be numerically sensitive in some cases. To
 prevent problems, try to avoid injecting points that will result in
 triangles with bad aspect ratios (1000:1 or greater). In practice this
 means inserting points that are "widely dispersed", and enables smooth
 transition of triangle sizes throughout the mesh. (You may even want to
 add extra points to create a better point distribution.) If numerical
 problems are present, you will see a warning message to this effect at
 the end of the triangulation process.

 To create constrained meshes, you must define an additional
 input. This input is an instance of vtkPolyData which contains
 lines, polylines, and/or polygons that define constrained edges and
 loops. Only the topology of (lines and polygons) from this second
 input are used.  The topology is assumed to reference points in the
 input point set (the one to be triangulated). In other words, the
 lines and polygons use point ids from the first input point
 set. Lines and polylines found in the input will be mesh edges in
 the output. Polygons define a loop with inside and outside
 regions. The inside of the polygon is determined by using the
 right-hand-rule, i.e., looking down the z-axis a polygon should be
 ordered counter-clockwise. Holes in a polygon should be ordered
 clockwise. If you choose to create a constrained triangulation, the
 final mesh may not satisfy the Delaunay criterion. (Noted: the
 lines/polygon edges must not intersect when projected onto the 2D
 plane.  It may not be possible to recover all edges due to not
 enough points in the triangulation, or poorly defined edges
 (coincident or excessively long).  The form of the lines or
 polygons is a list of point ids that correspond to the input point
 ids used to generate the triangulation.)

 If an input transform is used, constraints are defined in the
 "transformed" space.  So when the right hand rule is used for a
 polygon constraint, that operation is applied using the transformed
 points.  Since the input transform can be any transformation (rigid
 or non-rigid), care must be taken in constructing constraints when
 an input transform is used.

Caveats:

 Points arranged on a regular lattice (termed degenerate cases) can be 
 triangulated in more than one way (at least according to the Delaunay 
 criterion). The choice of triangulation (as implemented by 
 this algorithm) depends on the order of the input points. The first three
 points will form a triangle; other degenerate points will not break
 this triangle.

 Points that are coincident (or nearly so) may be discarded by the algorithm.
 This is because the Delaun ...
 [Truncated]

See Also:

 vtkDelaunay3D vtkTransformFilter vtkGaussianSplatter


"""
class vtkDelaunay3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDelaunay3D - create 3D Delaunay triangulation of input points

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkDelaunay3D is a filter that constructs a 3D Delaunay
 triangulation from a list of input points. These points may be
 represented by any dataset of type vtkPointSet and subclasses. The
 output of the filter is an unstructured grid dataset. Usually the
 output is a tetrahedral mesh, but if a non-zero alpha distance
 value is specified (called the "alpha" value), then only tetrahedra,
 triangles, edges, and vertices lying within the alpha radius are 
 output. In other words, non-zero alpha values may result in arbitrary
 combinations of tetrahedra, triangles, lines, and vertices. (The notion 
 of alpha value is derived from Edelsbrunner's work on "alpha shapes".)
 
 The 3D Delaunay triangulation is defined as the triangulation that
 satisfies the Delaunay criterion for n-dimensional simplexes (in
 this case n=3 and the simplexes are tetrahedra). This criterion
 states that a circumsphere of each simplex in a triangulation
 contains only the n+1 defining points of the simplex. (See text for
 more information.) While in two dimensions this translates into an
 "optimal" triangulation, this is not true in 3D, since a measurement 
 for optimality in 3D is not agreed on.

 Delaunay triangulations are used to build topological structures
 from unorganized (or unstructured) points. The input to this filter
 is a list of points specified in 3D. (If you wish to create 2D 
 triangulations see vtkDelaunay2D.) The output is an unstructured grid.
 
 The Delaunay triangulation can be numerically sensitive. To prevent
 problems, try to avoid injecting points that will result in
 triangles with bad aspect ratios (1000:1 or greater). In practice
 this means inserting points that are "widely dispersed", and
 enables smooth transition of triangle sizes throughout the
 mesh. (You may even want to add extra points to create a better
 point distribution.) If numerical problems are present, you will
 see a warning message to this effect at the end of the
 triangulation process.

Caveats:

 Points arranged on a regular lattice (termed degenerate cases) can be 
 triangulated in more than one way (at least according to the Delaunay 
 criterion). The choice of triangulation (as implemented by 
 this algorithm) depends on the order of the input points. The first four
 points will form a tetrahedron; other degenerate points (relative to this
 initial tetrahedron) will not break it.

 Points that are coincident (or nearly so) may be discarded by the
 algorit ...
 [Truncated]

See Also:

 vtkDelaunay2D vtkGaussianSplatter vtkUnstructuredGrid


"""
class vtkDelimitedTextReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkDelimitedTextReader - reader for pulling in flat text files

Super Class:

 vtkTableAlgorithm

 vtkDelimitedTextReader is an interface for pulling in data from a
 flat, delimited text file (delimiter can be any character).

 This class emits ProgressEvent for every 100 lines it reads.

 .SECTION Thanks
 Thanks to Andy Wilson and Brian Wylie from Sandia National Laboratories 
 for implementing this class.
 

Caveats:


 This reader assumes that the first line in the file (whether that's
 headers or the first document) contains at least as many fields as
 any other line in the file.


"""
class vtkDepthSortPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDepthSortPolyData - sort poly data along camera view direction

Super Class:

 vtkPolyDataAlgorithm

 vtkDepthSortPolyData rearranges the order of cells so that certain
 rendering operations (e.g., transparency or Painter's algorithms)
 generate correct results. To use this filter you must specify the
 direction vector along which to sort the cells. You can do this by 
 specifying a camera and/or prop to define a view direction; or 
 explicitly set a view direction.

Caveats:

 The sort operation will not work well for long, thin primitives, or cells
 that intersect, overlap, or interpenetrate each other.


"""
class vtkDijkstraGraphGeodesicPath:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDijkstraGraphGeodesicPath - Dijkstra algorithm to compute the graph geodesic.

Super Class:

 vtkGraphGeodesicPath

 Takes as input a polygonal mesh and performs a single source shortest 
 path calculation. Dijkstra's algorithm is used. The implementation is 
 similar to the one described in Introduction to Algorithms (Second Edition)
 by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and 
 Cliff Stein, published by MIT Press and McGraw-Hill. Some minor 
 enhancement are added though. All vertices are not pushed on the heap
 at start, instead a front set is maintained. The heap is implemented as 
 a binary heap. The output of the filter is a set of lines describing 
 the shortest path from StartVertex to EndVertex.


Caveats:

 The input polydata must have only triangle cells. 

 .SECTION Thanks
 The class was contributed by Rasmus Paulsen. 
 www.imm.dtu.dk/~rrp/VTK . Also thanks to Alexandre Gouaillard and Shoaib 
 Ghias for bug fixes and enhancements.


"""
class vtkDiscreteMarchingCubes:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDiscreteMarchingCubes - generate object boundaries from

Super Class:

 vtkMarchingCubes

 takes as input a volume (e.g., 3D structured point set) of
 segmentation labels and generates on output one or more
 models representing the boundaries between the specified label and
 the adjacent structures.  One or more label values must be specified to
 generate the models.  The boundary positions are always defined to
 be half-way between adjacent voxels. This filter works best with
 integral scalar values.
 If ComputeScalars is on (the default), each output cell will have
 cell data that corresponds to the scalar value (segmentation label)
 of the corresponding cube. Note that this differs from vtkMarchingCubes,
 which stores the scalar value as point data. The rationale for this
 difference is that cell vertices may be shared between multiple
 cells. This also means that the resultant polydata may be
 non-manifold (cell faces may be coincident). To further process the
 polydata, users should either: 1) extract cells that have a common
 scalar value using vtkThreshold, or 2) process the data with
 filters that can handle non-manifold polydata
 (e.g. vtkWindowedSincPolyDataFilter).
 Also note, Normals and Gradients are not computed.

Caveats:

 This filter is specialized to volumes. If you are interested in 
 contouring other types of data, use the general vtkContourFilter. If you
 want to contour an image (i.e., a volume slice), use vtkMarchingSquares.

See Also:

 vtkContourFilter vtkSliceCubes vtkMarchingSquares vtkDividingCubes


"""
class vtkDiskSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkDiskSource - create a disk with hole in center

Super Class:

 vtkPolyDataAlgorithm

 vtkDiskSource creates a polygonal disk with a hole in the center. The 
 disk has zero height. The user can specify the inner and outer radius
 of the disk, and the radial and circumferential resolution of the 
 polygonal representation. 

See Also:

 vtkLinearExtrusionFilter


"""
class vtkEarthSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkEarthSource - create the continents of the Earth as a sphere

Super Class:

 vtkPolyDataAlgorithm

 vtkEarthSource creates a spherical rendering of the geographical shapes
 of the major continents of the earth. The OnRatio determines
 how much of the data is actually used. The radius defines the radius
 of the sphere at which the continents are placed. Obtains data from
 an imbedded array of coordinates.


"""
class vtkEdgePoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkEdgePoints - generate points on isosurface

Super Class:

 vtkPolyDataAlgorithm

 vtkEdgePoints is a filter that takes as input any dataset and 
 generates for output a set of points that lie on an isosurface. The 
 points are created by interpolation along cells edges whose end-points are 
 below and above the contour value.

Caveats:

 vtkEdgePoints can be considered a "poor man's" dividing cubes algorithm
 (see vtkDividingCubes). Points are generated only on the edges of cells, 
 not in the interior, and at lower density than dividing cubes. However, it 
 is more general than dividing cubes since it treats any type of dataset.


"""
class vtkElevationFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkElevationFilter - generate scalars along a specified direction

Super Class:

 vtkDataSetAlgorithm

 vtkElevationFilter is a filter to generate scalar values from a
 dataset.  The scalar values lie within a user specified range, and
 are generated by computing a projection of each dataset point onto
 a line. The line can be oriented arbitrarily. A typical example is
 to generate scalars based on elevation or height above a plane.


"""
class vtkEllipticalButtonSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkEllipticalButtonSource - create a ellipsoidal-shaped button

Super Class:

 vtkButtonSource

 vtkEllipticalButtonSource creates a ellipsoidal shaped button with
 texture coordinates suitable for application of a texture map. This
 provides a way to make nice looking 3D buttons. The buttons are
 represented as vtkPolyData that includes texture coordinates and
 normals. The button lies in the x-y plane.

 To use this class you must define the major and minor axes lengths of an
 ellipsoid (expressed as width (x), height (y) and depth (z)). The button
 has a rectangular mesh region in the center with texture coordinates that
 range smoothly from (0,1). (This flat region is called the texture
 region.) The outer, curved portion of the button (called the shoulder) has
 texture coordinates set to a user specified value (by default (0,0).
 (This results in coloring the button curve the same color as the (s,t)
 location of the texture map.) The resolution in the radial direction, the
 texture region, and the shoulder region must also be set. The button can
 be moved by specifying an origin.


See Also:

 vtkButtonSource vtkRectangularButtonSource


"""
class vtkEnSight6BinaryReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkEnSight6BinaryReader - class to read binary EnSight6 files

Super Class:

 vtkEnSightReader

 vtkEnSight6BinaryReader is a class to read binary EnSight6 files into vtk.
 Because the different parts of the EnSight data can be of various data
 types, this reader produces multiple outputs, one per part in the input
 file.
 All variable information is being stored in field data.  The descriptions
 listed in the case file are used as the array names in the field data.
 For complex vector variables, the description is appended with _r (for the
 array of real values) and _i (for the array if imaginary values).  Complex
 scalar variables are stored as a single array with 2 components, real and
 imaginary, listed in that order.

Caveats:

 You must manually call Update on this reader and then connect the rest
 of the pipeline because (due to the nature of the file format) it is
 not possible to know ahead of time how many outputs you will have or
 what types they will be.
 This reader can only handle static EnSight datasets (both static geometry
 and variables).


"""
class vtkEnSight6Reader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkEnSight6Reader - class to read EnSight6 files

Super Class:

 vtkEnSightReader

 vtkEnSight6Reader is a class to read EnSight6 files into vtk.
 Because the different parts of the EnSight data can be of various data
 types, this reader produces multiple outputs, one per part in the input
 file.
 All variable information is being stored in field data.  The descriptions
 listed in the case file are used as the array names in the field data.
 For complex vector variables, the description is appended with _r (for the
 array of real values) and _i (for the array if imaginary values).  Complex
 scalar variables are stored as a single array with 2 components, real and
 imaginary, listed in that order.

Caveats:

 You must manually call Update on this reader and then connect the rest
 of the pipeline because (due to the nature of the file format) it is
 not possible to know ahead of time how many outputs you will have or
 what types they will be.
 This reader can only handle static EnSight datasets (both static geometry
 and variables).


"""
class vtkEnSightGoldBinaryReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkEnSightGoldBinaryReader - class to read binary EnSight Gold files

Super Class:

 vtkEnSightReader

 vtkEnSightGoldBinaryReader is a class to read EnSight Gold files into vtk.
 Because the different parts of the EnSight data can be of various data
 types, this reader produces multiple outputs, one per part in the input
 file.
 All variable information is being stored in field data.  The descriptions
 listed in the case file are used as the array names in the field data.
 For complex vector variables, the description is appended with _r (for the
 array of real values) and _i (for the array if imaginary values).  Complex
 scalar variables are stored as a single array with 2 components, real and
 imaginary, listed in that order.

Caveats:

 You must manually call Update on this reader and then connect the rest
 of the pipeline because (due to the nature of the file format) it is
 not possible to know ahead of time how many outputs you will have or
 what types they will be.
 This reader can only handle static EnSight datasets (both static geometry
 and variables).


"""
class vtkEnSightGoldReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkEnSightGoldReader - class to read EnSight Gold files

Super Class:

 vtkEnSightReader

 vtkEnSightGoldReader is a class to read EnSight Gold files into vtk.
 Because the different parts of the EnSight data can be of various data
 types, this reader produces multiple outputs, one per part in the input
 file.
 All variable information is being stored in field data.  The descriptions
 listed in the case file are used as the array names in the field data.
 For complex vector variables, the description is appended with _r (for the
 array of real values) and _i (for the array if imaginary values).  Complex
 scalar variables are stored as a single array with 2 components, real and
 imaginary, listed in that order.

Caveats:

 You must manually call Update on this reader and then connect the rest
 of the pipeline because (due to the nature of the file format) it is
 not possible to know ahead of time how many outputs you will have or
 what types they will be.
 This reader can only handle static EnSight datasets (both static geometry
 and variables).


"""
class vtkEnSightMasterServerReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkEnSightMasterServerReader - reader for compund EnSight files

Super Class:

 vtkGenericEnSightReader

None provided.


"""
class vtkExodusIIReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkExodusIIReader - Read exodus 2 files .ex2

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkExodusIIReader is a unstructured grid source object that reads ExodusII
 files.  Most of the meta data associated with the file is loaded when 
 UpdateInformation is called.  This includes information like Title, number
 of blocks, number and names of arrays. This data can be retrieved from 
 methods in this reader. Separate arrays that are meant to be a single 
 vector, are combined internally for convenience.  To be combined, the array 
 names have to be identical except for a trailing X,Y and Z (or x,y,z).  By 
 default cell and point arrays are not loaded.  However, the user can flag 
 arrays to load with the methods "SetPointArrayStatus" and
 "SetCellArrayStatus".  The reader DOES NOT respond to piece requests
 


"""
class vtkExodusReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkExodusReader - Read exodus 2 files .ex2

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkExodusReader is a unstructured grid source object that reads ExodusII
 files.  Most of the meta data associated with the file is loaded when 
 UpdateInformation is called.  This includes information like Title, number
 of blocks, number and names of arrays. This data can be retrieved from 
 methods in this reader. Separate arrays that are meant to be a single 
 vector, are combined internally for convenience.  To be combined, the array 
 names have to be identical except for a trailing X,Y and Z (or x,y,z).  By 
 default cell and point arrays are not loaded.  However, the user can flag 
 arrays to load with the methods "SetPointArrayStatus" and
 "SetCellArrayStatus".  The reader DOES NOT respond to piece requests
 


"""
class vtkExtractArraysOverTime:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractArraysOverTime - extract point or cell data over time

Super Class:

 vtkRectilinearGridAlgorithm

 vtkExtractArraysOverTime extracts point or cell data of one point or
 cell over time. The output is a 1D rectilinear grid where the 
 XCoordinates correspond to time (the same array is also copied to
 a point array named Time or TimeData (if Time exists in the input).
 When extracting point data, the input point coordinates are copied
 to a point array named Point Coordinates or Points (if Point Coordinates
 exists in the input).
 This algorithm does not produce a TIME_STEPS or TIME_RANGE information
 because it works across time. 
 .Section Caveat
 vtkExtractArraysOverTime puts a vtkOnePieceExtentTranslator in the
 output during RequestInformation(). As a result, the same whole 
 extented is produced independent of the piece request.
 This algorithm works only with source that produce TIME_STEPS().
 Continuous time range is not yet supported.


"""
class vtkExtractCells:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractCells - subset a vtkDataSet to create a vtkUnstructuredGrid

Super Class:

 vtkUnstructuredGridAlgorithm

    Given a vtkDataSet and a list of cell Ids, create a vtkUnstructuredGrid
    composed of these cells.  If the cell list is empty when vtkExtractCells 
    executes, it will set up the ugrid, point and cell arrays, with no points, 
    cells or data.


"""
class vtkExtractDataOverTime:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractDataOverTime - extract point data from a time sequence for

Super Class:

 vtkPointSetAlgorithm

 This filter extracts the point data from a time sequence and specified index
 and creates an output of the same type as the input but with Points 
 containing "number of time steps" points; the point and PointData 
 corresponding to the PointIndex are extracted at each time step and added to
 the output.  A PointData array is added called "Time" (or "TimeData" if
 there is already an array called "Time"), which is the time at each index.


"""
class vtkExtractEdges:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractEdges - extract cell edges from any type of data

Super Class:

 vtkPolyDataAlgorithm

 vtkExtractEdges is a filter to extract edges from a dataset. Edges
 are extracted as lines or polylines.

See Also:

 vtkFeatureEdges


"""
class vtkExtractGeometry:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractGeometry - extract cells that lie either entirely inside or outside of a specified implicit function

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkExtractGeometry extracts from its input dataset all cells that are either
 completely inside or outside of a specified implicit function. Any type of
 dataset can be input to this filter. On output the filter generates an
 unstructured grid.

 To use this filter you must specify an implicit function. You must also
 specify whethter to extract cells lying inside or outside of the implicit 
 function. (The inside of an implicit function is the negative values 
 region.) An option exists to extract cells that are neither inside or
 outside (i.e., boundary).

 A more efficient version of this filter is available for vtkPolyData input.
 See vtkExtractPolyDataGeometry.

See Also:

 vtkExtractPolyDataGeometry vtkGeometryFilter vtkExtractVOI 


"""
class vtkExtractGrid:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractGrid - select piece (e.g., volume of interest) and/or subsample structured grid dataset

Super Class:

 vtkStructuredGridAlgorithm

 vtkExtractGrid is a filter that selects a portion of an input structured
 grid dataset, or subsamples an input dataset. (The selected portion of
 interested is referred to as the Volume Of Interest, or VOI.) The output of
 this filter is a structured grid dataset. The filter treats input data of
 any topological dimension (i.e., point, line, image, or volume) and can
 generate output data of any topological dimension.

 To use this filter set the VOI ivar which are i-j-k min/max indices that
 specify a rectangular region in the data. (Note that these are 0-offset.)
 You can also specify a sampling rate to subsample the data.

 Typical applications of this filter are to extract a plane from a grid for 
 contouring, subsampling large grids to reduce data size, or extracting
 regions of a grid with interesting data.

See Also:

 vtkGeometryFilter vtkExtractGeometry vtkExtractVOI 
 vtkStructuredGridGeometryFilter


"""
class vtkExtractPolyDataGeometry:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractPolyDataGeometry - extract vtkPolyData cells that lies either entirely inside or outside of a specified implicit function

Super Class:

 vtkPolyDataAlgorithm

 vtkExtractPolyDataGeometry extracts from its input vtkPolyData all cells
 that are either completely inside or outside of a specified implicit
 function. This filter is specialized to vtkPolyData. On output the 
 filter generates vtkPolyData.

 To use this filter you must specify an implicit function. You must also
 specify whether to extract cells lying inside or outside of the implicit 
 function. (The inside of an implicit function is the negative values 
 region.) An option exists to extract cells that are neither inside nor
 outside (i.e., boundary).

 A more general version of this filter is available for arbitrary
 vtkDataSet input (see vtkExtractGeometry).

See Also:

 vtkExtractGeometry vtkClipPolyData


"""
class vtkExtractRectilinearGrid:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractRectilinearGrid - Extract a sub grid (VOI) from the structured rectilinear dataset.

Super Class:

 vtkRectilinearGridAlgorithm

 vtkExtractRectilinearGrid rounds out the set of filters that extract
 a subgrid out of a larger structured data set.  RIght now, this filter
 only supports extracting a VOI.  In the future, it might support
 strides like the vtkExtract grid filter.

See Also:

 vtkExtractGrid vtkImageClip vtkGeometryFilter vtkExtractGeometry vtkExtractVOI 
 vtkStructuredGridGeometryFilter


"""
class vtkExtractSelectedFrustum:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelectedFrustum - Returns the portion of the input dataset that 

Super Class:

 vtkDataSetAlgorithm

 This class intersects the input DataSet with a frustum and determines which
 cells and points lie within the frustum. The frustum is defined with a 
 vtkPlanes containing six cutting planes. The output is a DataSet that is 
 either a shallow copy of the input dataset with two new "vtkInsidedness" 
 attribute arrays, or a completely new UnstructuredGrid that contains only 
 the cells and points of the input that are inside the frustum. The 
 PassThrough flag controls which occurs. When PassThrough is off 
 this filter adds a scalar array called vtkOriginalCellIds that says what 
 input cell produced each output cell. This is an example of a Pedigree ID 
 which helps to trace back results.


See Also:

 vtkExtractGeometry, vtkAreaPicker, vtkExtractSelection, vtkSelection


"""
class vtkExtractSelectedGraph:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelectedGraph - return a subgraph of a vtkGraph

Super Class:

 vtkGraphAlgorithm

 The first input is a vtkGraph to take a subgraph from.
 The second input is a vtkSelection containing the selected indices.
 The vtkSelection may have FIELD_TYPE set to POINTS (a vertex selection)
 or CELLS (an edge selection).  A vertex selection preserves all edges
 that connect selected vertices.  An edge selection preserves all vertices
 that are adjacent to at least one selected edge.  Alternately, you may
 indicate that an edge selection should maintain the full set of vertices,
 by turning RemoveIsolatedVertices off.


"""
class vtkExtractSelectedIds:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelectedIds - extract a list of cells from a dataset

Super Class:

 vtkDataSetAlgorithm

 vtkExtractSelectedIds extracts a set of cells and points from within a
 vtkDataSet. The set of ids to extract are listed within a vtkSelection.
 This filter adds a scalar array called vtkOriginalCellIds that says what 
 input cell produced each output cell. This is an example of a Pedigree ID 
 which helps to trace back results. Depending on whether the selection has
 GLOBALIDS, VALUES or INDICES, the selection will use the contents of the
 array named in the GLOBALIDS DataSetAttribute, and arbitrary array, or the
 position (tuple id or number) within the cell or point array.

See Also:

 vtkSelection vtkExtractSelection


"""
class vtkExtractSelectedLocations:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelectedLocations - extract cells within a dataset that 

Super Class:

 vtkDataSetAlgorithm

 vtkExtractSelectedLocations extracts all cells whose volume contain at least 
 one point listed in the LOCATIONS content of the vtkSelection. This filter 
 adds a scalar array called vtkOriginalCellIds that says what input cell 
 produced each output cell. This is an example of a Pedigree ID which helps
 to trace back results.

See Also:

 vtkSelection vtkExtractSelection


"""
class vtkExtractSelectedPolyDataIds:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelectedPolyDataIds - extract a list of cells from a polydata

Super Class:

 vtkPolyDataAlgorithm

 vtkExtractSelectedPolyDataIds extracts all cells in vtkSelection from a
 vtkPolyData.

See Also:

 vtkSelection


"""
class vtkExtractSelectedThresholds:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelectedThresholds - extract a cells or points from a 

Super Class:

 vtkDataSetAlgorithm

 vtkExtractSelectedThresholds extracts all cells and points with attribute 
 values that lie within a vtkSelection's THRESHOLD contents. The selecion
 can specify to threshold a particular array within either the point or cell
 attribute data of the input. This is similar to vtkThreshold
 but allows mutliple thresholds ranges.
 This filter adds a scalar array called vtkOriginalCellIds that says what 
 input cell produced each output cell. This is an example of a Pedigree ID 
 which helps to trace back results.

See Also:

 vtkSelection vtkExtractSelection vtkThreshold 


"""
class vtkExtractSelection:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractSelection - extract a subset from a vtkDataSet.

Super Class:

 vtkDataSetAlgorithm

 vtkExtractSelection extracts some subset of cells and points from
 its input dataset. The subset is described by the contents of the
 vtkSelection on its first input port. The dataset is given on its 
 second input port. Depending on the content of the vtkSelection,
 this will use either a vtkExtractSelectedIds, vtkExtractSelectedFrustum
 vtkExtractSelectedLocations or a vtkExtractSelectedThreshold to perform
 the extraction.

See Also:

 vtkSelection vtkExtractSelectedIds vtkExtractSelectedFrustum
 vtkExtractSelectedLocations vtkExtractSelectedThresholds


"""
class vtkExtractTemporalFieldData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractTemporalFieldData - Extract temporal arrays from input field data

Super Class:

 vtkRectilinearGridAlgorithm

 vtkExtractTemporalFieldData extracts arrays from the input vtkFieldData. 
 These arrays are assumed to contain temporal data, where the nth tuple 
 contains the value for the nth timestep. 
 The output is a 1D rectilinear grid where the 
 XCoordinates correspond to time (the same array is also copied to
 a point array named Time or TimeData (if Time exists in the input).
 This algorithm does not produce a TIME_STEPS or TIME_RANGE information
 because it works across time. 
 .Section Caveat
 vtkExtractTemporalFieldData puts a vtkOnePieceExtentTranslator in the
 output during RequestInformation(). As a result, the same whole 
 extented is produced independent of the piece request.
 This algorithm works only with source that produce TIME_STEPS().
 Continuous time range is not yet supported.


"""
class vtkExtractTensorComponents:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractTensorComponents - extract parts of tensor and create a scalar, vector, normal, or texture coordinates.

Super Class:

 vtkDataSetAlgorithm

 vtkExtractTensorComponents is a filter that extracts components of
 a tensor to create a scalar, vector, normal, or texture coords. For
 example, if the tensor contains components of stress, then you
 could extract the normal stress in the x-direction as a scalar
 (i.e., tensor component (0,0).
 
 To use this filter, you must set some boolean flags to control
 which data is extracted from the tensors, and whether you want to
 pass the tensor data through to the output. Also, you must specify
 the tensor component(s) for each type of data you want to
 extract. The tensor component(s) is(are) specified using matrix notation
 into a 3x3 matrix. That is, use the (row,column) address to specify
 a particular tensor component; and if the data you are extracting
 requires more than one component, use a list of addresses. (Note
 that the addresses are 0-offset -> (0,0) specifies upper left
 corner of the tensor.)

 There are two optional methods to extract scalar data. You can
 extract the determinant of the tensor, or you can extract the
 effective stress of the tensor. These require that the ivar
 ExtractScalars is on, and the appropriate scalar extraction mode is
 set.


"""
class vtkExtractUnstructuredGrid:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractUnstructuredGrid - extract subset of unstructured grid geometry

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkExtractUnstructuredGrid is a general-purpose filter to
 extract geometry (and associated data) from an unstructured grid
 dataset. The extraction process is controlled by specifying a range
 of point ids, cell ids, or a bounding box (referred to as "Extent").
 Those cells lying within these regions are sent to the output.
 The user has the choice of merging coincident points (Merging is on)
 or using the original point set (Merging is off).

Caveats:

 If merging is off, the input points are copied through to the
 output. This means unused points may be present in the output data.
 If merging is on, then coincident points with different point attribute
 values are merged.

See Also:

 vtkImageDataGeometryFilter vtkStructuredGridGeometryFilter
 vtkRectilinearGridGeometryFilter
 vtkExtractGeometry vtkExtractVOI


"""
class vtkExtractVOI:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractVOI - select piece (e.g., volume of interest) and/or subsample structured points dataset

Super Class:

 vtkImageAlgorithm

 vtkExtractVOI is a filter that selects a portion of an input structured
 points dataset, or subsamples an input dataset. (The selected portion of
 interested is referred to as the Volume Of Interest, or VOI.) The output of
 this filter is a structured points dataset. The filter treats input data
 of any topological dimension (i.e., point, line, image, or volume) and can
 generate output data of any topological dimension.

 To use this filter set the VOI ivar which are i-j-k min/max indices that
 specify a rectangular region in the data. (Note that these are 0-offset.)
 You can also specify a sampling rate to subsample the data.

 Typical applications of this filter are to extract a slice from a volume
 for image processing, subsampling large volumes to reduce data size, or
 extracting regions of a volume with interesting data.

See Also:

 vtkGeometryFilter vtkExtractGeometry vtkExtractGrid


"""
class vtkExtractVectorComponents:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkExtractVectorComponents - extract components of vector as separate scalars

Super Class:

 vtkDataSetAlgorithm

 vtkExtractVectorComponents is a filter that extracts vector components as
 separate scalars. This is accomplished by creating three different outputs.
 Each output is the same as the input, except that the scalar values will be
 one of the three components of the vector. These can be found in the
 VxComponent, VyComponent, and VzComponent.
 Alternatively, if the ExtractToFieldData flag is set, the filter will
 put all the components in the field data. The first component will be
 the scalar and the others will be non-attribute arrays.

Caveats:

 This filter is unusual in that it creates multiple outputs. 
 If you use the GetOutput() method, you will be retrieving the x vector 
 component.


"""
class vtkFLUENTReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkFLUENTReader - reads a dataset in Fluent file format

Super Class:

 vtkMultiBlockDataSetAlgorithm

 vtkFLUENTReader creates an unstructured grid dataset. It reads .cas and
 .dat files stored in FLUENT native format.

 .SECTION Thanks
 Thanks to Brian W. Dotson & Terry E. Jordan (Department of Energy, National
 Energy Technology Laboratory) & Douglas McCorkle (Iowa State University)
 who developed this class.
 Please address all comments to Brian Dotson (brian.dotson@netl.doe.gov) &
 Terry Jordan (terry.jordan@sa.netl.doe.gov)
 & Doug McCorkle (mccdo@iastate.edu)


See Also:

 vtkGAMBITReader


"""
class vtkFacetReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkFacetReader - reads a dataset in Facet format

Super Class:

 vtkPolyDataAlgorithm

 vtkFacetReader creates a poly data dataset. It reads ASCII files
 stored in Facet format

 The facet format looks like this:
 FACET FILE ...
 nparts
 Part 1 name
 0
 npoints 0 0
 p1x p1y p1z
 p2x p2y p2z
 ...
 1
 Part 1 name
 ncells npointspercell
 p1c1 p2c1 p3c1 ... pnc1 materialnum partnum
 p1c2 p2c2 p3c2 ... pnc2 materialnum partnum
 ...


"""
class vtkFacetWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkFacetWriter - reads a dataset in Facet format

Super Class:

 vtkPolyDataAlgorithm

 vtkFacetWriter creates an unstructured grid dataset. It reads ASCII files
 stored in Facet format

 The facet format looks like this:
 FACET FILE ...
 nparts
 Part 1 name
 0
 npoints 0 0
 p1x p1y p1z
 p2x p2y p2z
 ...
 1
 Part 1 name
 ncells npointspercell
 p1c1 p2c1 p3c1 ... pnc1 materialnum partnum
 p1c2 p2c2 p3c2 ... pnc2 materialnum partnum
 ...


"""
class vtkFastSplatter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkFastSplatter - A splatter optimized for splatting single kernels.

Super Class:

 vtkImageAlgorithm


 vtkFastSplatter takes any vtkPointSet as input (of which vtkPolyData and
 vtkUnstructuredGrid inherit).  Each point in the data set is considered to be
 an impulse.  These impulses are convolved with a given splat image.  In other
 words, the splat image is added to the final image at every place where there
 is an input point.

 Note that point and cell data are thrown away.  If you want a sampling
 of unstructured points consider vtkGaussianSplatter or vtkShepardMethod.

 Use input port 0 for the impulse data (vtkPointSet), and input port 1 for
 the splat image (vtkImageData)

 .SECTION Bugs

 Any point outside of the extents of the image is thrown away, even if it is
 close enough such that it's convolution with the splat image would overlap
 the extents.



"""
class vtkFeatureEdges:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkFeatureEdges - extract boundary, non-manifold, and/or sharp edges from polygonal data

Super Class:

 vtkPolyDataAlgorithm

 vtkFeatureEdges is a filter to extract special types of edges from
 input polygonal data. These edges are either 1) boundary (used by 
 one polygon) or a line cell; 2) non-manifold (used by three or more 
 polygons); 3) feature edges (edges used by two triangles and whose
 dihedral angle > FeatureAngle); or 4) manifold edges (edges used by
 exactly two polygons). These edges may be extracted in any
 combination. Edges may also be "colored" (i.e., scalar values assigned)
 based on edge type. The cell coloring is assigned to the cell data of
 the extracted edges.

Caveats:

 To see the coloring of the liens you may have to set the ScalarMode
 instance variable of the mapper to SetScalarModeToUseCellData(). (This
 is only a problem if there are point data scalars.)

See Also:

 vtkExtractEdges


"""
class vtkFieldDataToAttributeDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkFieldDataToAttributeDataFilter - map field data to dataset attribute data

Super Class:

 vtkDataSetAlgorithm

 vtkFieldDataToAttributeDataFilter is a class that maps field data into
 dataset attributes. The input to this filter is any type of dataset and
 the output is the same dataset (geometry/topology) with new attribute data
 (attribute data is passed through if not replaced during filter
 execution).

 To use this filter you must specify which field data from the input
 dataset to use. There are three possibilities: the cell field data, the
 point field data, or the field data associated with the data object
 superclass. Then you specify which attribute data to create: either cell
 attribute data or point attribute data.  Finally, you must define how to
 construct the various attribute data types (e.g., scalars, vectors,
 normals, etc.) from the arrays and the components of the arrays from the
 field data. This is done by associating components in the input field with
 components making up the attribute data. For example, you would specify a
 scalar with three components (RGB) by assigning components from the field
 for the R, then G, then B values of the scalars.  You may also have to
 specify component ranges (for each R-G-B) to make sure that the number of
 R, G, and B values is the same. Also, you may want to normalize the
 components which helps distribute the data uniformly.

 This filter is often used in conjunction with
 vtkDataObjectToDataSetFilter.  vtkDataObjectToDataSetFilter filter
 generates dataset topology and geometry and passes its input field data
 along to its output. Then this filter is used to generate the attribute
 data to go along with the dataset.

Caveats:

 Make sure that the data you extract is consistent. That is, if you have N
 points, extract N point attributes (scalars, vectors, etc.). 

See Also:

 vtkFieldData vtkDataSet vtkDataObjectToDataSetFilter
 vtkDataSetAttributes vtkDataArray


"""
class vtkFixedWidthTextReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkFixedWidthTextReader - reader for pulling in text files with fixed-width fields

Super Class:

 vtkTableAlgorithm


 vtkFixedWidthTextReader reads in a table from a text file where
 each column occupies a certain number of characters.
 
 This class emits ProgressEvent for every 100 lines it reads.
 

Caveats:


 This first version of the reader will assume that all fields have
 the same width.  It also assumes that the first line in the file
 has at least as many fields (i.e. at least as many characters) as
 any other line in the file.

 .SECTION Thanks
 Thanks to Andy Wilson from Sandia National Laboratories for
 implementing this class.


"""
class vtkGAMBITReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkGAMBITReader - reads a dataset in Fluent GAMBIT neutral file format

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkGAMBITReader creates an unstructured grid dataset. It reads ASCII files
 stored in GAMBIT neutral format, with optional data stored at the nodes or
 at the cells of the model. A cell-based fielddata stores the material id.

See Also:

 vtkAVSucdReader


"""
class vtkGESignaReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkGESignaReader - read GE Signa ximg files

Super Class:

 vtkMedicalImageReader2

 vtkGESignaReader is a source object that reads some GE Signa ximg files It
 does support reading in pixel spacing, slice spacing and it computes an
 origin for the image in millimeters. It always produces greyscale unsigned
 short data and it supports reading in rectangular, packed, compressed, and
 packed&compressed. It does not read in slice orientation, or position
 right now. To use it you just need to specify a filename or a file prefix
 and pattern.

See Also:

 vtkImageReader2


"""
class vtkGaussianCubeReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkGaussianCubeReader - read ASCII Gaussian Cube Data files

Super Class:

 vtkMoleculeReaderBase

 vtkGaussianCubeReader is a source object that reads ASCII files following
 the description in http://www.gaussian.com/00000430.htm
 The FileName must be specified.

 .SECTION Thanks
 Dr. Jean M. Favre who developed and contributed this class.


"""
class vtkGaussianSplatter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGaussianSplatter - splat points into a volume with an elliptical, Gaussian distribution

Super Class:

 vtkImageAlgorithm

 vtkGaussianSplatter is a filter that injects input points into a
 structured points (volume) dataset. As each point is injected, it "splats"
 or distributes values to nearby voxels. Data is distributed using an
 elliptical, Gaussian distribution function. The distribution function is
 modified using scalar values (expands distribution) or normals
 (creates ellipsoidal distribution rather than spherical).

 In general, the Gaussian distribution function f(x) around a given
 splat point p is given by

     f(x) = ScaleFactor * exp( ExponentFactor*((r/Radius)**2) )

 where x is the current voxel sample point; r is the distance |x-p|
 ExponentFactor <= 0.0, and ScaleFactor can be multiplied by the scalar 
 value of the point p that is currently being splatted.

 If points normals are present (and NormalWarping is on), then the splat 
 function becomes elliptical (as compared to the spherical one described
 by the previous equation). The Gaussian distribution function then
 becomes:
 
     f(x) = ScaleFactor * 
               exp( ExponentFactor*( ((rxy/E)**2 + z**2)/R**2) )

 where E is a user-defined eccentricity factor that controls the elliptical
 shape of the splat; z is the distance of the current voxel sample point
 along normal N; and rxy is the distance of x in the direction
 prependicular to N.

 This class is typically used to convert point-valued distributions into
 a volume representation. The volume is then usually iso-surfaced or
 volume rendered to generate a visualization. It can be used to create
 surfaces from point distributions, or to create structure (i.e.,
 topology) when none exists.

Caveats:

 The input to this filter is any dataset type. This filter can be used 
 to resample any form of data, i.e., the input data need not be 
 unstructured. 

 Some voxels may never receive a contribution during the splatting process.
 The final value of these points can be specified with the "NullValue" 
 instance variable.

See Also:

 vtkShepardMethod


"""
class vtkGenericClip:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericClip - clip any dataset with an implicit function or scalar data

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkGenericClip is a filter that any type of dataset using either
 any subclass of vtkImplicitFunction, or the input scalar
 data. Clipping means that it actually "cuts" through the cells of
 the dataset, returning everything inside of the specified implicit
 function (or greater than the scalar value) including "pieces" of
 a cell. (Compare this with vtkExtractGeometry, which pulls out
 entire, uncut cells.) The output of this filter is an unstructured
 grid.

 To use this filter, you must decide if you will be clipping with an
 implicit function, or whether you will be using the input scalar
 data.  If you want to clip with an implicit function, you must:
 1) define an implicit function
 2) set it with the SetClipFunction method
 3) apply the GenerateClipScalarsOn method
 If a ClipFunction is not specified, or GenerateClipScalars is off
 (the default), then the input's scalar data will be used to clip
 the polydata.

 You can also specify a scalar value, which is used to decide what is
 inside and outside of the implicit function. You can also reverse the
 sense of what inside/outside is by setting the InsideOut instance
 variable. (The clipping algorithm proceeds by computing an implicit
 function value or using the input scalar data for each point in the
 dataset. This is compared to the scalar value to determine
 inside/outside.)

 This filter can be configured to compute a second output. The
 second output is the part of the cell that is clipped away. Set the
 GenerateClippedData boolean on if you wish to access this output data.

 This filter has been implemented to operate on generic datasets, rather
 than the typical vtkDataSet (and subclasses). vtkGenericDataSet is a more
 complex cousin of vtkDataSet, typically consisting of nonlinear,
 higher-order cells. To process this type of data, generic cells are
 automatically tessellated into linear cells prior to isocontouring.

See Also:

 vtkClipDataSet vtkClipPolyData vtkClipVolume vtkImplicitFunction 
 vtkGenericDataSet


"""
class vtkGenericContourFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericContourFilter - generate isocontours from input dataset

Super Class:

 vtkPolyDataAlgorithm

 vtkGenericContourFilter is a filter that takes as input any (generic)
 dataset and generates on output isosurfaces and/or isolines. The exact
 form of the output depends upon the dimensionality of the input data.
 Data consisting of 3D cells will generate isosurfaces, data consisting of
 2D cells will generate isolines, and data with 1D or 0D cells will
 generate isopoints. Combinations of output type are possible if the input
 dimension is mixed.

 To use this filter you must specify one or more contour values.
 You can either use the method SetValue() to specify each contour
 value, or use GenerateValues() to generate a series of evenly
 spaced contours. You can use ComputeNormalsOn to compute the normals
 without the need of a vtkPolyDataNormals

 This filter has been implemented to operate on generic datasets, rather
 than the typical vtkDataSet (and subclasses). vtkGenericDataSet is a more
 complex cousin of vtkDataSet, typically consisting of nonlinear,
 higher-order cells. To process this type of data, generic cells are
 automatically tessellated into linear cells prior to isocontouring.

See Also:

 vtkContourFilter vtkGenericDataSet


"""
class vtkGenericCutter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericCutter - cut a vtkGenericDataSet with an implicit function or scalar data

Super Class:

 vtkPolyDataAlgorithm

 vtkGenericCutter is a filter to cut through data using any subclass of 
 vtkImplicitFunction. That is, a polygonal surface is created
 corresponding to the implicit function F(x,y,z) = value(s), where
 you can specify one or more values used to cut with.

 In VTK, cutting means reducing a cell of dimension N to a cut surface
 of dimension N-1. For example, a tetrahedron when cut by a plane (i.e.,
 vtkPlane implicit function) will generate triangles. (In comparison,
 clipping takes a N dimensional cell and creates N dimension primitives.)

 vtkGenericCutter is generally used to "slice-through" a dataset, generating
 a surface that can be visualized. It is also possible to use
 vtkGenericCutter to do a form of volume rendering. vtkGenericCutter does
 this by generating multiple cut surfaces (usually planes) which are ordered
 (and rendered) from back-to-front. The surfaces are set translucent to give
 a volumetric rendering effect.

 This filter has been implemented to operate on generic datasets, rather
 than the typical vtkDataSet (and subclasses). vtkGenericDataSet is a more
 complex cousin of vtkDataSet, typically consisting of nonlinear,
 higher-order cells. To process this type of data, generic cells are
 automatically tessellated into linear cells prior to isocontouring.

See Also:

 vtkCutter vtkImplicitFunction vtkClipPolyData vtkGenericDataSet


"""
class vtkGenericDataObjectReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkGenericDataObjectReader - class to read any type of vtk data object

Super Class:

 vtkDataReader

 vtkGenericDataObjectReader is a class that provides instance variables and methods
 to read any type of data object in Visualization Toolkit (vtk) format.  The
 output type of this class will vary depending upon the type of data
 file. Convenience methods are provided to return the data as a particular
 type. (See text for format description details).
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkDataReader vtkGraphReader vtkPolyDataReader vtkRectilinearGridReader 
 vtkStructuredPointsReader vtkStructuredGridReader vtkTableReader
 vtkTreeReader vtkUnstructuredGridReader


"""
class vtkGenericDataObjectWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkGenericDataObjectWriter - writes any type of vtk data object to file

Super Class:

 vtkDataWriter

 vtkGenericDataObjectWriter is a concrete class that writes data objects
 to disk. The input to this object is any subclass of vtkDataObject.


"""
class vtkGenericDataSetTessellator:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericDataSetTessellator - tessellates generic, higher-order datasets into linear cells

Super Class:

 vtkUnstructuredGridAlgorithm

See Also:

 vtkGenericCellTessellator vtkGenericSubdivisionErrorMetric


"""
class vtkGenericEnSightReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkGenericEnSightReader - class to read any type of EnSight files

Super Class:

 vtkMultiBlockDataSetAlgorithm

 The class vtkGenericEnSightReader allows the user to read an EnSight data
 set without a priori knowledge of what type of EnSight data set it is.


"""
class vtkGenericGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericGeometryFilter - extract geometry from data (or convert data to polygonal type)

Super Class:

 vtkPolyDataAlgorithm

 vtkGenericGeometryFilter is a general-purpose filter to extract geometry (and 
 associated data) from any type of dataset. Geometry is obtained as 
 follows: all 0D, 1D, and 2D cells are extracted. All 2D faces that are 
 used by only one 3D cell (i.e., boundary faces) are extracted. It also is 
 possible to specify conditions on point ids, cell ids, and on 
 bounding box (referred to as "Extent") to control the extraction process.

 This filter also may be used to convert any type of data to polygonal
 type. The conversion process may be less than satisfactory for some 3D
 datasets. For example, this filter will extract the outer surface of a 
 volume or structured grid dataset. (For structured data you may want to
 use vtkImageDataGeometryFilter, vtkStructuredGridGeometryFilter,
 vtkExtractUnstructuredGrid, vtkRectilinearGridGeometryFilter, or 
 vtkExtractVOI.)

Caveats:

 When vtkGenericGeometryFilter extracts cells (or boundaries of cells) it
 will (by default) merge duplicate vertices. This may cause problems
 in some cases. For example, if you've run vtkPolyDataNormals to
 generate normals, which may split meshes and create duplicate
 vertices, vtkGenericGeometryFilter will merge these points back
 together. Turn merging off to prevent this from occurring.

See Also:

 vtkImageDataGeometryFilter vtkStructuredGridGeometryFilter
 vtkExtractGeometry vtkExtractVOI


"""
class vtkGenericGlyph3DFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericGlyph3DFilter - copy oriented and scaled glyph geometry to every input point

Super Class:

 vtkPolyDataAlgorithm

 vtkGenericGlyph3DFilter is a filter that copies a geometric representation (called
 a glyph) to every point in the input dataset. The glyph is defined with
 polygonal data from a source filter input. The glyph may be oriented
 along the input vectors or normals, and it may be scaled according to
 scalar data or vector magnitude. More than one glyph may be used by
 creating a table of source objects, each defining a different glyph. If a
 table of glyphs is defined, then the table can be indexed into by using
 either scalar value or vector magnitude.
 
 To use this object you'll have to provide an input dataset and a source
 to define the glyph. Then decide whether you want to scale the glyph and
 how to scale the glyph (using scalar value or vector magnitude). Next
 decide whether you want to orient the glyph, and whether to use the
 vector data or normal data to orient it. Finally, decide whether to use a
 table of glyphs, or just a single glyph. If you use a table of glyphs,
 you'll have to decide whether to index into it with scalar value or with
 vector magnitude.
 

Caveats:

 Contrary to vtkGlyph3D, the only way to specify which attributes will be
 used for scaling, coloring and orienting is through SelectInputScalars(),
 SelectInputVectors() and SelectInputNormals().

 The scaling of the glyphs is controlled by the ScaleFactor ivar multiplied
 by the scalar value at each point (if VTK_SCALE_BY_SCALAR is set), or
 multiplied by the vector magnitude (if VTK_SCALE_BY_VECTOR is set),
 Alternatively (if VTK_SCALE_BY_VECTORCOMPONENTS is set),  ...
 [Truncated]

See Also:

 vtkTensorGlyph


"""
class vtkGenericOutlineFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericOutlineFilter - create wireframe outline for arbitrary

Super Class:

 vtkPolyDataAlgorithm

 vtkGenericOutlineFilter is a filter that generates a wireframe outline of
 any generic data set. The outline consists of the twelve edges of the
 generic dataset bounding box.


See Also:

 vtkGenericDataSet


"""
class vtkGenericProbeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericProbeFilter - sample data values at specified point locations

Super Class:

 vtkDataSetAlgorithm

 vtkGenericProbeFilter is a filter that computes point attributes (e.g., scalars,
 vectors, etc.) at specified point positions. The filter has two inputs:
 the Input and Source. The Input geometric structure is passed through the
 filter. The point attributes are computed at the Input point positions
 by interpolating into the source data. For example, we can compute data
 values on a plane (plane specified as Input) from a volume (Source).

 This filter can be used to resample data, or convert one dataset form into
 another. For example, a generic dataset can be probed with a volume
 (three-dimensional vtkImageData), and then volume rendering techniques can
 be used to visualize the results. Another example: a line or curve can be
 used to probe data to produce x-y plots along that line or curve.

 This filter has been implemented to operate on generic datasets, rather
 than the typical vtkDataSet (and subclasses). vtkGenericDataSet is a more
 complex cousin of vtkDataSet, typically consisting of nonlinear,
 higher-order cells. To process this type of data, generic cells are
 automatically tessellated into linear cells prior to isocontouring.

See Also:

 vtkGenericProbeFilter vtkProbeFilter vtkGenericDataSet


"""
class vtkGenericStreamTracer:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGenericStreamTracer - Streamline generator

Super Class:

 vtkPolyDataAlgorithm

 vtkGenericStreamTracer is a filter that integrates a vector field to
 generate streamlines. The integration is performed using the provided
 integrator. The default is second order Runge-Kutta. 
 
 vtkGenericStreamTracer generate polylines as output. Each cell (polyline) 
 corresponds to one streamline. The values associated with each streamline
 are stored in the cell data whereas the values associated with points
 are stored in point data.

 Note that vtkGenericStreamTracer can integrate both forward and backward. 
 The length of the streamline is controlled by specifying either
 a maximum value in the units of length, cell length or elapsed time 
 (the elapsed time is the time each particle would have traveled if
 flow were steady). Otherwise, the integration terminates after exiting 
 the dataset or if the particle speed is reduced to a value less than 
 the terminal speed or when a maximum number of steps is reached. 
 The reason for the termination is stored in a cell array named 
 ReasonForTermination.

 The quality of integration can be controlled by setting integration
 step (InitialIntegrationStep) and in the case of adaptive solvers
 the maximum error, the minimum integration step and the maximum 
 integration step. All of these can have units of length, cell length 
 or elapsed time.

 The integration time, vorticity, rotation and angular velocity
 are stored in point arrays named "IntegrationTime", "Vorticity",
 "Rotation" and "AngularVelocity" respectively (vorticity, rotation
 and angular velocity are computed only when ComputeVorticity is on).
 All point attributes in the source data set are interpolated on the 
 new streamline points.

 vtkGenericStreamTracer integrates through any type of dataset. As a result,
 if the dataset contains 2D cells such as polygons or triangles, the
 integration is constrained to lie on the surface defined by the 2D cells.

 The starting point of traces may be defined in two different ways.
 Starting from global x-y-z "position" allows you to start a single trace
 at a specified x-y-z coordinate. If you specify a source object, 
 a trace will be generated for each point in the source that is 
 inside the dataset.


See Also:

 vtkRibbonFilter vtkRuledSurfaceFilter vtkInitialValueProblemSolver 
 vtkRungeKutta2 vtkRungeKutta4 vtkRungeKutta45 


"""
class vtkGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGeometryFilter - extract geometry from data (or convert data to polygonal type)

Super Class:

 vtkPolyDataAlgorithm

 vtkGeometryFilter is a general-purpose filter to extract geometry (and 
 associated data) from any type of dataset. Geometry is obtained as 
 follows: all 0D, 1D, and 2D cells are extracted. All 2D faces that are 
 used by only one 3D cell (i.e., boundary faces) are extracted. It also is 
 possible to specify conditions on point ids, cell ids, and on 
 bounding box (referred to as "Extent") to control the extraction process.

 This filter also may be used to convert any type of data to polygonal
 type. The conversion process may be less than satisfactory for some 3D
 datasets. For example, this filter will extract the outer surface of a 
 volume or structured grid dataset. (For structured data you may want to
 use vtkImageDataGeometryFilter, vtkStructuredGridGeometryFilter,
 vtkExtractUnstructuredGrid, vtkRectilinearGridGeometryFilter, or 
 vtkExtractVOI.)

Caveats:

 When vtkGeometryFilter extracts cells (or boundaries of cells) it
 will (by default) merge duplicate vertices. This may cause problems
 in some cases. For example, if you've run vtkPolyDataNormals to
 generate normals, which may split meshes and create duplicate
 vertices, vtkGeometryFilter will merge these points back
 together. Turn merging off to prevent this from occurring.

See Also:

 vtkImageDataGeometryFilter vtkStructuredGridGeometryFilter
 vtkExtractGeometry vtkExtractVOI


"""
class vtkGlyph2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGlyph2D - copy oriented and scaled glyph geometry to every input point (2D specialization)

Super Class:

 vtkGlyph3D

 This subclass of vtkGlyph3D is a specialization to 2D. Transformations
 (i.e., translation, scaling, and rotation) are constrained to the plane.
 For example, rotations due to a vector are computed from the x-y
 coordinates of the vector only, and are assumed to occur around the
 z-axis. (See vtkGlyph3D for documentation on the interface to this
 class.)
 

See Also:

 vtkTensorGlyph vtkGlyph3D vtkProgrammableGlyphFilter


"""
class vtkGlyph3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGlyph3D - copy oriented and scaled glyph geometry to every input point

Super Class:

 vtkPolyDataAlgorithm

 vtkGlyph3D is a filter that copies a geometric representation (called
 a glyph) to every point in the input dataset. The glyph is defined with
 polygonal data from a source filter input. The glyph may be oriented
 along the input vectors or normals, and it may be scaled according to
 scalar data or vector magnitude. More than one glyph may be used by
 creating a table of source objects, each defining a different glyph. If a
 table of glyphs is defined, then the table can be indexed into by using
 either scalar value or vector magnitude.
 
 To use this object you'll have to provide an input dataset and a source
 to define the glyph. Then decide whether you want to scale the glyph and
 how to scale the glyph (using scalar value or vector magnitude). Next
 decide whether you want to orient the glyph, and whether to use the
 vector data or normal data to orient it. Finally, decide whether to use a
 table of glyphs, or just a single glyph. If you use a table of glyphs,
 you'll have to decide whether to index into it with scalar value or with
 vector magnitude.
 

Caveats:

 The scaling of the glyphs is controlled by the ScaleFactor ivar multiplied
 by the scalar value at each point (if VTK_SCALE_BY_SCALAR is set), or
 multiplied by the vector magnitude (if VTK_SCALE_BY_VECTOR is set),
 Alternatively (if VTK_SCALE_BY_VECTORCOMPONENTS is set), the scaling
 may be specified for x,y,z using the vector components. The
 scale factor can be further controlled by enabling clamping using the
 Clamping ivar. If clamping is enabled, the scale is no ...
 [Truncated]

See Also:

 vtkTensorGlyph


"""
class vtkGlyphSource2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGlyphSource2D - create 2D glyphs represented by vtkPolyData

Super Class:

 vtkPolyDataAlgorithm

 vtkGlyphSource2D can generate a family of 2D glyphs each of which lies
 in the x-y plane (i.e., the z-coordinate is zero). The class is a helper 
 class to be used with vtkGlyph2D and vtkXYPlotActor.

 To use this class, specify the glyph type to use and its
 attributes. Attributes include its position (i.e., center point), scale,
 color, and whether the symbol is filled or not (a polygon or closed line
 sequence). You can also put a short line through the glyph running from -x
 to +x (the glyph looks like it's on a line), or a cross.


"""
class vtkGradientFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGradientFilter - A general filter for gradient estimation.

Super Class:

 vtkDataSetAlgorithm

 Estimates the gradient of a scalar field in a data set.  This class
 is basically designed for unstructured data sets (i.e.
 vtkUnstructuredGrid).  More efficient filters exist for vtkImageData.



"""
class vtkGraphAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGraphAlgorithm - Superclass for algorithms that produce only Graph as output

Super Class:

 vtkAlgorithm

 vtkGraphAlgorithm is a convenience class to make writing algorithms
 easier. It is also designed to help transition old algorithms to the new
 pipeline edgehitecture. There are some assumptions and defaults made by this
 class you should be aware of. This class defaults such that your filter
 will have one input port and one output port. If that is not the case
 simply change it with SetNumberOfInputPorts etc. See this class
 constructor for the default. This class also provides a FillInputPortInfo
 method that by default says that all inputs will be Graph. If that
 isn't the case then please override this method in your subclass. This
 class breaks out the downstream requests into separate functions such as
 ExecuteData and ExecuteInformation.  For new algorithms you should
 implement RequestData( request, inputVec, outputVec) but for older filters
 there is a default implementation that calls the old ExecuteData(output)
 signature. For even older filters that don't implement ExecuteData the
 default implementation calls the even older Execute() signature.

 .SECTION Thanks
 Thanks to Patricia Crossno, Ken Moreland, Andrew Wilson and Brian Wylie from
 Sandia National Laboratories for their help in developing this class.


"""
class vtkGraphHierarchicalBundle:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGraphHierarchicalBundle - layout graph arcs in bundles

Super Class:

 vtkPolyDataAlgorithm

 This algorithm creates a vtkPolyData from a vtkAbstractGraph.  As opposed to
 vtkGraphToPolyData, which converts each arc into a straight line, each arc
 is converted to a polyline, following a tree structure.  The filter requires
 both a vtkAbstractGraph and vtkTree as input.  The tree vertices must be a
 superset of the graph vertices.  A common example is when the graph vertices
 correspond to the leaves of the tree, but the internal vertices of the tree
 represent groupings of graph vertices.  The algorithm matches the vertices
 using the array "PedigreeId".  The user may alternately set the
 DirectMapping flag to indicate that the two structures must have directly
 corresponding offsets (i.e. node i in the graph must correspond to node i in
 the tree).

 The vtkAbstractGraph defines the topology of the output vtkPolyData (i.e.
 the connections between nodes) while the vtkTree defines the geometry (i.e.
 the location of nodes and arc routes).  Thus, the tree must have been
 assigned vertex locations, but the graph does not need locations, in fact
 they will be ignored.  The edges approximately follow the path from the
 source to target nodes in the tree.  A bundling parameter controls how
 closely the edges are bundled together along the tree structure.
 
 You may follow this algorithm with vtkSplineFilter in order to make nicely
 curved edges.


"""
class vtkGraphLayout:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGraphLayout - layout a graph in 2 or 3 dimensions

Super Class:

 vtkAbstractGraphAlgorithm

 This class is a shell for many graph layout strategies which may be set
 using the SetLayoutStrategy() function.  The layout strategies do the
 actual work.

 .SECION Thanks
 Thanks to Brian Wylie from Sandia National Laboratories for adding incremental
 layout capabilities.


"""
class vtkGraphLayoutFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGraphLayoutFilter - nice layout of undirected graphs in 3D

Super Class:

 vtkPolyDataAlgorithm

 vtkGraphLayoutFilter will reposition a network of nodes, connected by
 lines or polylines, into a more pleasing arrangement. The class 
 implements a simple force-directed placement algorithm 
 (Fruchterman & Reingold "Graph Drawing by Force-directed Placement" 
 Software-Practice and Experience 21(11) 1991).

 The input to the filter is a vtkPolyData representing the undirected 
 graphs. A graph is represented by a set of polylines and/or lines. 
 The output is also a vtkPolyData, where the point positions have been 
 modified. To use the filter, specify whether you wish the layout to 
 occur in 2D or 3D; the bounds in which the graph should lie (note that you
 can just use automatic bounds computation); and modify the cool down
 rate (controls the final process of simulated annealing).


"""
class vtkGraphReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkGraphReader - read vtkGraph data file

Super Class:

 vtkDataReader

 vtkGraphReader is a source object that reads ASCII or binary 
 vtkGraph data files in vtk format. (see text for format details).
 The output of this reader is a single vtkGraph data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkGraph vtkDataReader vtkGraphWriter


"""
class vtkGraphToPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGraphToPolyData - convert a vtkGraph to vtkPolyData

Super Class:

 vtkPolyDataAlgorithm

 Converts a vtkGraph to a vtkPolyData.  This assumes that the points
 of the graph have already been filled (perhaps by vtkGraphLayout),
 and coverts all the edge of the graph into lines in the polydata.
 The vertex data is passed along to the point data, and the edge data
 is passed along to the cell data.

 Only the owned graph edges (i.e. edges with ghost level 0) are copied
 into the vtkPolyData.


"""
class vtkGraphWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkGraphWriter - write vtkGraph data to a file

Super Class:

 vtkDataWriter

 vtkGraphWriter is a sink object that writes ASCII or binary 
 vtkGraph data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkGreedyTerrainDecimation:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGreedyTerrainDecimation - reduce height field (represented as image) to reduced TIN

Super Class:

 vtkPolyDataAlgorithm

 vtkGreedyTerrainDecimation approximates a height field with a triangle
 mesh (triangulated irregular network - TIN) using a greedy insertion
 algorithm similar to that described by Garland and Heckbert in their paper
 "Fast Polygonal Approximations of Terrain and Height Fields" (Technical
 Report CMU-CS-95-181).  The input to the filter is a height field
 (represented by a image whose scalar values are height) and the output of
 the filter is polygonal data consisting of triangles. The number of
 triangles in the output is reduced in number as compared to a naive
 tessellation of the input height field. This filter copies point data
 from the input to the output for those points present in the output.

 An brief description of the algorithm is as follows. The algorithm uses a
 top-down decimation approach that initially represents the height field
 with two triangles (whose vertices are at the four corners of the
 image). These two triangles form a Delaunay triangulation. In an iterative
 fashion, the point in the image with the greatest error (as compared to
 the original height field) is injected into the triangulation. (Note that
 the single point with the greatest error per triangle is identified and
 placed into a priority queue. As the triangulation is modified, the errors
 from the deleted triangles are removed from the queue, error values from
 the new triangles are added.) The point whose error is at the top of the
 queue is added to the triangulaion modifying it using the standard
 incremental Delaunay point insertion (see vtkDelaunay2D) algorithm. Points
 are repeatedly inserted until the appropriate (user-specified) error
 criterion is met.

 To use this filter, set the input and specify the error measure to be
 used.  The error measure options are 1) the absolute number of triangles
 to be produced; 2) a fractional reduction of the mesh (numTris/maxTris)
 where maxTris is the largest possible number of triangles
 2*(dims[0]-1)*(dims[1]-1); 3) an absolute measure on error (maximum
 difference in height field to reduced TIN); and 4) relative error (the
 absolute error is normalized by the diagonal of the bounding box of the
 height field).
 

Caveats:

 This algorithm requires the entire input dataset to be in memory, hence it 
 may not work for extremely large images. Invoking BoundaryVertexDeletionOff
 will allow you to stitch together images with matching boundaries.

 The input height image is assumed to be positioned in the x-y plane so the
 scalar value is the z-coordinate, height value.


See Also:

 vtkDecimatePro vtkQuadricDecimation vtkQuadricClustering


"""
class vtkGridSynchronizedTemplates3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGridSynchronizedTemplates3D - generate isosurface from structured grids

Super Class:

 vtkPolyDataAlgorithm

 vtkGridSynchronizedTemplates3D is a 3D implementation of the synchronized 
 template algorithm.

Caveats:

 This filter is specialized to 3D grids.

See Also:

 vtkContourFilter vtkSynchronizedTemplates3D


"""
class vtkGroupLeafVertices:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkGroupLeafVertices - Filter that expands a tree, categorizing leaf vertices

Super Class:

 vtkTreeAlgorithm

 Use SetInputArrayToProcess(0, ...) to set the array to group on.
 Currently this array must be a vtkStringArray.


"""
class vtkHedgeHog:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHedgeHog - create oriented lines from vector data

Super Class:

 vtkPolyDataAlgorithm

 vtkHedgeHog creates oriented lines from the input data set. Line
 length is controlled by vector (or normal) magnitude times scale
 factor. If VectorMode is UseNormal, normals determine the orientation
 of the lines. Lines are colored by scalar data, if available.


"""
class vtkHierarchicalDataExtractDataSets:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHierarchicalDataExtractDataSets - extract a number of datasets

Super Class:

 vtkMultiGroupDataExtractDataSets

 Legacy class. Use vtkMultiGroupDataExtractDataSets instead.


See Also:

 vtkMultiGroupDataExtractDataSets


"""
class vtkHierarchicalDataExtractLevel:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHierarchicalDataExtractLevel - extact levels between min and max

Super Class:

 vtkMultiGroupDataExtractGroup

 Legacy class. Use vtkMultiGroupDataExtractGroup instead.

See Also:

 vtkMultiGroupDataExtractGroup


"""
class vtkHierarchicalDataGroupFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHierarchicalDataGroupFilter - collects multiple inputs into one hierarchical dataset

Super Class:

 vtkMultiGroupDataGroupFilter

 Legacy class. Use vtkMultiGroupDataGroupFilter instead.


See Also:

 vtkMultiGroupDataGroupFilter


"""
class vtkHierarchicalDataLevelFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHierarchicalDataLevelFilter - generate scalars from levels

Super Class:

 vtkMultiGroupDataGroupIdScalars

 Legacy class. Use vtkMultiGroupDataGroupIdScalars instead.


See Also:

 vtkMultiGroupDataGroupIdScalars


"""
class vtkHierarchicalDataSetAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHierarchicalDataSetAlgorithm - Superclass for algorithms that produce only vtkHierarchicalDataSet as output

Super Class:

 vtkAlgorithm

 Algorithms that take any type of data object (including composite dataset)
 and produce a vtkHierarchicalDataSet in the output can subclass from this
 class.


"""
class vtkHierarchicalDataSetGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHierarchicalDataSetGeometryFilter - extract geometry from hierarchical data

Super Class:

 vtkMultiGroupDataGeometryFilter

 Legacy class. Use vtkMultiGroupDataGeometryFilter instead.


See Also:

 vtkMultiGroupDataGeometryFilter


"""
class vtkHull:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHull - produce an n-sided convex hull

Super Class:

 vtkPolyDataAlgorithm

 vtkHull is a filter which will produce an n-sided convex hull given a
 set of n planes. (The convex hull bounds the input polygonal data.)
 The hull is generated by squeezing the planes towards the input
 vtkPolyData, until the planes just touch the vtkPolyData. Then,
 the resulting planes are used to generate a polyhedron (i.e., hull)
 that is represented by triangles.

 The n planes can be defined in a number of ways including 1) manually 
 specifying each plane; 2) choosing the six face planes of the input's
 bounding box; 3) choosing the eight vertex planes of the input's
 bounding box; 4) choosing the twelve edge planes of the input's
 bounding box; and/or 5) using a recursively subdivided octahedron.
 Note that when specifying planes, the plane normals should point
 outside of the convex region.

 The output of this filter can be used in combination with vtkLODActor 
 to represent a levels-of-detail in the LOD hierarchy. Another use of
 this class is to manually specify the planes, and then generate the
 polyhedron from the planes (without squeezing the planes towards the
 input). The method GenerateHull() is used to do this.


"""
class vtkHyperOctreeContourFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeContourFilter - generate isosurfaces/isolines from scalar values

Super Class:

 vtkPolyDataAlgorithm

 vtkContourFilter is a filter that takes as input any dataset and 
 generates on output isosurfaces and/or isolines. The exact form 
 of the output depends upon the dimensionality of the input data. 
 Data consisting of 3D cells will generate isosurfaces, data 
 consisting of 2D cells will generate isolines, and data with 1D 
 or 0D cells will generate isopoints. Combinations of output type 
 are possible if the input dimension is mixed.

 To use this filter you must specify one or more contour values.
 You can either use the method SetValue() to specify each contour
 value, or use GenerateValues() to generate a series of evenly
 spaced contours. It is also possible to accelerate the operation of
 this filter (at the cost of extra memory) by using a
 vtkScalarTree. A scalar tree is used to quickly locate cells that
 contain a contour surface. This is especially effective if multiple
 contours are being extracted. If you want to use a scalar tree,
 invoke the method UseScalarTreeOn().

Caveats:

 For unstructured data or structured grids, normals and gradients
 are not computed. Use vtkPolyDataNormals to compute the surface
 normals.

See Also:

 vtkMarchingContourFilter vtkKitwareContourFilter
 vtkMarchingCubes vtkSliceCubes vtkDividingCubes vtkMarchingSquares
 vtkImageMarchingCubes


"""
class vtkHyperOctreeCutter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeCutter - Cut vtkHyperOctree with user-specified

Super Class:

 vtkPolyDataAlgorithm

 vtkHyperOctreeCutter is a filter to cut through data using any subclass of 
 vtkImplicitFunction. That is, a polygonal surface is created
 corresponding to the implicit function F(x,y,z) = value(s), where
 you can specify one or more values used to cut with.

 In VTK, cutting means reducing a cell of dimension N to a cut surface
 of dimension N-1. For example, a tetrahedron when cut by a plane (i.e.,
 vtkPlane implicit function) will generate triangles. (In comparison,
 clipping takes a N dimensional cell and creates N dimension primitives.)

 vtkHyperOctreeCutter is generally used to "slice-through" a dataset,
 generating a surface that can be visualized. It is also possible to use
 vtkHyperOctreeCutter to do a form of volume rendering. vtkHyperOctreeCutter
 does this by generating multiple cut surfaces (usually planes) which are
 ordered (and rendered) from back-to-front. The surfaces are set translucent
 to give a volumetric rendering effect.

 Note that data can be cut using either 1) the scalar values associated
 with the dataset or 2) an implicit function associated with this class.
 By default, if an implicit function is set it is used to cut the data
 set, otherwise the dataset scalars are used to perform the cut.

See Also:

 vtkImplicitFunction vtkHyperOctree


"""
class vtkHyperOctreeDepth:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeDepth - Assign tree depth attribute to each cell.

Super Class:

 vtkDataSetAlgorithm

 This filter returns a shallow copy of its input HyperOctree with a new
 data attribute field containing the depth of each cell.

See Also:

 vtkHyperOctree


"""
class vtkHyperOctreeDualGridContourFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeDualGridContourFilter - generate isosurfaces/isolines from scalar values

Super Class:

 vtkPolyDataAlgorithm

 use of unsigned short to hold level index limits tree depth to 16.

 To use this filter you must specify one or more contour values.
 You can either use the method SetValue() to specify each contour
 value, or use GenerateValues() to generate a series of evenly
 spaced contours. It is also possible to accelerate the operation of
 this filter (at the cost of extra memory) by using a
 vtkScalarTree. A scalar tree is used to quickly locate cells that
 contain a contour surface. This is especially effective if multiple
 contours are being extracted. If you want to use a scalar tree,
 invoke the method UseScalarTreeOn().

See Also:

 vtkMarchingContourFilter vtkKitwareContourFilter
 vtkMarchingCubes vtkSliceCubes vtkDividingCubes vtkMarchingSquares
 vtkImageMarchingCubes


"""
class vtkHyperOctreeFractalSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeFractalSource - Create an octree from a fractal.

Super Class:

 vtkHyperOctreeAlgorithm



See Also:

 vtkHyperOctreeSampleFunction


"""
class vtkHyperOctreeLimiter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeLimiter - Limit the tree's depth, averaging data

Super Class:

 vtkDataSetAlgorithm

 This filter returns a lower resolution copy of its input vtkHyperOctree.
 It does a length/area/volume weighted averaging to obtain data at each
 cut point. Above the cut level, leaf attribute data is simply copied.

See Also:

 vtkHyperOctree


"""
class vtkHyperOctreeSampleFunction:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeSampleFunction - sample an implicit function over an

Super Class:

 vtkHyperOctreeAlgorithm

 vtkHyperOctreeSampleFunction is a source object that evaluates an implicit
 function to drive the subdivision process. The user can specify
 the threshold over which a subdivision occurs, the maximum and minimum
 level of subdivisions and the dimension of the hyperoctree.


See Also:

 vtkSampleFunction


"""
class vtkHyperOctreeSurfaceFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeSurfaceFilter - Extracts outer (polygonal) surface.

Super Class:

 vtkPolyDataAlgorithm

 vtkHyperOctreeSurfaceFilter extracts the surface of an hyperoctree.

See Also:

 vtkGeometryFilter vtkStructuredGridGeometryFilter.


"""
class vtkHyperOctreeToUniformGridFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperOctreeToUniformGridFilter - Flat the octree into a uniform

Super Class:

 vtkImageAlgorithm

 vtkHyperOctreeToUniformGridFilter creates a uniform grid with a resolution
 based on the number of levels of the hyperoctree. Then, it copies celldata
 in each cell of the uniform grid that belongs to an actual leaf of the
 hyperoctree.


See Also:

 vtkGeometryFilter vtkStructuredGridGeometryFilter.


"""
class vtkHyperStreamline:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkHyperStreamline - generate hyperstreamline in arbitrary dataset

Super Class:

 vtkPolyDataAlgorithm

 vtkHyperStreamline is a filter that integrates through a tensor field to 
 generate a hyperstreamline. The integration is along the maximum eigenvector
 and the cross section of the hyperstreamline is defined by the two other
 eigenvectors. Thus the shape of the hyperstreamline is "tube-like", with 
 the cross section being elliptical. Hyperstreamlines are used to visualize
 tensor fields.

 The starting point of a hyperstreamline can be defined in one of two ways. 
 First, you may specify an initial position. This is a x-y-z global 
 coordinate. The second option is to specify a starting location. This is 
 cellId, subId, and  cell parametric coordinates.

 The integration of the hyperstreamline occurs through the major eigenvector 
 field. IntegrationStepLength controls the step length within each cell 
 (i.e., this is the fraction of the cell length). The length of the 
 hyperstreamline is controlled by MaximumPropagationDistance. This parameter
 is the length of the hyperstreamline in units of distance. The tube itself 
 is composed of many small sub-tubes - NumberOfSides controls the number of 
 sides in the tube, and StepLength controls the length of the sub-tubes.

 Because hyperstreamlines are often created near regions of singularities, it
 is possible to control the scaling of the tube cross section by using a 
 logarithmic scale. Use LogScalingOn to turn this capability on. The Radius 
 value controls the initial radius of the tube.

See Also:

 vtkTensorGlyph vtkStreamer


"""
class vtkIVWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkIVWriter - export polydata into OpenInventor 2.0 format.

Super Class:

 vtkPolyDataWriter

 vtkIVWriter is a concrete subclass of vtkWriter that writes OpenInventor 2.0
 files.


See Also:

 vtkPolyDataWriter


"""
class vtkIdFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkIdFilter - generate scalars or field data from point and cell ids

Super Class:

 vtkDataSetAlgorithm

 vtkIdFilter is a filter to that generates scalars or field data
 using cell and point ids. That is, the point attribute data scalars
 or field data are generated from the point ids, and the cell
 attribute data scalars or field data are generated from the the
 cell ids.

 Typically this filter is used with vtkLabeledDataMapper (and possibly
 vtkSelectVisiblePoints) to create labels for points and cells, or labels
 for the point or cell data scalar values.


"""
class vtkImageAccumulate:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageAccumulate - Generalized histograms up to 4 dimensions.

Super Class:

 vtkImageAlgorithm

 vtkImageAccumulate - This filter divides component space into
 discrete bins.  It then counts the number of pixels associated
 with each bin.  The output is this "scatter plot" (histogram values for 1D).
 The dimensionality of the output depends on how many components the
 input pixels have.  Input pixels with one component generate a 1D histogram.
 This filter can only handle images with 1 to 3 scalar components.
 The input can be any type, but the output is always int.
 Some statistics are computed on the pixel values at the same time.
 The SetStencil and ReverseStencil
 functions allow the statistics to be computed on an arbitrary
 portion of the input data.
 See the documentation for vtkImageStencilData for more information.


"""
class vtkImageAnisotropicDiffusion2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageAnisotropicDiffusion2D - edge preserving smoothing.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageAnisotropicDiffusion2D  diffuses a 2d image iteratively.
 The neighborhood of the diffusion is determined by the instance
 flags. If "Edges" is on the 4 edge connected voxels
 are included, and if "Corners" is on, the 4 corner connected voxels
 are included.  "DiffusionFactor" determines how far a pixel value
 moves toward its neighbors, and is insensitive to the number of 
 neighbors chosen.  The diffusion is anisotropic because it only occurs
 when a gradient measure is below "GradientThreshold".  Two gradient measures
 exist and are toggled by the "GradientMagnitudeThreshold" flag.
 When "GradientMagnitudeThreshold" is on, the magnitude of the gradient,
 computed by central differences, above "DiffusionThreshold"
 a voxel is not modified.  The alternative measure examines each
 neighbor independently.  The gradient between the voxel and the neighbor
 must be below the "DiffusionThreshold" for diffusion to occur with
 THAT neighbor.

See Also:

 vtkImageAnisotropicDiffusion3D


"""
class vtkImageAnisotropicDiffusion3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageAnisotropicDiffusion3D - edge preserving smoothing.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageAnisotropicDiffusion3D  diffuses an volume iteratively.
 The neighborhood of the diffusion is determined by the instance
 flags. if "Faces" is on, the 6 voxels adjoined by faces are included
 in the neighborhood.  If "Edges" is on the 12 edge connected voxels
 are included, and if "Corners" is on, the 8 corner connected voxels
 are included.  "DiffusionFactor" determines how far a pixel value
 moves toward its neighbors, and is insensitive to the number of 
 neighbors chosen.  The diffusion is anisotropic because it only occurs
 when a gradient measure is below "GradientThreshold".  Two gradient measures
 exist and are toggled by the "GradientMagnitudeThreshold" flag.
 When "GradientMagnitudeThreshold" is on, the magnitude of the gradient,
 computed by central differences, above "DiffusionThreshold"
 a voxel is not modified.  The alternative measure examines each
 neighbor independently.  The gradient between the voxel and the neighbor
 must be below the "DiffusionThreshold" for diffusion to occur with
 THAT neighbor.

See Also:

 vtkImageAnisotropicDiffusion2D


"""
class vtkImageAppend:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageAppend - Collects data from multiple inputs into one image.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageAppend takes the components from multiple inputs and merges
 them into one output. The output images are append along the "AppendAxis".
 Except for the append axis, all inputs must have the same extent.
 All inputs must have the same number of scalar components.
 A future extension might be to pad or clip inputs to have the same extent.
 The output has the same origin and spacing as the first input.
 The origin and spacing of all other inputs are ignored.  All inputs
 must have the same scalar type.


"""
class vtkImageAppendComponents:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageAppendComponents - Collects components from two inputs into

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageAppendComponents takes the components from two inputs and merges
 them into one output. If Input1 has M components, and Input2 has N 
 components, the output will have M+N components with input1
 components coming first.


"""
class vtkImageBlend:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageBlend - blend images together using alpha or opacity

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageBlend takes L, LA, RGB, or RGBA images as input and blends them
 according to the alpha values and/or the opacity setting for each input.

 The spacing, origin, extent, and number of components of the output are
 the same as those for the first input.  If the input has an alpha
 component, then this component is copied unchanged into the output.
 In addition, if the first input has either one component or two
 components i.e. if it is either L (greyscale) or LA (greyscale + alpha)
 then all other inputs must also be L or LA.

 Different blending modes are available:

 \em Normal (default) :
 This is the standard blending mode used by OpenGL and other graphics
 packages.  The output always has the same number of components
 and the same extent as the first input.  The alpha value of the first
 input is not used in the blending computation, instead it is copied
 directly to the output.

 \code
 output <- input[0]
 foreach input i {
   foreach pixel px {
     r <- input[i](px)(alpha) * opacity[i]
     f <- (255 - r)
     output(px) <- output(px) * f + input(px) * r
   }
 }
 \endcode

 \em Compound :
 Images are compounded together and each component is scaled by the sum of
 the alpha/opacity values. Use the CompoundThreshold method to set
 specify a threshold in compound mode. Pixels with opacity*alpha less
 or equal than this threshold are ignored.
 The alpha value of the first input, if present, is NOT copied to the alpha
 value of the output.  The output always has the same number of components
 and the same extent as the first input.

 \code
 output <- 0
 foreach pixel px {
   sum <- 0
   foreach input i {
     r <- input[i](px)(alpha) * opacity(i)
     sum <- sum + r
     if r > threshold {
       output(px) <- output(px) + input(px) * r
     }
   }
   output(px) <- output(px) / sum
 }
 \endcode


"""
class vtkImageButterworthHighPass:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageButterworthHighPass - Frequency domain high pass.

Super Class:

 vtkThreadedImageAlgorithm

 This filter only works on an image after it has been converted to
 frequency domain by a vtkImageFFT filter.  A vtkImageRFFT filter
 can be used to convert the output back into the spatial domain.
 vtkImageButterworthHighPass  the frequency components around 0 are
 attenuated.  Input and output are in doubles, with two components
 (complex numbers).
 out(i, j) = 1 / (1 + pow(CutOff/Freq(i,j), 2*Order));

See Also:

 vtkImageButterworthLowPass


"""
class vtkImageButterworthLowPass:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageButterworthLowPass - Frequency domain Low pass.

Super Class:

 vtkThreadedImageAlgorithm

 This filter only works on an image after it has been converted to
 frequency domain by a vtkImageFFT filter.  A vtkImageRFFT filter
 can be used to convert the output back into the spatial domain.
 vtkImageButterworthLowPass  the high frequency components are
 attenuated.  Input and output are in doubles, with two components
 (complex numbers).
 out(i, j) = (1 + pow(CutOff/Freq(i,j), 2*Order));

See Also:

 vtkImageButterworthHighPass vtkImageFFT vtkImageRFFT


"""
class vtkImageCacheFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageCacheFilter - Caches multiple vtkImageData objects.

Super Class:

 vtkImageAlgorithm

 vtkImageCacheFilter keep a number of vtkImageDataObjects from previous
 updates to satisfy future updates without needing to update the input.  It
 does not change the data at all.  It just makes the pipeline more
 efficient at the expense of using extra memory.


"""
class vtkImageCast:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageCast -  Image Data type Casting Filter

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageCast filter casts the input type to match the output type in
 the image processing pipeline.  The filter does nothing if the input
 already has the correct type.  To specify the "CastTo" type,
 use "SetOutputScalarType" method.

See Also:

 vtkImageThreshold vtkImageShiftScale


"""
class vtkImageChangeInformation:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageChangeInformation - modify spacing, origin and extent.

Super Class:

 vtkImageAlgorithm

 vtkImageChangeInformation  modify the spacing, origin, or extent of
 the data without changing the data itself.  The data is not resampled
 by this filter, only the information accompanying the data is modified.


"""
class vtkImageCheckerboard:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageCheckerboard - show two images at once using a checkboard pattern

Super Class:

 vtkThreadedImageAlgorithm

  vtkImageCheckerboard displays two images as one using a checkerboard
  pattern. This filter can be used to compare two images. The
  checkerboard pattern is controlled by the NumberOfDivisions
  ivar. This controls the number of checkerboard divisions in the whole
  extent of the image.


"""
class vtkImageCityBlockDistance:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageCityBlockDistance - 1,2 or 3D distance map.

Super Class:

 vtkImageDecomposeFilter

 vtkImageCityBlockDistance creates a distance map using the city block
 (Manhatten) distance measure.  The input is a mask.  Zero values are
 considered boundaries.  The output pixel is the minimum of the input pixel
 and the distance to a boundary (or neighbor value + 1 unit).
 distance values are calculated in pixels.
 The filter works by taking 6 passes (for 3d distance map): 2 along each 
 axis (forward and backward). Each pass keeps a running minimum distance.
 For some reason, I preserve the sign if the distance.  If the input 
 mask is initially negative, the output distances will be negative.
 Distances maps can have inside (negative regions) 
 and outsides (positive regions).


"""
class vtkImageClip:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageClip - Reduces the image extent of the input.

Super Class:

 vtkImageAlgorithm

 vtkImageClip  will make an image smaller.  The output must have
 an image extent which is the subset of the input.  The filter has two 
 modes of operation: 
 1: By default, the data is not copied in this filter. 
 Only the whole extent is modified.  
 2: If ClipDataOn is set, then you will get no more that the clipped
 extent.


"""
class vtkImageConstantPad:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageConstantPad - Makes image larger by padding with constant.

Super Class:

 vtkImagePadFilter

 vtkImageConstantPad changes the image extent of its input.
 Any pixels outside of the original image extent are filled with
 a constant value.

See Also:

 vtkImageWrapPad vtkImageMirrorPad


"""
class vtkImageContinuousDilate3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageContinuousDilate3D - Dilate implemented as a maximum.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageContinuousDilate3D replaces a pixel with the maximum over
 an ellipsoidal neighborhood.  If KernelSize of an axis is 1, no processing
 is done on that axis.


"""
class vtkImageContinuousErode3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageContinuousErode3D - Erosion implemented as a minimum.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageContinuousErode3D replaces a pixel with the minimum over
 an ellipsoidal neighborhood.  If KernelSize of an axis is 1, no processing
 is done on that axis.


"""
class vtkImageConvolve:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageConvolve - Convolution of an image with a kernel.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageConvolve convolves the image with a 3D NxNxN kernel or a
 2D NxN kernal.  The output image is cropped to the same size as
 the input.


"""
class vtkImageCorrelation:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageCorrelation - Correlation imageof the two inputs.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageCorrelation finds the correlation between two data sets. 
 SetDimensionality determines
 whether the Correlation will be 3D, 2D or 1D.  
 The default is a 2D Correlation.  The Output type will be double.
 The output size will match the size of the first input.
 The second input is considered the correlation kernel.


"""
class vtkImageCursor3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageCursor3D - Paints a cursor on top of an image or volume.

Super Class:

 vtkImageInPlaceFilter

 vtkImageCursor3D will draw a cursor on a 2d image or 3d volume.


"""
class vtkImageDataGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageDataGeometryFilter - extract geometry for structured points

Super Class:

 vtkPolyDataAlgorithm

 vtkImageDataGeometryFilter is a filter that extracts geometry from a
 structured points dataset. By specifying appropriate i-j-k indices (via the 
 "Extent" instance variable), it is possible to extract a point, a line, a 
 plane (i.e., image), or a "volume" from dataset. (Since the output is 
 of type polydata, the volume is actually a (n x m x o) region of points.)

 The extent specification is zero-offset. That is, the first k-plane in
 a 50x50x50 volume is given by (0,49, 0,49, 0,0).

Caveats:

 If you don't know the dimensions of the input dataset, you can use a large
 number to specify extent (the number will be clamped appropriately). For 
 example, if the dataset dimensions are 50x50x50, and you want a the fifth 
 k-plane, you can use the extents (0,100, 0,100, 4,4). The 100 will 
 automatically be clamped to 49.

See Also:

 vtkGeometryFilter vtkStructuredGridSource


"""
class vtkImageDataStreamer:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageDataStreamer - Initiates streaming on image data.

Super Class:

 vtkImageAlgorithm

 To satisfy a request, this filter calls update on its input
 many times with smaller update extents.  All processing up stream
 streams smaller pieces.


"""
class vtkImageDifference:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageDifference - Compares images for regression tests.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageDifference takes two rgb unsigned char images and compares them.
 It allows the images to be slightly different.  If AllowShift is on,
 then each pixel can be shifted by one pixel. Threshold is the allowable
 error for each pixel.

 This is not a symetric filter and the difference computed is not symetric
 when AllowShift is on. Specifically in that case a pixel in SetImage input
 will be compared to the matching pixel in the input as well as to the
 input's eight connected neighbors. BUT... the opposite is not true. So for
 example if a valid image (SetImage) has a single white pixel in it, it
 will not find a match in the input image if the input image is black
 (because none of the nine suspect pixels are white). In contrast, if there
 is a single white pixel in the input image and the valid image (SetImage)
 is all black it will match with no error because all it has to do is find
 black pixels and even though the input image has a white pixel, its
 neighbors are not white.


"""
class vtkImageDilateErode3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageDilateErode3D - Dilates one value and erodes another.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageDilateErode3D will dilate one value and erode another.
 It uses an elliptical foot print, and only erodes/dilates on the
 boundary of the two values.  The filter is restricted to the 
 X, Y, and Z axes for now.  It can degenerate to a 2 or 1 dimensional
 filter by setting the kernel size to 1 for a specific axis.


"""
class vtkImageDivergence:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageDivergence - Divergence of a vector field.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageDivergence takes a 3D vector field 
 and creates a scalar field which 
 which represents the rate of change of the vector field.
 The definition of Divergence:
 Given V = P(x,y,z), Q(x,y,z), R(x,y,z),
 Divergence = dP/dx + dQ/dy + dR/dz.


"""
class vtkImageDotProduct:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageDotProduct - Dot product of two vector images.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageDotProduct interprets the scalar components of two images
 as vectors and takes the dot product vector by vector (pixel by pixel).


"""
class vtkImageEllipsoidSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageEllipsoidSource - Create a binary image of an ellipsoid.

Super Class:

 vtkImageAlgorithm

 vtkImageEllipsoidSource creates a binary image of a ellipsoid.  It was created
 as an example of a simple source, and to test the mask filter.
 It is also used internally in vtkImageDilateErode3D.


"""
class vtkImageEuclideanDistance:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageEuclideanDistance - computes 3D Euclidean DT 

Super Class:

 vtkImageDecomposeFilter

 vtkImageEuclideanDistance implements the Euclidean DT using
 Saito's algorithm. The distance map produced contains the square of the
 Euclidean distance values. 

 The algorithm has a o(n^(D+1)) complexity over nxnx...xn images in D 
 dimensions. It is very efficient on relatively small images. Cuisenaire's
 algorithms should be used instead if n >> 500. These are not implemented
 yet.

 For the special case of images where the slice-size is a multiple of 
 2^N with a large N (typically for 256x256 slices), Saito's algorithm 
 encounters a lot of cache conflicts during the 3rd iteration which can 
 slow it very significantly. In that case, one should use 
 ::SetAlgorithmToSaitoCached() instead for better performance. 

 References:

 T. Saito and J.I. Toriwaki. New algorithms for Euclidean distance 
 transformations of an n-dimensional digitised picture with applications.
 Pattern Recognition, 27(11). pp. 1551--1565, 1994. 
 
 O. Cuisenaire. Distance Transformation: fast algorithms and applications
 to medical image processing. PhD Thesis, Universite catholique de Louvain,
 October 1999. http://ltswww.epfl.ch/~cuisenai/papers/oc_thesis.pdf 


"""
class vtkImageEuclideanToPolar:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageEuclideanToPolar - Converts 2D Euclidean coordinates to polar.

Super Class:

 vtkThreadedImageAlgorithm

 For each pixel with vector components x,y, this filter outputs 
 theta in component0, and radius in component1.


"""
class vtkImageExport:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageExport - Export VTK images to third-party systems.

Super Class:

 vtkImageAlgorithm

 vtkImageExport provides a way of exporting image data at the end
 of a pipeline to a third-party system or to a simple C array.
 Applications can use this to get direct access to the image data
 in memory.  A callback interface is provided to allow connection
 of the VTK pipeline to a third-party pipeline.  This interface
 conforms to the interface of vtkImageImport.
 In Python it is possible to use this class to write the image data
 into a python string that has been pre-allocated to be the correct
 size.

See Also:

 vtkImageImport


"""
class vtkImageExtractComponents:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageExtractComponents - Outputs a single component

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageExtractComponents takes an input with any number of components
 and outputs some of them.  It does involve a copy of the data.

See Also:

 vtkImageAppendComponents


"""
class vtkImageFFT:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageFFT -  Fast Fourier Transform.

Super Class:

 vtkImageFourierFilter

 vtkImageFFT implements a  fast Fourier transform.  The input
 can have real or complex data in any components and data types, but
 the output is always complex doubles with real values in component0, and
 imaginary values in component1.  The filter is fastest for images that
 have power of two sizes.  The filter uses a butterfly fitlers for each
 prime factor of the dimension.  This makes images with prime number dimensions 
 (i.e. 17x17) much slower to compute.  Multi dimensional (i.e volumes) 
 FFT's are decomposed so that each axis executes in series.


"""
class vtkImageFlip:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageFlip - This flips an axis of an image. Right becomes left ...

Super Class:

 vtkImageReslice

 vtkImageFlip will reflect the data along the filtered axis.  This filter is
 actually a thin wrapper around vtkImageReslice.


"""
class vtkImageFourierCenter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageFourierCenter - Shifts constant frequency to center for

Super Class:

 vtkImageDecomposeFilter

 Is used for dispaying images in frequency space.  FFT converts spatial
 images into frequency space, but puts the zero frequency at the origin.
 This filter shifts the zero frequency to the center of the image.
 Input and output are assumed to be doubles.


"""
class vtkImageGaussianSmooth:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageGaussianSmooth - Performs a gaussian convolution.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageGaussianSmooth implements a convolution of the input image
 with a gaussian. Supports from one to three dimensional convolutions.


"""
class vtkImageGaussianSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageGaussianSource - Create an image with Gaussian pixel values.

Super Class:

 vtkImageAlgorithm

 vtkImageGaussianSource just produces images with pixel values determined 
 by a Gaussian.


"""
class vtkImageGradient:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageGradient - Computes the gradient vector.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageGradient computes the gradient vector of an image.  The
 vector results are stored as scalar components. The Dimensionality
 determines whether to perform a 2d or 3d gradient. The default is
 two dimensional XY gradient.  OutputScalarType is always
 double. Gradient is computed using central differences.


"""
class vtkImageGradientMagnitude:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageGradientMagnitude - Computes magnitude of the gradient.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageGradientMagnitude computes the gradient magnitude of an image.
 Setting the dimensionality determines whether the gradient is computed on
 2D images, or 3D volumes.  The default is two dimensional XY images.

See Also:

 vtkImageGradient vtkImageMagnitude


"""
class vtkImageGridSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageGridSource - Create an image of a grid.

Super Class:

 vtkImageAlgorithm

 vtkImageGridSource produces an image of a grid.  The
 default output type is double.


"""
class vtkImageHSIToRGB:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageHSIToRGB - Converts HSI components to RGB.

Super Class:

 vtkThreadedImageAlgorithm

 For each pixel with hue, saturation and intensity components this filter
 outputs the color coded as red, green, blue.  Output type must be the same
 as input type.

See Also:

 vtkImageRGBToHSI


"""
class vtkImageHSVToRGB:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageHSVToRGB - Converts HSV components to RGB.

Super Class:

 vtkThreadedImageAlgorithm

 For each pixel with hue, saturation and value components this filter
 outputs the color coded as red, green, blue.  Output type must be the same
 as input type.

See Also:

 vtkImageRGBToHSV


"""
class vtkImageHybridMedian2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageHybridMedian2D - Median filter that preserves lines and 

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageHybridMedian2D is a median filter that preserves thin lines and
 corners.  It operates on a 5x5 pixel neighborhood.  It computes two values
 initially: the median of the + neighbors and the median of the x
 neighbors.  It then computes the median of these two values plus the center
 pixel.  This result of this second median is the output pixel value.


"""
class vtkImageIdealHighPass:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageIdealHighPass - Simple frequency domain band pass.

Super Class:

 vtkThreadedImageAlgorithm

 This filter only works on an image after it has been converted to
 frequency domain by a vtkImageFFT filter.  A vtkImageRFFT filter
 can be used to convert the output back into the spatial domain.
 vtkImageIdealHighPass just sets a portion of the image to zero.  The sharp
 cutoff in the frequence domain produces ringing in the spatial domain.
 Input and Output must be doubles.  Dimensionality is set when the axes are
 set.  Defaults to 2D on X and Y axes.

See Also:

 vtkImageButterworthHighPass vtkImageIdealLowPass vtkImageFFT vtkImageRFFT


"""
class vtkImageIdealLowPass:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageIdealLowPass - Simple frequency domain band pass.

Super Class:

 vtkThreadedImageAlgorithm

 This filter only works on an image after it has been converted to
 frequency domain by a vtkImageFFT filter.  A vtkImageRFFT filter
 can be used to convert the output back into the spatial domain.
 vtkImageIdealLowPass just sets a portion of the image to zero.  The result
 is an image with a lot of ringing.  Input and Output must be doubles.
 Dimensionality is set when the axes are set.  Defaults to 2D on X and Y
 axes.

See Also:

 vtkImageButterworthLowPass vtkImageIdealHighPass vtkImageFFT vtkImageRFFT


"""
class vtkImageImport:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageImport - Import data from a C array.

Super Class:

 vtkImageAlgorithm

 vtkImageImport provides methods needed to import image data from a source
 independent of VTK, such as a simple C array or a third-party pipeline.
 Note that the VTK convention is for the image voxel index (0,0,0) to be
 the lower-left corner of the image, while most 2D image formats use
 the upper-left corner.  You can use vtkImageFlip to correct the 
 orientation after the image has been loaded into VTK.
 Note that is also possible to import the raw data from a Python string
 instead of from a C array.

See Also:

 vtkImageExport


"""
class vtkImageIslandRemoval2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageIslandRemoval2D - Removes small clusters in masks.

Super Class:

 vtkImageAlgorithm

 vtkImageIslandRemoval2D computes the area of separate islands in 
 a mask image.  It removes any island that has less than AreaThreshold
 pixels.  Output has the same ScalarType as input.  It generates
 the whole 2D output image for any output request.


"""
class vtkImageLaplacian:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageLaplacian - Computes divergence of gradient.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageLaplacian computes the Laplacian (like a second derivative)
 of a scalar image.  The operation is the same as taking the
 divergence after a gradient.  Boundaries are handled, so the input
 is the same as the output.
 Dimensionality determines how the input regions are interpreted.
 (images, or volumes). The Dimensionality defaults to two.


"""
class vtkImageLogarithmicScale:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageLogarithmicScale - Passes each pixel through log function.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageLogarithmicScale passes each pixel through the function
 c*log(1+x).  It also handles negative values with the function
 -c*log(1-x).


"""
class vtkImageLogic:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageLogic - And, or, xor, nand, nor, not.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageLogic implements basic logic operations.
 SetOperation is used to select the filter's behavior.
 The filter can take two or one input. Inputs must have the same type.


"""
class vtkImageLuminance:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageLuminance - Computes the luminance of the input

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageLuminance calculates luminance from an rgb input.


"""
class vtkImageMagnify:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMagnify - magnify an image by an integer value

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageMagnify maps each pixel of the input onto a nxmx... region
 of the output.  Location (0,0,...) remains in the same place. The
 magnification occurs via pixel replication, or if Interpolate is on,
 by bilinear interpolation. Initially, interpolation is off and magnification
 factors are set to 1 in all directions.


"""
class vtkImageMagnitude:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMagnitude - Colapses components with magnitude function..

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageMagnitude takes the magnitude of the components.


"""
class vtkImageMandelbrotSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMandelbrotSource - Mandelbrot image.

Super Class:

 vtkImageAlgorithm

 vtkImageMandelbrotSource creates an unsigned char image of the Mandelbrot
 set.  The values in the image are the number of iterations it takes for
 the magnitude of the value to get over 2.  The equation repeated is
 z = z^2 + C (z and C are complex).  Initial value of z is zero, and the 
 real value of C is mapped onto the x axis, and the imaginary value of C
 is mapped onto the Y Axis.  I was thinking of extending this source
 to generate Julia Sets (initial value of Z varies).  This would be 4
 possible parameters to vary, but there are no more 4d images :(
 The third dimension (z axis) is the imaginary value of the initial value.


"""
class vtkImageMapToColors:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMapToColors - map the input image through a lookup table

Super Class:

 vtkThreadedImageAlgorithm

 The vtkImageMapToColors filter will take an input image of any valid
 scalar type, and map the first component of the image through a
 lookup table.  The result is an image of type VTK_UNSIGNED_CHAR.
 If the lookup table is not set, or is set to NULL, then the input
 data will be passed through if it is already of type VTK_UNSIGNED_CHAR.

See Also:

 vtkLookupTable vtkScalarsToColors


"""
class vtkImageMapToRGBA:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMapToRGBA - map the input image through a lookup table

Super Class:

 vtkImageMapToColors

 This filter has been replaced by vtkImageMapToColors, which provided
 additional features.  Use vtkImageMapToColors instead.

See Also:

 vtkLookupTable


"""
class vtkImageMapToWindowLevelColors:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMapToWindowLevelColors - map the input image through a lookup table and window / level it

Super Class:

 vtkImageMapToColors

 The vtkImageMapToWindowLevelColors filter will take an input image of any
 valid scalar type, and map the first component of the image through a
 lookup table.  This resulting color will be modulated with value obtained
 by a window / level operation. The result is an image of type 
 VTK_UNSIGNED_CHAR. If the lookup table is not set, or is set to NULL, then 
 the input data will be passed through if it is already of type 
 UNSIGNED_CHAR.


See Also:

 vtkLookupTable vtkScalarsToColors


"""
class vtkImageMarchingCubes:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMarchingCubes - generate isosurface(s) from volume/images

Super Class:

 vtkPolyDataAlgorithm

 vtkImageMarchingCubes is a filter that takes as input images (e.g., 3D
 image region) and generates on output one or more isosurfaces.
 One or more contour values must be specified to generate the isosurfaces.
 Alternatively, you can specify a min/max scalar range and the number of
 contours to generate a series of evenly spaced contour values.
 This filter can stream, so that the entire volume need not be loaded at
 once.  Streaming is controlled using the instance variable
 InputMemoryLimit, which has units KBytes.

Caveats:

 This filter is specialized to volumes. If you are interested in 
 contouring other types of data, use the general vtkContourFilter. If you
 want to contour an image (i.e., a volume slice), use vtkMarchingSquares.

See Also:

 vtkContourFilter vtkSliceCubes vtkMarchingSquares vtkSynchronizedTemplates3D


"""
class vtkImageMask:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMask - Combines a mask and an image.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageMask combines a mask with an image.  Non zero mask
 implies the output pixel will be the same as the image.
 If a mask pixel is zero,  the the output pixel
 is set to "MaskedValue".  The filter also has the option to pass
 the mask through a boolean not operation before processing the image.
 This reverses the passed and replaced pixels.
 The two inputs should have the same "WholeExtent".
 The mask input should be unsigned char, and the image scalar type
 is the same as the output scalar type.


"""
class vtkImageMaskBits:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMaskBits - applies a bit-mask pattern to each component.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageMaskBits applies a bit-mask pattern to each component.  The
 bit-mask can be applied using a variety of boolean bitwise operators.


"""
class vtkImageMathematics:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMathematics - Add, subtract, multiply, divide, invert, sin,

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageMathematics implements basic mathematic operations SetOperation is
 used to select the filters behavior.  The filter can take two or one
 input.


"""
class vtkImageMedian3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMedian3D - Median Filter

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageMedian3D a Median filter that replaces each pixel with the 
 median value from a rectangular neighborhood around that pixel.
 Neighborhoods can be no more than 3 dimensional.  Setting one
 axis of the neighborhood kernelSize to 1 changes the filter
 into a 2D median.  


"""
class vtkImageMirrorPad:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageMirrorPad - Extra pixels are filled by mirror images.

Super Class:

 vtkImagePadFilter

 vtkImageMirrorPad makes an image larger by filling extra pixels with
 a mirror image of the original image (mirror at image boundaries).  


"""
class vtkImageNoiseSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageNoiseSource - Create an image filled with noise.

Super Class:

 vtkImageAlgorithm

 vtkImageNoiseSource just produces images filled with noise.  The only
 option now is uniform noise specified by a min and a max.  There is one
 major problem with this source. Every time it executes, it will output
 different pixel values.  This has important implications when a stream
 requests overlapping regions.  The same pixels will have different values
 on different updates.


"""
class vtkImageNonMaximumSuppression:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageNonMaximumSuppression - Performs non-maximum suppression

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageNonMaximumSuppression Sets to zero any pixel that is not a peak.
 If a pixel has a neighbor along the vector that has larger magnitude, the
 smaller pixel is set to zero.  The filter takes two inputs: a magnitude
 and a vector.  Output is magnitude information and is always in doubles.
 Typically this filter is used with vtkImageGradient and
 vtkImageGradientMagnitude as inputs.


"""
class vtkImageNormalize:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageNormalize - Normalizes that scalar components for each point.

Super Class:

 vtkThreadedImageAlgorithm

 For each point, vtkImageNormalize normalizes the vector defined by the 
 scalar components.  If the magnitude of this vector is zero, the output
 vector is zero also.


"""
class vtkImageOpenClose3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageOpenClose3D - Will perform opening or closing.

Super Class:

 vtkImageAlgorithm

 vtkImageOpenClose3D performs opening or closing by having two 
 vtkImageErodeDilates in series.  The size of operation
 is determined by the method SetKernelSize, and the operator is an ellipse.
 OpenValue and CloseValue determine how the filter behaves.  For binary
 images Opening and closing behaves as expected.
 Close value is first dilated, and then eroded.
 Open value is first eroded, and then dilated.
 Degenerate two dimensional opening/closing can be achieved by setting the
 one axis the 3D KernelSize to 1.
 Values other than open value and close value are not touched.
 This enables the filter to processes segmented images containing more than
 two tags.


"""
class vtkImagePadFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImagePadFilter - Super class for filters that fill in extra pixels.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImagePadFilter Changes the image extent of an image.  If the image
 extent is larger than the input image extent, the extra pixels are
 filled by an algorithm determined by the subclass.
 The image extent of the output has to be specified.


"""
class vtkImagePermute:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImagePermute -  Permutes axes of input.

Super Class:

 vtkImageReslice

 vtkImagePermute reorders the axes of the input. Filtered axes specify
 the input axes which become X, Y, Z.  The input has to have the
 same scalar type of the output. The filter does copy the 
 data when it executes. This filter is actually a very thin wrapper
 around vtkImageReslice.


"""
class vtkImageQuantizeRGBToIndex:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageQuantizeRGBToIndex - generalized histograms up to 4 dimensions

Super Class:

 vtkImageAlgorithm

 vtkImageQuantizeRGBToIndex takes a 3 component RGB image as
 input and produces a one component index image as output, along with
 a lookup table that contains the color definitions for the index values.
 This filter works on the entire input extent - it does not perform
 streaming, and it does not supported threaded execution (because it has
 to process the entire image).

 To use this filter, you typically set the number of colors 
 (between 2 and 65536), execute it, and then retrieve the lookup table.
 The colors can then be using the lookup table and the image index.


"""
class vtkImageRFFT:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageRFFT -  Reverse Fast Fourier Transform.

Super Class:

 vtkImageFourierFilter

 vtkImageRFFT implements the reverse fast Fourier transform.  The input
 can have real or complex data in any components and data types, but
 the output is always complex doubles with real values in component0, and
 imaginary values in component1.  The filter is fastest for images that
 have power of two sizes.  The filter uses a butterfly fitlers for each
 prime factor of the dimension.  This makes images with prime number dimensions 
 (i.e. 17x17) much slower to compute.  Multi dimensional (i.e volumes) 
 FFT's are decomposed so that each axis executes in series.
 In most cases the RFFT will produce an image whose imaginary values are all
 zero's. In this case vtkImageExtractComponents can be used to remove
 this imaginary components leaving only the real image.

See Also:

 vtkImageExtractComponenents


"""
class vtkImageRGBToHSI:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageRGBToHSI - Converts RGB components to HSI.

Super Class:

 vtkThreadedImageAlgorithm

 For each pixel with red, blue, and green components this
 filter output the color coded as hue, saturation and intensity.
 Output type must be the same as input type.


"""
class vtkImageRGBToHSV:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageRGBToHSV - Converts RGB components to HSV.

Super Class:

 vtkThreadedImageAlgorithm

 For each pixel with red, blue, and green components this
 filter output the color coded as hue, saturation and value.
 Output type must be the same as input type.


"""
class vtkImageRange3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageRange3D - Max - min of a circular neighborhood.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageRange3D replaces a pixel with the maximum minus minimum over
 an ellipsoidal neighborhood.  If KernelSize of an axis is 1, no processing
 is done on that axis.


"""
class vtkImageReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkImageReader - Superclass of transformable binary file readers.

Super Class:

 vtkImageReader2

 vtkImageReader provides methods needed to read a region from a file.
 It supports both transforms and masks on the input data, but as a result
 is more complicated and slower than its parent class vtkImageReader2.

See Also:

 vtkBMPReader vtkPNMReader vtkTIFFReader


"""
class vtkImageReader2:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageReader2 - Superclass of binary file readers.

Super Class:

 vtkImageAlgorithm

 vtkImageReader2 is the parent class for vtkImageReader.  It 
 is a good super class for streaming readers that do not require
 a mask or transform on the data.  vtkImageReader was implemented
 before vtkImageReader2, vtkImageReader2 is intended to have 
 a simpler interface.

See Also:

 vtkJPEGReader vtkPNGReader vtkImageReader vtkGESignaReader


"""
class vtkImageRectilinearWipe:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageRectilinearWipe - make a rectilinear combination of two images.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageRectilinearWipe makes a rectilinear combination of two
 images. The two input images must correspond in size, scalar type and
 number of components.
 The resulting image has four possible configurations
 called:
   Quad - alternate input 0 and input 1 horizontally and
     vertically. Select this with SetWipeModeToQuad. The Position
     specifies the location of the quad intersection.
   Corner - 3 of one input and 1 of the other. Select the location of
     input 0 with with SetWipeModeToLowerLeft, SetWipeModeToLowerRight,
     SetWipeModeToUpperLeft and SetWipeModeToUpperRight. The Position
     selects the location of the corner.
   Horizontal - alternate input 0 and input 1 with a vertical
     split. Select this with SetWipeModeToHorizontal. Position[0]
     specifies the location of the vertical transition between input 0
     and input 1.
   Vertical - alternate input 0 and input 1 with a horizontal
     split. Only the y The intersection point of the rectilinear points
     is controlled with the Point ivar.

See Also:

 vtkImageCheckerboard


"""
class vtkImageResample:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageResample - Resamples an image to be larger or smaller.

Super Class:

 vtkImageReslice

 This filter produces an output with different spacing (and extent)
 than the input.  Linear interpolation can be used to resample the data.
 The Output spacing can be set explicitly or relative to input spacing
 with the SetAxisMagnificationFactor method.


"""
class vtkImageReslice:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageReslice - Reslices a volume along a new set of axes.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageReslice is the swiss-army-knife of image geometry filters:  
 It can permute, rotate, flip, scale, resample, deform, and pad image
 data in any combination with reasonably high efficiency.  Simple
 operations such as permutation, resampling and padding are done
 with similar efficiently to the specialized vtkImagePermute,
 vtkImageResample, and vtkImagePad filters.  There are a number of
 tasks that vtkImageReslice is well suited for:
 <p>1) Application of simple rotations, scales, and translations to
 an image. It is often a good idea to use vtkImageChangeInformation
 to center the image first, so that scales and rotations occur around
 the center rather than around the lower-left corner of the image.
 <p>2) Resampling of one data set to match the voxel sampling of 
 a second data set via the SetInformationInput() method, e.g. for
 the purpose of comparing two images or combining two images.
 A transformation, either linear or nonlinear, can be applied 
 at the same time via the SetResliceTransform method if the two
 images are not in the same coordinate space.
 <p>3) Extraction of slices from an image volume.  The most convenient
 way to do this is to use SetResliceAxesDirectionCosines() to
 specify the orientation of the slice.  The direction cosines give
 the x, y, and z axes for the output volume.  The method 
 SetOutputDimensionality(2) is used to specify that want to output a
 slice rather than a volume.  The SetResliceAxesOrigin() command is
 used to provide an (x,y,z) point that the slice will pass through.
 You can use both the ResliceAxes and the ResliceTransform at the
 same time, in order to extract slices from a volume that you have
 applied a transformation to.

Caveats:

 This filter is very inefficient if the output X dimension is 1.

See Also:

 vtkAbstractTransform vtkMatrix4x4


"""
class vtkImageSeedConnectivity:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSeedConnectivity - SeedConnectivity with user defined seeds.

Super Class:

 vtkImageAlgorithm

 vtkImageSeedConnectivity marks pixels connected to user supplied seeds.
 The input must be unsigned char, and the output is also unsigned char.  If
 a seed supplied by the user does not have pixel value "InputTrueValue",
 then the image is scanned +x, +y, +z until a pixel is encountered with
 value "InputTrueValue".  This new pixel is used as the seed .  Any pixel
 with out value "InputTrueValue" is consider off.  The output pixels values
 are 0 for any off pixel in input, "OutputTrueValue" for any pixels
 connected to seeds, and "OutputUnconnectedValue" for any on pixels not
 connected to seeds.  The same seeds are used for all images in the image
 set.


"""
class vtkImageSeparableConvolution:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSeparableConvolution -  3 1D convolutions on an image

Super Class:

 vtkImageDecomposeFilter

 vtkImageSeparableConvolution performs a convolution along the X, Y,
 and Z axes of an image, based on the three different 1D convolution
 kernels.  The kernels must be of odd size, and are considered to be
 centered at (int)((kernelsize - 1) / 2.0 ).  If a kernel is NULL,
 that dimension is skipped.  This filter is designed to efficiently
 convolve separable filters that can be decomposed into 1 or more 1D
 convolutions.  It also handles arbitrarly large kernel sizes, and
 uses edge replication to handle boundaries.


"""
class vtkImageShiftScale:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageShiftScale - shift and scale an input image

Super Class:

 vtkThreadedImageAlgorithm

 With vtkImageShiftScale Pixels are shifted and then scaled. As
 a convenience, this class allows you to set the output scalar type
 similar to vtkImageCast. This is because shift scale operations
 frequently convert data types.


"""
class vtkImageShrink3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageShrink3D - Subsamples an image.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageShrink3D shrinks an image by sub sampling on a 
 uniform grid (integer multiples).  


"""
class vtkImageSinusoidSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSinusoidSource - Create an image with sinusoidal pixel values.

Super Class:

 vtkImageAlgorithm

 vtkImageSinusoidSource just produces images with pixel values determined 
 by a sinusoid.


"""
class vtkImageSkeleton2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSkeleton2D - Skeleton of 2D images.

Super Class:

 vtkImageIterateFilter

 vtkImageSkeleton2D should leave only single pixel width lines
 of non-zero-valued pixels (values of 1 are not allowed).  
 It works by erosion on a 3x3 neighborhood with special rules.
 The number of iterations determines how far the filter can erode.
 There are three pruning levels:  
  prune == 0 will leave traces on all angles...
  prune == 1 will not leave traces on 135 degree angles, but will on 90.
  prune == 2 does not leave traces on any angles leaving only closed loops.
 Prune defaults to zero. The output scalar type is the same as the input.


"""
class vtkImageSobel2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSobel2D - Computes a vector field using sobel functions.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageSobel2D computes a vector field from a scalar field by using
 Sobel functions.  The number of vector components is 2 because
 the input is an image.  Output is always doubles.


"""
class vtkImageSobel3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSobel3D - Computes a vector field using sobel functions.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageSobel3D computes a vector field from a scalar field by using
 Sobel functions.  The number of vector components is 3 because
 the input is a volume.  Output is always doubles.  A little creative 
 liberty was used to extend the 2D sobel kernels into 3D.


"""
class vtkImageSpatialAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSpatialAlgorithm - Filters that operate on pixel neighborhoods.

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageSpatialAlgorithm is a super class for filters that operate on an
 input neighborhood for each output pixel. It handles even sized
 neighborhoods, but their can be a half pixel shift associated with
 processing.  This superclass has some logic for handling boundaries.  It
 can split regions into boundary and non-boundary pieces and call different
 execute methods.


"""
class vtkImageSpatialFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageSpatialFilter - Filters that operate on pixel neighborhoods.

Super Class:

 vtkImageToImageFilter

 vtkImageSpatialFilter is a super class for filters that operate on an
 input neighborhood for each output pixel. It handles even sized
 neighborhoods, but their can be a half pixel shift associated with
 processing.  This superclass has some logic for handling boundaries.  It
 can split regions into boundary and non-boundary pieces and call different
 execute methods.
 .SECTION Warning
 This used to be the parent class for most imaging filter in VTK4.x, now 
 this role has been replaced by vtkImageSpatialAlgorithm. You should consider
 using vtkImageSpatialAlgorithm instead, when writing filter for VTK5 and above.
 This class was kept to ensure full backward compatibility.
 .SECTION See also
 vtkSimpleImageToImageFilter vtkImageToImageFilter vtkImageSpatialAlgorithm 


"""
class vtkImageStencil:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageStencil - combine images via a cookie-cutter operation

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageStencil will combine two images together using a stencil.
 The stencil should be provided in the form of a vtkImageStencilData,


"""
class vtkImageThreshold:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageThreshold -  Flexible threshold

Super Class:

 vtkThreadedImageAlgorithm

 vtkImageThreshold can do binary or continuous thresholding for lower, upper
 or a range of data.  The output data type may be different than the
 output, but defaults to the same type.


"""
class vtkImageToImageStencil:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageToImageStencil - clip an image with a mask image

Super Class:

 vtkImageStencilSource

 vtkImageToImageStencil will convert a vtkImageData into an stencil
 that can be used with vtkImageStecil or other vtk classes that apply
 a stencil to an image.

See Also:

 vtkImageStencil vtkImplicitFunctionToImageStencil vtkPolyDataToImageStencil


"""
class vtkImageToPolyDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageToPolyDataFilter - generate linear primitives (vtkPolyData) from an image

Super Class:

 vtkPolyDataAlgorithm

 vtkImageToPolyDataFilter converts raster data (i.e., an image) into
 polygonal data (i.e., quads or n-sided polygons), with each polygon
 assigned a constant color. This is useful for writers that generate vector
 formats (i.e., CGM or PostScript). To use this filter, you specify how to
 quantize the color (or whether to use an image with a lookup table), and
 what style the output should be. The output is always polygons, but the
 choice is n x m quads (where n and m define the input image dimensions)
 "Pixelize" option; arbitrary polygons "Polygonalize" option; or variable
 number of quads of constant color generated along scan lines "RunLength"
 option.

 The algorithm quantizes color in order to create coherent regions that the
 polygons can represent with good compression. By default, the input image
 is quantized to 256 colors using a 3-3-2 bits for red-green-blue. However,
 you can also supply a single component image and a lookup table, with the
 single component assumed to be an index into the table.  (Note: a quantized
 image can be generated with the filter vtkImageQuantizeRGBToIndex.) The
 number of colors on output is equal to the number of colors in the input
 lookup table (or 256 if the built in linear ramp is used).

 The output of the filter is polygons with a single color per polygon cell.
 If the output style is set to "Polygonalize", the polygons may have an
 large number of points (bounded by something like 2*(n+m)); and the
 polygon may not be convex which may cause rendering problems on some
 systems (use vtkTriangleFilter). Otherwise, each polygon will have four
 vertices. The output also contains scalar data defining RGB color in
 unsigned char form.


Caveats:

 The input linear lookup table must
 be of the form of 3-component unsigned char.

 This filter defines constant cell colors. If you have a plotting
 device that supports Gouraud shading (linear interpolation of color), then 
 superior algorithms are available for generating polygons from images.

 Note that many plotting devices/formats support only a limited number of
 colors.
 

See Also:

 vtkCGMWriter vtkImageQuantizeRGBToIndex vtkTriangleFilter


"""
class vtkImageToStructuredPoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageToStructuredPoints - Attaches image pipeline to VTK. 

Super Class:

 vtkImageAlgorithm

 vtkImageToStructuredPoints changes an image cache format to
 a structured points dataset.  It takes an Input plus an optional
 VectorInput. The VectorInput converts the RGB scalar components
 of the VectorInput to vector pointdata attributes. This filter
 will try to reference count the data but in some cases it must
 make a copy.


"""
class vtkImageTranslateExtent:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageTranslateExtent - Changes extent, nothing else.

Super Class:

 vtkImageAlgorithm

 vtkImageTranslateExtent  shift the whole extent, but does not
 change the data.


"""
class vtkImageVariance3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageVariance3D - Variance in a neighborhood.

Super Class:

 vtkImageSpatialAlgorithm

 vtkImageVariance3D replaces each pixel with a measurement of 
 pixel variance in a elliptical neighborhood centered on that pixel.
 The value computed is not exactly the variance.
 The difference between the neighbor values and center value is computed
 and squared for each neighbor.  These values are summed and divided by
 the total number of neighbors to produce the output value.


"""
class vtkImageWeightedSum:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageWeightedSum -  adds any number of images, weighting

Super Class:

 vtkThreadedImageAlgorithm

 All weights are normalized so they will sum to 1.
 Images must have the same extents. Output is 

 .SECTION Thanks
 The original author of this class is Lauren O'Donnell (MIT) for Slicer


"""
class vtkImageWrapPad:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImageWrapPad - Makes an image larger by wrapping existing data.

Super Class:

 vtkImagePadFilter

 vtkImageWrapPad performs a modulo operation on the output pixel index
 to determine the source input index.  The new image extent of the
 output has to be specified.  Input has to be the same scalar type as 
 output.


"""
class vtkImageWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkImageWriter - Writes images to files.

Super Class:

 vtkImageAlgorithm

 vtkImageWriter writes images to files with any data type. The data type of
 the file is the same scalar type as the input.  The dimensionality
 determines whether the data will be written in one or multiple files.
 This class is used as the superclass of most image writing classes 
 such as vtkBMPWriter etc. It supports streaming.


"""
class vtkImplicitFunctionToImageStencil:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImplicitFunctionToImageStencil - clip an image with a function

Super Class:

 vtkImageStencilSource

 vtkImplicitFunctionToImageStencil will convert a vtkImplicitFunction into
 a stencil that can be used with vtkImageStencil or with other classes
 that apply a stencil to an image.

See Also:

 vtkImplicitFunction vtkImageStencil vtkPolyDataToImageStencil


"""
class vtkImplicitModeller:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImplicitModeller - compute distance from input geometry on structured point dataset

Super Class:

 vtkImageAlgorithm

 vtkImplicitModeller is a filter that computes the distance from the input
 geometry to the points of an output structured point set. This distance
 function can then be "contoured" to generate new, offset surfaces from
 the original geometry. An important feature of this object is
 "capping". If capping is turned on, after the implicit model is created,
 the values on the boundary of the structured points dataset are set to
 the cap value. This is used to force closure of the resulting contoured
 surface. Note, however, that large cap values can generate weird surface
 normals in those cells adjacent to the boundary of the dataset. Using
 smaller cap value will reduce this effect.
<P>
 Another important ivar is MaximumDistance. This controls how far into the
 volume the distance function is computed from the input geometry.  Small
 values give significant increases in performance. However, there can
 strange sampling effects at the extreme range of the MaximumDistance.
<P>
 In order to properly execute and sample the input data, a rectangular
 region in space must be defined (this is the ivar ModelBounds).  If not
 explicitly defined, the model bounds will be computed. Note that to avoid
 boundary effects, it is possible to adjust the model bounds (i.e., using
 the AdjustBounds and AdjustDistance ivars) to strictly contain the
 sampled data.
<P>
 This filter has one other unusual capability: it is possible to append
 data in a sequence of operations to generate a single output. This is
 useful when you have multiple datasets and want to create a
 conglomeration of all the data.  However, the user must be careful to
 either specify the ModelBounds or specify the first item such that its
 bounds completely contain all other items.  This is because the 
 rectangular region of the output can not be changed after the 1st Append.
<P>
 The ProcessMode ivar controls the method used within the Append function
 (where the actual work is done regardless if the Append function is
 explicitly called) to compute the implicit model.  If set to work in voxel
 mode, each voxel is visited once.  If set to cell mode, each cell is visited
 once.  Tests have shown once per voxel to be faster when there are a 
 lot of cells (at least a thousand?); relative performance improvement 
 increases with addition cells. Primitives should not be stripped for best
 performance of the voxel mode.  Also, if explicitly using the Append feature
 many times, the cell mode will probably be better because each voxel will be
 visited each Append.  Append the data before input if possible when using
 the voxel mode.  Do not switch between voxel and cell mode between execution
 of StartAppend and EndAppend.
<P>
 Further performance improvement is now possible using the PerVoxel process
 mode on multi-processor machines (the mode is now multithreaded).  Each
 thread processes a different "slab" of the output.  Also, if the input is 
 vtkPolyData, it is appropriately clipped for each thread; that is, each 
 thread only considers the input which could affect its slab of the output.
<P>
 This filter can now produce output of any type supported by vtkImageData.  
 However to support this change, additional sqrts must be executed during the
 Append step.  Previously, the output was initialized to the squared CapValue 
 in StartAppend, the output was updated with squared distance values during 
 the Append, and then the sqrt of the distances was computed in EndAppend.  
 To support different scalar types in the output (largely to reduce memory 
 requirements as an vtkImageShiftScale and/or vtkImageCast could have 
 achieved the same result), we can't "afford" to save squared value in the
 output, because then we could only represent up to the sqrt of the scalar
 max for an integer type in the output; 1 (instead of 255) for an unsigned
 char; 11 for a char (instead of 127).  Thus this change may result in a
 minor performance degradation.  Non-float output types can be scaled to the
 CapValue by turning ScaleToMaximumDistance On.


See Also:

 vtkSampleFunction vtkContourFilter


"""
class vtkImplicitTextureCoords:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkImplicitTextureCoords - generate 1D, 2D, or 3D texture coordinates based on implicit function(s)

Super Class:

 vtkDataSetAlgorithm

 vtkImplicitTextureCoords is a filter to generate 1D, 2D, or 3D texture 
 coordinates from one, two, or three implicit functions, respectively. 
 In combinations with a vtkBooleanTexture map (or another texture map of
 your own creation), the texture coordinates can be used to highlight
(via color or intensity) or cut (via transparency) dataset geometry without
 any complex geometric processing. (Note: the texture coordinates are 
 referred to as r-s-t coordinates.)

 The texture coordinates are automatically normalized to lie between (0,1). 
 Thus, no matter what the implicit functions evaluate to, the resulting 
 texture coordinates lie between (0,1), with the zero implicit function 
 value mapped to the 0.5 texture coordinates value. Depending upon the 
 maximum negative/positive implicit function values, the full (0,1) range 
 may not be occupied (i.e., the positive/negative ranges are mapped using 
 the same scale factor).

 A boolean variable InvertTexture is available to flip the texture 
 coordinates around 0.5 (value 1.0 becomes 0.0, 0.25->0.75). This is 
 equivalent to flipping the texture map (but a whole lot easier).

Caveats:

 You can use the transformation capabilities of vtkImplicitFunction to
 orient, translate, and scale the implicit functions. Also, the dimension of 
 the texture coordinates is implicitly defined by the number of implicit 
 functions defined.

See Also:

 vtkImplicitFunction vtkTexture vtkBooleanTexture vtkTransformTexture


"""
class vtkInterpolateDataSetAttributes:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkInterpolateDataSetAttributes - interpolate scalars, vectors, etc. and other dataset attributes

Super Class:

 vtkDataSetAlgorithm

 vtkInterpolateDataSetAttributes is a filter that interpolates data set
 attribute values between input data sets. The input to the filter
 must be datasets of the same type, same number of cells, and same 
 number of points. The output of the filter is a data set of the same
 type as the input dataset and whose attribute values have been 
 interpolated at the parametric value specified.

 The filter is used by specifying two or more input data sets (total of N),
 and a parametric value t (0 <= t <= N-1). The output will contain
 interpolated data set attributes common to all input data sets. (For
 example, if one input has scalars and vectors, and another has just
 scalars, then only scalars will be interpolated and output.)


"""
class vtkJPEGReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkJPEGReader - read JPEG files

Super Class:

 vtkImageReader2

 vtkJPEGReader is a source object that reads JPEG files.
 It should be able to read most any JPEG file


See Also:

 vtkJPEGWriter


"""
class vtkJPEGWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkJPEGWriter - Writes JPEG files.

Super Class:

 vtkImageWriter

 vtkJPEGWriter writes JPEG files. It supports 1 and 3 component data of
 unsigned char. It relies on the IJG's libjpeg.  Thanks to IJG for
 supplying a public jpeg IO library.

See Also:

 vtkJPEGReader


"""
class vtkKdTreeSelector:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkKdTreeSelector - Selects point ids using a kd-tree.

Super Class:

 vtkSelectionAlgorithm

 If SetKdTree is used, the filter ignores the input and selects based on that
 kd-tree.  If SetKdTree is not used, the filter builds a kd-tree using the
 input point set and uses that tree for selection.  The output is a
 vtkSelection containing the ids found in the kd-tree using the specified
 bounds.


"""
class vtkLSDynaReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkLSDynaReader - Read LS-Dyna databases (d3plot)

Super Class:

 vtkMultiBlockDataSetAlgorithm

 This filter reads LS-Dyna databases.

 The Set/GetFileName() routines are actually wrappers around the
 Set/GetDatabaseDirectory() members; the actual filename you choose is
 irrelevant -- only the directory name is used.  This is done in order to
 accommodate ParaView.

 Note that this reader produces 7 output meshes.
 These meshes are required as several attributes are defined on subsets
 of the mesh.  Below is a list of meshes in the order they are output and
 an explanation of which attributes are unique to each mesh:
 - solid (3D) elements: number of integration points are different than 2D
 - thick shell elements: number of integration points are different than 
 planar 2D
 - shell (2D) elements: number of integration points are different than 3D
 - rigid surfaces: can't have deflection, only velocity, accel, etc.
 - road surfaces: have only a "segment ID" (serves as material ID) and a 
 velocity.
 - beam elements: have Frenet (TNB) frame and cross-section attributes 
 (shape and size)
 - spherical particle hydrodynamics (SPH) elements: have a radius of 
 influence, internal energy, etc.
 Because each mesh has its own cell attributes, the vtkLSDynaReader has a
 rather large API.  Instead of a single set of routines to query and set
 cell array names and status, one exists for each possible output mesh.
 Also, GetNumberOfCells() will return the sum of all the cells in all 7
 meshes.  If you want the number of cells in a specific mesh, there are
 separate routines for each mesh type.

 .SECTION "Developer Notes"


"""
class vtkLineSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkLineSource - create a line defined by two end points

Super Class:

 vtkPolyDataAlgorithm

 vtkLineSource is a source object that creates a polyline defined by
 two endpoints. The number of segments composing the polyline is
 controlled by setting the object resolution.


"""
class vtkLinearExtrusionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkLinearExtrusionFilter - sweep polygonal data creating a "skirt" from free edges and lines, and lines from vertices

Super Class:

 vtkPolyDataAlgorithm

 vtkLinearExtrusionFilter is a modeling filter. It takes polygonal data as 
 input and generates polygonal data on output. The input dataset is swept
 according to some extrusion function and creates new polygonal primitives.
 These primitives form a "skirt" or swept surface. For example, sweeping a
 line results in a quadrilateral, and sweeping a triangle creates a "wedge".

 There are a number of control parameters for this filter. You can 
 control whether the sweep of a 2D object (i.e., polygon or triangle strip) 
 is capped with the generating geometry via the "Capping" ivar. Also, you
 can extrude in the direction of a user specified vector, towards a point,
 or in the direction of vertex normals (normals must be provided - use 
 vtkPolyDataNormals if necessary). The amount of extrusion is controlled by
 the "ScaleFactor" instance variable.

 The skirt is generated by locating certain topological features. Free 
 edges (edges of polygons or triangle strips only used by one polygon or
 triangle strips) generate surfaces. This is true also of lines or 
 polylines. Vertices generate lines.

 This filter can be used to create 3D fonts, 3D irregular bar charts,
 or to model 2 1/2D objects like punched plates. It also can be used to 
 create solid objects from 2D polygonal meshes.

Caveats:

 Some polygonal objects have no free edges (e.g., sphere). When swept,
 this will result in two separate surfaces if capping is on, or no surface
 if capping is off.

See Also:

 vtkRotationalExtrusionFilter


"""
class vtkLinearSubdivisionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkLinearSubdivisionFilter - generate a subdivision surface using the Linear Scheme

Super Class:

 vtkInterpolatingSubdivisionFilter

 vtkLinearSubdivisionFilter is a filter that generates output by
 subdividing its input polydata. Each subdivision iteration create 4
 new triangles for each triangle in the polydata.

See Also:

 vtkInterpolatingSubdivisionFilter vtkButterflySubdivisionFilter


"""
class vtkLinkEdgels:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkLinkEdgels - links edgels together to form digital curves.

Super Class:

 vtkPolyDataAlgorithm

 vtkLinkEdgels links edgels into digital curves which are then stored 
 as polylines. The algorithm works one pixel at a time only looking at
 its immediate neighbors. There is a GradientThreshold that can be set 
 that eliminates any pixels with a smaller gradient value. This can
 be used as the lower threshold of a two value edgel thresholding. 

 For the remaining edgels, links are first tried for the four
 connected neighbors.  A successful neighbor will satisfy three
 tests. First both edgels must be above the gradient
 threshold. Second, the difference between the orientation between
 the two edgels (Alpha) and each edgels orientation (Phi) must be
 less than LinkThreshold. Third, the difference between the two
 edgels Phi values must be less than PhiThreshold.
 The most successful link is selected. The measure is simply the 
 sum of the three angle differences (actually stored as the sum of
 the cosines). If none of the four connect neighbors succeeds, then
 the eight connect neighbors are examined using the same method.
  
 This filter requires gradient information so you will need to use
 a vtkImageGradient at some point prior to this filter.  Typically
 a vtkNonMaximumSuppression filter is also used. vtkThresholdEdgels
 can be used to complete the two value edgel thresholding as used
 in a Canny edge detector. The vtkSubpixelPositionEdgels filter 
 can also be used after this filter to adjust the edgel locations.

See Also:

 vtkImageData vtkImageGradient vtkImageNonMaximumSuppression


"""
class vtkLoopSubdivisionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkLoopSubdivisionFilter - generate a subdivision surface using the Loop Scheme

Super Class:

 vtkApproximatingSubdivisionFilter

 vtkLoopSubdivisionFilter is an approximating subdivision scheme that
 creates four new triangles for each triangle in the mesh. The user can
 specify the NumberOfSubdivisions. Loop's subdivision scheme is
 described in: Loop, C., "Smooth Subdivision surfaces based on
 triangles,", Masters Thesis, University of Utah, August 1987.
 For a nice summary of the technique see, Hoppe, H., et. al,
 "Piecewise Smooth Surface Reconstruction,:, Proceedings of Siggraph 94
 (Orlando, Florida, July 24-29, 1994). In COmputer Graphics
 Proceedings, Annual COnference Series, 1994, ACM SIGGRAPH,
 pp. 295-302.
 <P>
 The filter only operates on triangles. Users should use the
 vtkTriangleFilter to triangulate meshes that contain polygons or
 triangle strips.
 <P>
 The filter approximates point data using the same scheme. New
 triangles create at a subdivision step will have the cell data of
 their parent cell.

See Also:

 vtkApproximatingSubdivisionFilter


"""
class vtkMCubesReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkMCubesReader - read binary marching cubes file

Super Class:

 vtkPolyDataAlgorithm

 vtkMCubesReader is a source object that reads binary marching cubes
 files. (Marching cubes is an isosurfacing technique that generates 
 many triangles.) The binary format is supported by W. Lorensen's
 marching cubes program (and the vtkSliceCubes object). The format 
 repeats point coordinates, so this object will merge the points 
 with a vtkLocator object. You can choose to supply the vtkLocator 
 or use the default.

Caveats:

 Binary files assumed written in sun/hp/sgi (i.e., Big Endian) form.

 Because points are merged when read, degenerate triangles may be removed.
 Thus the number of triangles read may be fewer than the number of triangles
 actually created.

 The point merging does not take into account that the same point may have
 different normals. For example, running vtkPolyDataNormals after
 vtkContourFilter may split triangles because of the FeatureAngle
 ivar. Subsequent rea ...
 [Truncated]

See Also:

 vtkContourFilter vtkMarchingCubes vtkSliceCubes vtkLocator


"""
class vtkMCubesWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkMCubesWriter - write binary marching cubes file

Super Class:

 vtkPolyDataWriter

 vtkMCubesWriter is a polydata writer that writes binary marching cubes
 files. (Marching cubes is an isosurfacing technique that generates many
 triangles.) The binary format is supported by W. Lorensen's marching cubes
 program (and the vtkSliceCubes object). Each triangle is represented by
 three records, with each record consisting of six single precision
 floating point numbers representing the a triangle vertex coordinate and
 vertex normal.

Caveats:

 Binary files are written in sun/hp/sgi (i.e., Big Endian) form.

See Also:

 vtkMarchingCubes vtkSliceCubes vtkMCubesReader


"""
class vtkMFIXReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkMFIXReader - reads a dataset in MFIX file format

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkMFIXReader creates an unstructured grid dataset. It reads a restart
 file and a set of sp files.  The restart file contains the mesh 
 information.  MFIX meshes are either cylindrical or rectilinear, but 
 this reader will convert them to an unstructured grid.  The sp files 
 contain transient data for the cells.  Each sp file has one or more 
 variables stored inside it.  

See Also:

 vtkGAMBITReader


"""
class vtkMINCImageReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkMINCImageReader - A reader for MINC files.

Super Class:

 vtkImageReader2

 MINC is a NetCDF-based medical image file format that was developed
 at the Montreal Neurological Institute in 1992. 
 This class will read a MINC file into VTK, rearranging the data to
 match the VTK x, y, and z dimensions, and optionally rescaling
 real-valued data to VTK_FLOAT if RescaleRealValuesOn() is set.
 If RescaleRealValues is off, then the data will be stored in its
 original data type and the GetRescaleSlope(), GetRescaleIntercept()
 method can be used to retrieve global rescaling parameters.
 If the original file had a time dimension, the SetTimeStep() method
 can be used to specify a time step to read.
 All of the original header information can be accessed though the
 GetImageAttributes() method.

See Also:

 vtkMINCImageWriter vtkMINCImageAttributes
 .SECTION Thanks
 Thanks to David Gobbi for writing this class and Atamai Inc. for
 contributing it to VTK.


"""
class vtkMINCImageWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkMINCImageWriter - A writer for MINC files.

Super Class:

 vtkImageWriter

 MINC is a NetCDF-based medical image file format that was developed
 at the Montreal Neurological Institute in 1992. 
 The data is written slice-by-slice, and this writer is therefore
 suitable for streaming MINC data that is larger than the memory
 size through VTK.  This writer can also produce files with up to
 4 dimensions, where the fourth dimension is provided by using
 AddInput() to specify multiple input data sets.  If you want to
 set header information for the file, you must supply a
 vtkMINCImageAttributes 

See Also:

 vtkMINCImageReader vtkMINCImageAttributes
 .SECTION Thanks
 Thanks to David Gobbi for writing this class and Atamai Inc. for
 contributing it to VTK.


"""
class vtkMarchingContourFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMarchingContourFilter - generate isosurfaces/isolines from scalar values

Super Class:

 vtkPolyDataAlgorithm

 vtkMarchingContourFilter is a filter that takes as input any dataset and 
 generates on output isosurfaces and/or isolines. The exact form 
 of the output depends upon the dimensionality of the input data. 
 Data consisting of 3D cells will generate isosurfaces, data 
 consisting of 2D cells will generate isolines, and data with 1D 
 or 0D cells will generate isopoints. Combinations of output type 
 are possible if the input dimension is mixed.

 This filter will identify special dataset types (e.g., structured
 points) and use the appropriate specialized filter to process the
 data. For examples, if the input dataset type is a volume, this
 filter will create an internal vtkMarchingCubes instance and use
 it. This gives much better performance.
 
 To use this filter you must specify one or more contour values.
 You can either use the method SetValue() to specify each contour
 value, or use GenerateValues() to generate a series of evenly
 spaced contours. It is also possible to accelerate the operation of
 this filter (at the cost of extra memory) by using a
 vtkScalarTree. A scalar tree is used to quickly locate cells that
 contain a contour surface. This is especially effective if multiple
 contours are being extracted. If you want to use a scalar tree,
 invoke the method UseScalarTreeOn().

Caveats:

 For unstructured data or structured grids, normals and gradients
 are not computed.  This calculation will be implemented in the
 future. In the mean time, use vtkPolyDataNormals to compute the surface
 normals.

See Also:

 vtkMarchingCubes vtkSliceCubes vtkDividingCubes vtkMarchingSquares
 vtkImageMarchingCubes


"""
class vtkMarchingCubes:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMarchingCubes - generate isosurface(s) from volume

Super Class:

 vtkPolyDataAlgorithm

 vtkMarchingCubes is a filter that takes as input a volume (e.g., 3D
 structured point set) and generates on output one or more isosurfaces.
 One or more contour values must be specified to generate the isosurfaces.
 Alternatively, you can specify a min/max scalar range and the number of
 contours to generate a series of evenly spaced contour values.

Caveats:

 This filter is specialized to volumes. If you are interested in 
 contouring other types of data, use the general vtkContourFilter. If you
 want to contour an image (i.e., a volume slice), use vtkMarchingSquares.

See Also:

 vtkContourFilter vtkSliceCubes vtkMarchingSquares vtkDividingCubes


"""
class vtkMarchingSquares:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMarchingSquares - generate isoline(s) from structured points set

Super Class:

 vtkPolyDataAlgorithm

 vtkMarchingSquares is a filter that takes as input a structured points set
 and generates on output one or more isolines.  One or more contour values 
 must be specified to generate the isolines.  Alternatively, you can specify 
 a min/max scalar range and the number of contours to generate a series of 
 evenly spaced contour values. 

 To generate contour lines the input data must be of topological dimension 2 
 (i.e., an image). If not, you can use the ImageRange ivar to select an
 image plane from an input volume. This avoids having to extract a plane first
 (using vtkExtractSubVolume).  The filter deals with this by first
 trying to use the input data directly, and if not a 2D image, then uses the 
 ImageRange ivar to reduce it to an image.

Caveats:

 This filter is specialized to images. If you are interested in 
 contouring other types of data, use the general vtkContourFilter.

See Also:

 vtkContourFilter vtkMarchingCubes vtkSliceCubes vtkDividingCubes


"""
class vtkMaskPoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMaskPoints - selectively filter points

Super Class:

 vtkPolyDataAlgorithm

 vtkMaskPoints is a filter that passes through points and point attributes 
 from input dataset. (Other geometry is not passed through.) It is 
 possible to mask every nth point, and to specify an initial offset
 to begin masking from. A special random mode feature enables random 
 selection of points. The filter can also generate vertices (topological
 primitives) as well as points. This is useful because vertices are
 rendered while points are not.


"""
class vtkMaskPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMaskPolyData - sample subset of input polygonal data cells

Super Class:

 vtkPolyDataAlgorithm

 vtkMaskPolyData is a filter that sub-samples the cells of input polygonal
 data. The user specifies every nth item, with an initial offset to begin
 sampling. 

See Also:

 vtkMaskPoints


"""
class vtkMassProperties:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMassProperties - estimate volume, area, shape index of triangle mesh

Super Class:

 vtkPolyDataAlgorithm

 vtkMassProperties estimates the volume, the surface area, and the
 normalized shape index of a triangle mesh.  The algorithm
 implemented here is based on the discrete form of the divergence
 theorem.  The general assumption here is that the model is of
 closed surface.  For more details see the following reference
 (Alyassin A.M. et al, "Evaluation of new algorithms for the
 interactive measurement of surface area and volume", Med Phys 21(6)
 1994.).

Caveats:

 Currently only triangles are processed. Use vtkTriangleFilter to
 convert any strips or polygons to triangles.

See Also:

 vtkTriangleFilter


"""
class vtkMedicalImageReader2:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMedicalImageReader2 - vtkImageReader2 with medical meta data.

Super Class:

 vtkImageReader2

 vtkMedicalImageReader2 is a parent class for medical image readers.
 It provides a place to store patient information that may be stored
 in the image header.

See Also:

 vtkImageReader2 vtkGESignaReader vtkMedicalImageProperties


"""
class vtkMergeColumns:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMergeColumns - merge two columns into a single column

Super Class:

 vtkTableAlgorithm

 vtkMergeColumns replaces two columns in a table with a single column
 containing data in both columns.  The columns are set using

   SetInputArrayToProcess(0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_NONE, "col1")

 and

   SetInputArrayToProcess(1, 0, 0, vtkDataObject::FIELD_ASSOCIATION_NONE, "col2")

 where "col1" and "col2" are the names of the columns to merge.
 The user may also specify the name of the merged column.
 The arrays must be of the same type.
 If the arrays are numeric, the values are summed in the merged column.
 If the arrays are strings, the values are concatenated.  The strings are
 separated by a space if they are both nonempty.


"""
class vtkMergeDataObjectFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMergeDataObjectFilter - merge dataset and data object field to create dataset with attribute data

Super Class:

 vtkDataSetAlgorithm

 vtkMergeDataObjectFilter is a filter that merges the field from a
 vtkDataObject with a vtkDataSet. The resulting combined dataset can
 then be processed by other filters (e.g.,
 vtkFieldDataToAttributeDataFilter) to create attribute data like
 scalars, vectors, etc.

 The filter operates as follows. The field data from the
 vtkDataObject is merged with the input's vtkDataSet and then placed
 in the output. You can choose to place the field data into the cell
 data field, the point data field, or the datasets field (i.e., the
 one inherited from vtkDataSet's superclass vtkDataObject). All this
 data shuffling occurs via reference counting, therefore memory is
 not copied.

 One of the uses of this filter is to allow you to read/generate the
 structure of a dataset independent of the attributes. So, for
 example, you could store the dataset geometry/topology in one file,
 and field data in another. Then use this filter in combination with
 vtkFieldDataToAttributeData to create a dataset ready for
 processing in the visualization pipeline.


"""
class vtkMergeFields:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMergeFields - Merge multiple fields into one.

Super Class:

 vtkDataSetAlgorithm

 vtkMergeFields is used to merge mutliple field into one.
 The new field is put in the same field data as the original field.
 For example
 @verbatim
 mf->SetOutputField("foo", vtkMergeFields::POINT_DATA);
 mf->SetNumberOfComponents(2);
 mf->Merge(0, "array1", 1);
 mf->Merge(1, "array2", 0);
 @endverbatim
 will tell vtkMergeFields to use the 2nd component of array1 and
 the 1st component of array2 to create a 2 component field called foo.
 The same can be done using Tcl:
 @verbatim
 mf SetOutputField foo POINT_DATA
 mf Merge 0 array1 1
 mf Merge 1 array2 0

 Field locations: DATA_OBJECT, POINT_DATA, CELL_DATA
 @endverbatim

See Also:

 vtkFieldData vtkDataSet vtkDataObjectToDataSetFilter
 vtkDataSetAttributes vtkDataArray vtkRearrangeFields
 vtkSplitField vtkAssignAttribute


"""
class vtkMergeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMergeFilter - extract separate components of data from different datasets

Super Class:

 vtkDataSetAlgorithm

 vtkMergeFilter is a filter that extracts separate components of data from
 different datasets and merges them into a single dataset. The output from
 this filter is of the same type as the input (i.e., vtkDataSet.) It treats 
 both cell and point data set attributes.


"""
class vtkMergeTables:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMergeTables - combine two tables

Super Class:

 vtkTableAlgorithm

 Combines the columns of two tables into one larger table.
 The number of rows in the resulting table is the sum of the number of
 rows in each of the input tables.
 The number of columns in the output is generally the sum of the number
 of columns in each input table, except in the case where column names
 are duplicated in both tables.
 In this case, if MergeColumnsByName is on (the default), the two columns
 will be merged into a single column of the same name.
 If MergeColumnsByName is off, both columns will exist in the output.
 You may set the FirstTablePrefix and SecondTablePrefix to define how
 the columns named are modified.  One of these prefixes may be the empty
 string, but they must be different.


"""
class vtkMeshQuality:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMeshQuality - Calculate measures of quality of a mesh

Super Class:

 vtkDataSetAlgorithm

 vtkMeshQuality computes one or more measures of (geometric)
 quality for each 2-D and 3-D cell (triangle, quadrilateral, tetrahedron,
 or hexahedron) of a mesh. These measures of quality are then averaged
 over the entire mesh. The minimum, average, maximum, and variance
 of quality for each type of cell is stored in the output mesh's FieldData.
 The FieldData arrays are named "Mesh Triangle Quality,"
 "Mesh Quadrilateral Quality," "Mesh Tetrahedron Quality,"
 and "Mesh Hexahedron Quality." Each array has a single tuple
 with 5 components. The first 4 components are the quality statistics
 mentioned above; the final value is the number of cells of the given type.
 This final component makes aggregation of statistics for distributed
 mesh data possible.

 By default, the per-cell quality is added to the mesh's cell data, in
 an array named "Quality." Cell types not supported by
 this filter will have an entry of 0. Use SaveCellQualityOff() to
 store only the final statistics.

 This version of the filter written by Philippe Pebay and David Thompson
 overtakes an older version written by Leila Baghdadi, Hanif Ladak, and 
 David Steinman at the Imaging Research Labs, Robarts Research Institute.
 That version only supported tetrahedral radius ratio. See the 
 CompatibilityModeOn() member for information on how to make this filter 
 behave like the previous implementation.
 For more information on the triangle quality measures of this class, cf.
 Pebay & Baker 2003, Analysis of triangle quality measures, Math Comp 72:244.
 For more information on the quadrangle quality measures of this class, cf.
 Pebay 2004, Planar Quadrangle Quality Measures, Eng Comp 20:2.


Caveats:

 While more general than before, this class does not address many
 cell types, including wedges and pyramids in 3D and triangle strips
 and fans in 2D (among others). 
 Most quadrilateral quality measures are intended for planar quadrilaterals
 only. 
 The minimal angle is not, strictly speaking, a quality measure, but it is
 provided because of its useage by many authors.


"""
class vtkMetaImageReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkMetaImageReader - read binary UNC meta image data

Super Class:

 vtkImageReader2

 One of the formats for which a reader is already available in the toolkit is
 the MetaImage file format. This is a fairly simple yet powerful format
 consisting of a text header and a binary data section. The following
 instructions describe how you can write a MetaImage header for the data that
 you download from the BrainWeb page.

 The minimal structure of the MetaImage header is the following:

    NDims = 3
    DimSize = 181 217 181
    ElementType = MET_UCHAR
    ElementSpacing = 1.0 1.0 1.0
    ElementByteOrderMSB = False
    ElementDataFile = brainweb1.raw

    * NDims indicate that this is a 3D image. ITK can handle images of
      arbitrary dimension.
    * DimSize indicates the size of the volume in pixels along each
      direction.
    * ElementType indicate the primitive type used for pixels. In this case
      is "unsigned char", implying that the data is digitized in 8 bits /
      pixel.
    * ElementSpacing indicates the physical separation between the center of
      one pixel and the center of the next pixel along each direction in space.
      The units used are millimeters.
    * ElementByteOrderMSB indicates is the data is encoded in little or big
      endian order. You might want to play with this value when moving data
      between different computer platforms.
    * ElementDataFile is the name of the file containing the raw binary data
      of the image. This file must be in the same directory as the header. 

 MetaImage headers are expected to have extension: ".mha" or ".mhd"

 Once you write this header text file, it should be possible to read the
 image into your ITK based application using the itk::FileIOToImageFilter
 class.

Caveats:

 

See Also:



"""
class vtkMetaImageWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkMetaImageWriter - write a binary UNC meta image data

Super Class:

 vtkImageWriter

 One of the formats for which a reader is already available in the toolkit is
 the MetaImage file format. This is a fairly simple yet powerful format
 consisting of a text header and a binary data section. The following
 instructions describe how you can write a MetaImage header for the data that
 you download from the BrainWeb page.

 The minimal structure of the MetaImage header is the following:

    NDims = 3
    DimSize = 181 217 181
    ElementType = MET_UCHAR
    ElementSpacing = 1.0 1.0 1.0
    ElementByteOrderMSB = False
    ElementDataFile = brainweb1.raw

    * NDims indicate that this is a 3D image. ITK can handle images of
      arbitrary dimension.
    * DimSize indicates the size of the volume in pixels along each
      direction.
    * ElementType indicate the primitive type used for pixels. In this case
      is "unsigned char", implying that the data is digitized in 8 bits /
      pixel.
    * ElementSpacing indicates the physical separation between the center of
      one pixel and the center of the next pixel along each direction in space.
      The units used are millimeters.
    * ElementByteOrderMSB indicates is the data is encoded in little or big
      endian order. You might want to play with this value when moving data
      between different computer platforms.
    * ElementDataFile is the name of the file containing the raw binary data
      of the image. This file must be in the same directory as the header. 

 MetaImage headers are expected to have extension: ".mha" or ".mhd"

 Once you write this header text file, it should be possible to read the
 image into your ITK based application using the itk::FileIOToImageFilter
 class.

Caveats:

 

See Also:

 vtkImageWriter vtkMetaImageReader


"""
class vtkMultiBlockDataSetAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiBlockDataSetAlgorithm - Superclass for algorithms that produce only vtkMultiBlockDataSet as output

Super Class:

 vtkAlgorithm

 Algorithms that take any type of data object (including composite dataset)
 and produce a vtkMultiBlockDataSet in the output can subclass from this
 class.


"""
class vtkMultiBlockMergeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiBlockMergeFilter - merges multiblock inputs into a single multiblock output

Super Class:

 vtkMultiBlockDataSetAlgorithm

 vtkMultiBlockMergeFilter is an M to 1 filter similar to 
 vtkMultiGroupDataGroupFilters. However where as that class creates N groups 
 in the output for N inputs, this creates 1 group in the output with N 
 datasets inside it. In actuality if the inputs have M groups, this will 
 produce M groups, each of which has N datasets. Inside the merged group, 
 the i'th data set comes from the i'th data set in the i'th input.


"""
class vtkMultiBlockPLOT3DReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkMultiBlockPLOT3DReader - read PLOT3D data files

Super Class:

 vtkMultiBlockDataSetAlgorithm

 vtkMultiBlockPLOT3DReader is a reader object that reads PLOT3D formatted
 files and generates structured grid(s) on output. PLOT3D is a computer
 graphics program designed to visualize the grids and solutions of
 computational fluid dynamics. Please see the "PLOT3D User's Manual"
 available from NASA Ames Research Center, Moffett Field CA.

 PLOT3D files consist of a grid file (also known as XYZ file), an 
 optional solution file (also known as a Q file), and an optional function 
 file that contains user created data (currently unsupported). The Q file 
 contains solution  information as follows: the four parameters free stream 
 mach number (Fsmach), angle of attack (Alpha), Reynolds number (Re), and 
 total integration time (Time). This information is stored in an array
 called Properties in the FieldData of each output (tuple 0: fsmach, tuple 1:
 alpha, tuple 2: re, tuple 3: time). In addition, the solution file contains 
 the flow density (scalar), flow momentum (vector), and flow energy (scalar).

 The reader can generate additional scalars and vectors (or "functions")
 from this information. To use vtkMultiBlockPLOT3DReader, you must specify the 
 particular function number for the scalar and vector you want to visualize.
 This implementation of the reader provides the following functions. The
 scalar functions are:
    -1  - don't read or compute any scalars
    100 - density
    110 - pressure
    120 - temperature
    130 - enthalpy
    140 - internal energy
    144 - kinetic energy
    153 - velocity magnitude
    163 - stagnation energy
    170 - entropy
    184 - swirl.

 The vector functions are:
    -1  - don't read or compute any vectors
    200 - velocity
    201 - vorticity
    202 - momentum
    210 - pressure gradient.

 (Other functions are described in the PLOT3D spec, but only those listed are
 implemented here.) Note that by default, this reader creates the density 
 scalar (100) and momentum vector (202) as output. (These are just read in
 from the solution file.) Please note that the validity of computation is
 a function of this class's gas constants (R, Gamma) and the equations used.
 They may not be suitable for your computational domain.

 Additionally, you can read other data and associate it as a vtkDataArray
 into the output's point attribute data. Use the method AddFunction()
 to list all the functions that you'd like to read. AddFunction() accepts
 an integer parameter that defines the function number.


See Also:

 vtkStructuredGridSource vtkStructuredGrid


"""
class vtkMultiGroupDataExtractDataSets:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupDataExtractDataSets - extract a number of datasets

Super Class:

 vtkMultiGroupDataSetAlgorithm

 vtkMultiGroupDataExtractDataSets extracts the user specified list
 of datasets from a multi-group dataset.


"""
class vtkMultiGroupDataExtractGroup:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupDataExtractGroup - extact groups between min and max

Super Class:

 vtkMultiGroupDataSetAlgorithm

 vtkMultiGroupDataExtractGroup is a filter that extracts groups
 between user specified min and max.


"""
class vtkMultiGroupDataGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupDataGeometryFilter - extract geometry from multi-group data

Super Class:

 vtkPolyDataAlgorithm

 vtkMultiGroupDataGeometryFilter applies vtkGeometryFilter to all
 groups in vtkMultiGroupData. Place this filter at the end of a
 pipeline before a polydata consumer such as a polydata mapper to extract
 geometry from all blocks and append them to one polydata object.


"""
class vtkMultiGroupDataGroupFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupDataGroupFilter - collects multiple inputs into one multi-group dataset

Super Class:

 vtkMultiGroupDataSetAlgorithm

 vtkMultiGroupDataGroupFilter is an M to 1 filter that merges multiple
 input into one multi-group dataset. It will assign each input to
 one group of the multi-group dataset and will assign each update piece
 as a sub-block. For example, if there are two inputs and four update
 pieces, the output contains two groups with four datasets each.


"""
class vtkMultiGroupDataGroupIdScalars:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupDataGroupIdScalars - generate scalars from groups

Super Class:

 vtkMultiGroupDataSetAlgorithm

 vtkMultiGroupDataGroupIdScalars is a filter to that generates scalars 
 using multi-group data group information. For example, it will assign
 an vtkUnsignedCharArray named GroupIdScalars and of value 0 to all 
 datasets in group 0.


"""
class vtkMultiGroupDataSetAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupDataSetAlgorithm - Superclass for algorithms that produce only vtkMultiGroupDataSet as output

Super Class:

 vtkAlgorithm

 Algorithms that take any type of data object (including composite dataset)
 and produce a vtkMultiGroupDataSet in the output can subclass from this
 class.


"""
class vtkMultiGroupProbeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiGroupProbeFilter - subclass of vtkProbeFilter which supports

Super Class:

 vtkProbeFilter

 vtkMultiGroupProbeFilter supports probing into multi-group datasets.
 It sequentially probes through each concrete dataset within the multigroup
 probing at only those locations at which there were no hits when probing
 earlier datasets. For Hierarchical datasets, this traversal through leaf
 datasets is done in reverse order of levels i.e. highest level first.


"""
class vtkMultiThreshold:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkMultiThreshold - Threshold cells within multiple intervals

Super Class:

 vtkMultiBlockDataSetAlgorithm

 This filter can be substituted for a chain of several vtkThreshold filters
 and can also perform more sophisticated subsetting operations.
 It generates a vtkMultiBlockDataSet as its output.
 This multiblock dataset contains a vtkUnstructuredGrid for each thresholded
 subset you request.
 A thresholded subset can be a set defined by an interval over a
 point or cell attribute of the mesh; these subsets are called IntervalSets.
 A thresholded subset can also be a boolean combination of one or more IntervalSets;
 these subsets are called BooleanSets.
 BooleanSets allow complex logic since their output
 can depend on multiple intervals over multiple variables
 defined on the input mesh.
 This is useful because it eliminates the need for thresholding several
 times and then appending the results, as can be required with vtkThreshold
 when one wants to remove some range of values (e.g., a notch filter).
 Cells are not repeated when they belong to more than one interval unless
 those intervals have different output grids.

 Another advantage this filter provides over vtkThreshold is the ability
 to threshold on non-scalar (i.e., vector, tensor, etc.) attributes without
 first computing an array containing some norm of the desired attribute.
 vtkMultiThreshold provides \f$L_1\f$, \f$L_2\f$, and \f$L_{\infty}\f$ norms.

 This filter makes a distinction between intermediate subsets and
 subsets that will be output to a grid.
 Each intermediate subset you create with AddIntervalSet or
 AddBooleanSet is given a unique integer identifier (via the return
 values of these member functions).
 If you wish for a given set to be output, you must call
 OutputSet and pass it one of these identifiers.
 The return of OutputSet is the integer index of the output set
 in the multiblock dataset created by this filter.

 For example, if an input mesh defined three attributes T, P, and s, one might
 wish to find cells that satisfy "T < 320 [K] && ( P > 101 [kPa] || s < 0.1 [kJ/kg/K] )".
 To accomplish this with a vtkMultiThreshold filter,
 <pre>
 vtkMultiThreshold* thr;
 int intervalSets[3];

 intervalSets[0] = thr->AddIntervalSet( vtkMath::NegInf(), 320., vtkMultiThreshold::CLOSED, vtkMultiThreshold::OPEN,
     vtkDataObject::FIELD_ASSOCIATION_POINTS, "T", 0, 1 );
 intervalSets[1] = thr->AddIntervalSet( 101., vtkMath::Inf(), vtkMultiThreshold::OPEN, vtkMultiThreshold::CLOSED,
     vtkDataObject::FIELD_ASSOCIATION_CELLS, "P", 0, 1 );
 intervalSets[2] = thr->AddIntervalSet( vtkMath::NegInf(), 0.1, vtkMultiThreshold::CLOSED, vtkMultiThreshold::OPEN,
     vtkDataObject::FIELD_ASSOCIATION_POINTS, "s", 0, 1 );

 int intermediate = thr->AddBooleanSet( vtkMultiThreshold::OR, 2, &intervalSets[1] );

 int intersection[2];
 intersection[0] = intervalSets[0];
 intersection[1] = intermediate;
 int outputSet = thr->AddBooleanSet( vtkMultiThreshold::AND, 2, intersection );

 int outputGridIndex = thr->OutputSet( outputSet );
 thr->Update();
 </pre>
 The result of this filter will be a multiblock dataset that contains a single child with the desired cells.
 If we had also called <code>thr->OutputSet( intervalSets[0] );</code>, there would be two child meshes and
 one would contain all cells with T < 320 [K].
 In that case, the output can be represented by this graph
 \dot
 digraph MultiThreshold {
   set0 [shape=rect,style=filled,label="point T(0) in [-Inf,320["]
   set1 [shape=rect,label="cell P(0) in ]101,Inf]"]
   set2 [shape=rect,label="point s(0) in [-Inf,0.1["]
   set3 [shape=rect,label="OR"]
   set4 [shape=rect,style=filled,label="AND"]
   set0 -> set4
   set1 -> set3
   set2 -> set3
   set3 -> set4
 }
 \enddot
 The filled rectangles represent sets that are output.


"""
class vtkOBBDicer:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOBBDicer - divide dataset into spatially aggregated pieces

Super Class:

 vtkDicer

 vtkOBBDicer separates the cells of a dataset into spatially
 aggregated pieces using a Oriented Bounding Box (OBB). These pieces
 can then be operated on by other filters (e.g., vtkThreshold). One
 application is to break very large polygonal models into pieces and
 performing viewing and occlusion culling on the pieces.

 Refer to the superclass documentation (vtkDicer) for more information.

See Also:

 vtkDicer vtkConnectedDicer


"""
class vtkOBJReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkOBJReader - read Wavefront .obj files

Super Class:

 vtkPolyDataAlgorithm

 vtkOBJReader is a source object that reads Wavefront .obj
 files. The output of this source object is polygonal data.

See Also:

 vtkOBJImporter


"""
class vtkOpenFOAMReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkOpenFOAMReader - reads a dataset in OpenFOAM format

Super Class:

 vtkMultiBlockDataSetAlgorithm

 vtkOpenFOAMReader creates an multiblock dataset. It reads a controlDict
 file, mesh information, and time dependent data.  The controlDict file
 contains timestep information. The polyMesh folders contain mesh information
 The time folders contain transient data for the cells  Each folder can
 contain any number of data files.


"""
class vtkOpenGLTexture:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOpenGLTexture - OpenGL texture map

Super Class:

 vtkTexture

 vtkOpenGLTexture is a concrete implementation of the abstract class 
 vtkTexture. vtkOpenGLTexture interfaces to the OpenGL rendering library.


"""
class vtkOutlineCornerFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOutlineCornerFilter - create wireframe outline corners for arbitrary data set

Super Class:

 vtkPolyDataAlgorithm

 vtkOutlineCornerFilter is a filter that generates wireframe outline corners of any 
 data set. The outline consists of the eight corners of the dataset 
 bounding box.


"""
class vtkOutlineCornerSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOutlineCornerSource - create wireframe outline corners around bounding box

Super Class:

 vtkOutlineSource

 vtkOutlineCornerSource creates wireframe outline corners around a user-specified 
 bounding box.


"""
class vtkOutlineFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOutlineFilter - create wireframe outline for arbitrary data set

Super Class:

 vtkPolyDataAlgorithm

 vtkOutlineFilter is a filter that generates a wireframe outline of any 
 data set. The outline consists of the twelve edges of the dataset 
 bounding box.


"""
class vtkOutlineSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOutlineSource - create wireframe outline around bounding box

Super Class:

 vtkPolyDataAlgorithm

 vtkOutlineSource creates a wireframe outline around a
 user-specified bounding box.  The outline may be created aligned
 with the {x,y,z} axis - in which case it is defined by the 6 bounds
 {xmin,xmax,ymin,ymax,zmin,zmax} via SetBounds(). Alternatively, the
 box may be arbitrarily aligned, in which case it should be set via
 the SetCorners() member.


"""
class vtkPDBReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPDBReader - read Molecular Data files

Super Class:

 vtkMoleculeReaderBase

 vtkPDBReader is a source object that reads Molecule files
 The FileName must be specified

 .SECTION Thanks
 Dr. Jean M. Favre who developed and contributed this class


"""
class vtkPExodusIIReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPExodusIIReader - Read Exodus II files (.exii)

Super Class:

 vtkExodusIIReader

 vtkPExodusIIReader is a unstructured grid source object that reads
 ExodusII files. Most of the meta data associated with the
 file is loaded when UpdateInformation is called. This includes
 information like Title, number of blocks, number and names of
 arrays. This data can be retrieved from methods in this
 reader. Separate arrays that are meant to be a single vector, are
 combined internally for convenience. To be combined, the array
 names have to be identical except for a trailing X,Y and Z (or
 x,y,z). By default all cell and point arrays are loaded. However,
 the user can flag arrays not to load with the methods
 "SetPointDataArrayLoadFlag" and "SetCellDataArrayLoadFlag". The
 reader responds to piece requests by loading only a range of the
 possible blocks. Unused points are filtered out internally.


"""
class vtkPLOT3DReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPLOT3DReader - read PLOT3D data files

Super Class:

 vtkStructuredGridSource

 vtkPLOT3DReader is a reader object that reads PLOT3D formatted files and 
 generates structured grid(s) on output. PLOT3D is a computer graphics 
 program designed to visualize the grids and solutions of computational 
 fluid dynamics. Please see the "PLOT3D User's Manual" available from 
 NASA Ames Research Center, Moffett Field CA.

 PLOT3D files consist of a grid file (also known as XYZ file), an 
 optional solution file (also known as a Q file), and an optional function 
 file that contains user created data (currently unsupported). The Q file 
 contains solution  information as follows: the four parameters free stream 
 mach number (Fsmach), angle of attack (Alpha), Reynolds number (Re), and 
 total integration time (Time). This information is stored in an array
 called Properties in the FieldData of each output (tuple 0: fsmach, tuple 1:
 alpha, tuple 2: re, tuple 3: time). In addition, the solution file contains 
 the flow density (scalar), flow momentum (vector), and flow energy (scalar).

 The reader can generate additional scalars and vectors (or "functions")
 from this information. To use vtkPLOT3DReader, you must specify the 
 particular function number for the scalar and vector you want to visualize.
 This implementation of the reader provides the following functions. The
 scalar functions are:
    -1  - don't read or compute any scalars
    100 - density
    110 - pressure
    120 - temperature
    130 - enthalpy
    140 - internal energy
    144 - kinetic energy
    153 - velocity magnitude
    163 - stagnation energy
    170 - entropy
    184 - swirl.

 The vector functions are:
    -1  - don't read or compute any vectors
    200 - velocity
    201 - vorticity
    202 - momentum
    210 - pressure gradient.

 (Other functions are described in the PLOT3D spec, but only those listed are
 implemented here.) Note that by default, this reader creates the density 
 scalar (100) and momentum vector (202) as output. (These are just read in
 from the solution file.) Please note that the validity of computation is
 a function of this class's gas constants (R, Gamma) and the equations used.
 They may not be suitable for your computational domain.

 Additionally, you can read other data and associate it as a vtkDataArray
 into the output's point attribute data. Use the method AddFunction()
 to list all the functions that you'd like to read. AddFunction() accepts
 an integer parameter that defines the function number.


See Also:

 vtkStructuredGridSource vtkStructuredGrid


"""
class vtkPLYReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPLYReader - read Stanford University PLY polygonal file format

Super Class:

 vtkPolyDataAlgorithm

 vtkPLYReader is a source object that reads polygonal data in
 Stanford University PLY file format (see 
 http://graphics.stanford.edu/data/3Dscanrep). It requires that
 the elements "vertex" and "face" are defined. The "vertex" element
 must have the properties "x", "y", and "z". The "face" element must
 have the property "vertex_indices" defined. Optionally, if the "face"
 element has the properties "intensity" and/or the triplet "red",
 "green", and "blue"; these are read and added as scalars to the
 output data.

See Also:

 vtkPLYWriter


"""
class vtkPLYWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkPLYWriter - write Stanford PLY file format

Super Class:

 vtkPolyDataWriter

 vtkPLYWriter writes polygonal data in Stanford University PLY format
 (see http://graphics.stanford.edu/data/3Dscanrep/). The data can be
 written in either binary (little or big endian) or ASCII representation.
 As for PointData and CellData, vtkPLYWriter cannot handle normals or
 vectors. It only handles RGB PointData and CellData. You need to set the
 name of the array (using SetName for the array and SetArrayName for the
 writer). If the array is not a vtkUnsignedCharArray with 3 components,
 you need to specify a vtkLookupTable to map the scalars to RGB.

Caveats:

 PLY does not handle big endian versus little endian correctly. Also,
 this class is compiled into VTK only if the PLY library is found
 during the make process (using CMake).

See Also:

 vtkPLYReader


"""
class vtkPNGReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPNGReader - read PNG files

Super Class:

 vtkImageReader2

 vtkPNGReader is a source object that reads PNG files.
 It should be able to read most any PNG file


See Also:

 vtkPNGWriter


"""
class vtkPNGWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkPNGWriter - Writes PNG files.

Super Class:

 vtkImageWriter

 vtkPNGWriter writes PNG files. It supports 1 to 4 component data of
 unsigned char or unsigned short

See Also:

 vtkPNGReader


"""
class vtkPNMReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPNMReader - read pnm (i.e., portable anymap) files

Super Class:

 vtkImageReader

 vtkPNMReader is a source object that reads pnm (portable anymap) files.
 This includes .pbm (bitmap), .pgm (grayscale), and .ppm (pixmap) files.
 (Currently this object only reads binary versions of these files.)

 PNMReader creates structured point datasets. The dimension of the 
 dataset depends upon the number of files read. Reading a single file 
 results in a 2D image, while reading more than one file results in a 
 3D volume.

 To read a volume, files must be of the form "FileName.<number>" (e.g.,
 foo.ppm.0, foo.ppm.1, ...). You must also specify the DataExtent.  The
 fifth and sixth values of the DataExtent specify the beginning and ending
 files to read.


"""
class vtkPNMWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkPNMWriter - Writes PNM (portable any map)  files.

Super Class:

 vtkImageWriter

 vtkPNMWriter writes PNM file. The data type
 of the file is unsigned char regardless of the input type.


"""
class vtkParametricFunctionSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkParametricFunctionSource - tessellate parametric functions

Super Class:

 vtkPolyDataAlgorithm

 This class tessellates parametric functions. The user must specify how
 many points in the parametric coordinate directions are required (i.e.,
 the resolution), and the mode to use to generate scalars. 

 .SECTION Thanks
 Andrew Maclean a.maclean@cas.edu.au for creating and contributing the
 class.


See Also:

 vtkParametricFunction

 Implementation of parametrics for 1D lines:
 vtkParametricSpline

 Subclasses of vtkParametricFunction implementing non-orentable surfaces:
 vtkParametricBoy vtkParametricCrossCap vtkParametricFigure8Klein
 vtkParametricKlein vtkParametricMobius vtkParametricRoman

 Subclasses of vtkParametricFunction implementing orientable surfaces:
 vtkParametricConicSpiral vtkParametricDini vtkParametricEllipsoid 
 vtkParametricEnneper vtkParametricRandomHills vtkParametricSuperEllipsoid 
 vtkParametricSuperToroid vtkParametricTorus 
 


"""
class vtkParticleReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkParticleReader - Read ASCII or binary particle 

Super Class:

 vtkPolyDataAlgorithm

 vtkParticleReader reads either a binary or a text file of 
  particles. Each particle can have associated with it an optional
  scalar value. So the format is: x, y, z, scalar 
  (all floats or doubles). The text file can consist of a comma 
  delimited set of values. In most cases vtkParticleReader can 
  automatically determine whether the file is text or binary. 
  The data can be either float or double. 
  Progress updates are provided. 
  With respect to binary files, random access into the file to read 
  pieces is supported.
  


"""
class vtkPiecewiseFunctionAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPiecewiseFunctionAlgorithm - Superclass for algorithms that produce only piecewise function as output

Super Class:

 vtkAlgorithm


"""
class vtkPiecewiseFunctionShiftScale:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPiecewiseFunctionShiftScale -

Super Class:

 vtkPiecewiseFunctionAlgorithm


"""
class vtkPlaneSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPlaneSource - create an array of quadrilaterals located in a plane

Super Class:

 vtkPolyDataAlgorithm

 vtkPlaneSource creates an m x n array of quadrilaterals arranged as
 a regular tiling in a plane. The plane is defined by specifying an
 origin point, and then two other points that, together with the
 origin, define two axes for the plane. These axes do not have to be
 orthogonal - so you can create a parallelogram. (The axes must not
 be parallel.) By default, the plane is centered at the origin and
 perpendicular to the z-axis, with width and height of length 1. The
 resolution of the plane (i.e., number of subdivisions) is
 controlled by the ivars XResolution and YResolution.

 There are three convenience methods that allow you to easily move the
 plane.  The first, SetNormal(), allows you to specify the plane
 normal. The effect of this method is to rotate the plane around the center
 of the plane, aligning the plane normal with the specified normal. The
 rotation is about the axis defined by the cross product of the current
 normal with the new normal. The second, SetCenter(), translates the center
 of the plane to the specified center point. The third method, Push(),
 allows you to translate the plane along the plane normal by the distance
 specified. (Negative Push values translate the plane in the negative
 normal direction.)  Note that the SetNormal(), SetCenter() and Push()
 methods modify the Origin, Point1, and/or Point2 instance variables.

Caveats:

 The normal to the plane will point in the direction of the cross product
 of the first axis (Origin->Point1) with the second (Origin->Point2). This
 also affects the normals to the generated polygons.


"""
class vtkPlatonicSolidSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPlatonicSolidSource - produce polygonal Platonic solids

Super Class:

 vtkPolyDataAlgorithm

 vtkPlatonicSolidSource can generate each of the five Platonic solids:
 tetrahedron, cube, octahedron, icosahedron, and dodecahedron. Each of the
 solids is placed inside a sphere centered at the origin with radius 1.0.
 To use this class, simply specify the solid to create. Note that this
 source object creates cell scalars that are (integral value) face numbers.


"""
class vtkPointDataToCellData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPointDataToCellData - map point data to cell data

Super Class:

 vtkDataSetAlgorithm

 vtkPointDataToCellData is a filter that transforms point data (i.e., data
 specified per point) into cell data (i.e., data specified per cell).
 The method of transformation is based on averaging the data
 values of all points defining a particular cell. Optionally, the input point
 data can be passed through to the output as well.

Caveats:

 This filter is an abstract filter, that is, the output is an abstract type
 (i.e., vtkDataSet). Use the convenience methods (e.g.,
 GetPolyDataOutput(), GetStructuredPointsOutput(), etc.) to get the type
 of output you want.

See Also:

 vtkPointData vtkCellData vtkCellDataToPointData


"""
class vtkPointLoad:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPointLoad - compute stress tensors given point load on semi-infinite domain

Super Class:

 vtkImageAlgorithm

 vtkPointLoad is a source object that computes stress tensors on a volume. 
 The tensors are computed from the application of a point load on a 
 semi-infinite domain. (The analytical results are adapted from Saada - see 
 text.) It also is possible to compute effective stress scalars if desired.
 This object serves as a specialized data generator for some of the examples
 in the text.

See Also:

 vtkTensorGlyph, vtkHyperStreamline


"""
class vtkPointSetAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPointSetAlgorithm - Superclass for algorithms that produce output of the same type as input

Super Class:

 vtkAlgorithm

 vtkPointSetAlgorithm is a convenience class to make writing algorithms
 easier. It is also designed to help transition old algorithms to the new
 pipeline architecture. Ther are some assumptions and defaults made by this
 class you should be aware of. This class defaults such that your filter
 will have one input port and one output port. If that is not the case
 simply change it with SetNumberOfInputPorts etc. See this classes
 contstructor for the default. This class also provides a FillInputPortInfo
 method that by default says that all inputs will be PointSet. If that
 isn't the case then please override this method in your subclass. This
 class breaks out the downstream requests into seperate functions such as
 RequestDataObject RequestData and ExecuteInformation. The default 
 implementation of RequestDataObject will create an output data of the 
 same type as the input. 


"""
class vtkPointSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPointSource - create a random cloud of points

Super Class:

 vtkPolyDataAlgorithm

 vtkPointSource is a source object that creates a user-specified number 
 of points within a specified radius about a specified center point. 
 By default location of the points is random within the sphere. It is
 also possible to generate random points only on the surface of the
 sphere.


"""
class vtkPolyDataAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPolyDataAlgorithm - Superclass for algorithms that produce only polydata as output

Super Class:

 vtkAlgorithm


"""
class vtkPolyDataConnectivityFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPolyDataConnectivityFilter - extract polygonal data based on geometric connectivity

Super Class:

 vtkPolyDataAlgorithm

 vtkPolyDataConnectivityFilter is a filter that extracts cells that
 share common points and/or satisfy a scalar threshold
 criterion. (Such a group of cells is called a region.) The filter
 works in one of six ways: 1) extract the largest connected region
 in the dataset; 2) extract specified region numbers; 3) extract all
 regions sharing specified point ids; 4) extract all regions sharing
 specified cell ids; 5) extract the region closest to the specified
 point; or 6) extract all regions (used to color regions).

 This filter is specialized for polygonal data. This means it runs a bit 
 faster and is easier to construct visualization networks that process
 polygonal data.

 The behavior of vtkPolyDataConnectivityFilter can be modified by turning
 on the boolean ivar ScalarConnectivity. If this flag is on, the
 connectivity algorithm is modified so that cells are considered connected
 only if 1) they are geometrically connected (share a point) and 2) the
 scalar values of one of the cell's points falls in the scalar range
 specified. This use of ScalarConnectivity is particularly useful for
 selecting cells for later processing.

See Also:

 vtkConnectivityFilter


"""
class vtkPolyDataNormals:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPolyDataNormals - compute normals for polygonal mesh

Super Class:

 vtkPolyDataAlgorithm

 vtkPolyDataNormals is a filter that computes point normals for a polygonal 
 mesh. The filter can reorder polygons to insure consistent orientation
 across polygon neighbors. Sharp edges can be split and points duplicated
 with separate normals to give crisp (rendered) surface definition. It is
 also possible to globally flip the normal orientation.

 The algorithm works by determining normals for each polygon and then
 averaging them at shared points. When sharp edges are present, the edges
 are split and new points generated to prevent blurry edges (due to 
 Gouraud shading).

Caveats:

 Normals are computed only for polygons and triangle strips. Normals are
 not computed for lines or vertices.

 Triangle strips are broken up into triangle polygons. You may want to 
 restrip the triangles.


"""
class vtkPolyDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkPolyDataReader - read vtk polygonal data file

Super Class:

 vtkDataReader

 vtkPolyDataReader is a source object that reads ASCII or binary 
 polygonal data files in vtk format (see text for format details).
 The output of this reader is a single vtkPolyData data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkPolyData vtkDataReader


"""
class vtkPolyDataStreamer:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPolyDataStreamer - Stream appends input pieces to the output.

Super Class:

 vtkPolyDataAlgorithm

 vtkPolyDataStreamer initiates streaming by requesting pieces from its 
 single input it appends these pieces it to the requested output.
 Note that since vtkPolyDataStreamer uses an append filter, all the
 polygons generated have to be kept in memory before rendering. If
 these do not fit in the memory, it is possible to make the vtkPolyDataMapper
 stream. Since the mapper will render each piece separately, all the
 polygons do not have to stored in memory.
 .SECTION Note
 The output may be slightly different if the pipeline does not handle 
 ghost cells properly (i.e. you might see seames between the pieces).

See Also:

 vtkAppendFilter


"""
class vtkPolyDataToImageStencil:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPolyDataToImageStencil - clip an image with polydata

Super Class:

 vtkImageStencilSource

 vtkPolyDataToImageStencil will convert a vtkPolyData into an image
 that can be used with vtkImageStencil or other vtk classes that apply
 a stencil to an image.

See Also:

 vtkPolyData vtkImageStencil vtkImplicitFunctionToImageStencil


"""
class vtkPolyDataWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkPolyDataWriter - write vtk polygonal data

Super Class:

 vtkDataWriter

 vtkPolyDataWriter is a source object that writes ASCII or binary 
 polygonal data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkPostScriptWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkPostScriptWriter - Writes an image as a PostScript file.

Super Class:

 vtkImageWriter

 vtkPostScriptWriter writes an image as a PostScript file using some
 reasonable scalings and centered on the page which is assumed to be
 about 8.5 by 11 inches. This is based loosely off of the code from
 pnmtops.c. Right now there aren't any real options.


"""
class vtkProbeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProbeFilter - sample data values at specified point locations

Super Class:

 vtkDataSetAlgorithm

 vtkProbeFilter is a filter that computes point attributes (e.g., scalars,
 vectors, etc.) at specified point positions. The filter has two inputs:
 the Input and Source. The Input geometric structure is passed through the
 filter. The point attributes are computed at the Input point positions
 by interpolating into the source data. For example, we can compute data
 values on a plane (plane specified as Input) from a volume (Source).
 The cell data of the source data is copied to the output based on in
 which source cell each input point is. If an array of the same name exists
 both in source's point and cell data, only the one from the point data is
 probed.

 This filter can be used to resample data, or convert one dataset form into
 another. For example, an unstructured grid (vtkUnstructuredGrid) can be
 probed with a volume (three-dimensional vtkImageData), and then volume
 rendering techniques can be used to visualize the results. Another example:
 a line or curve can be used to probe data to produce x-y plots along
 that line or curve.


"""
class vtkProgrammableAttributeDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProgrammableAttributeDataFilter - manipulate attribute (cell and point) data via a user-specified function

Super Class:

 vtkDataSetAlgorithm

 vtkProgrammableAttributeDataFilter is a filter that allows you to write a
 custom procedure to manipulate attribute data - either point or cell
 data. For example, you could generate scalars based on a complex formula;
 convert vectors to normals; compute scalar values as a function of
 vectors, texture coords, and/or any other point data attribute; and so
 on. The filter takes multiple inputs (input plus an auxiliary input list),
 so you can write procedures that combine several dataset point
 attributes. Note that the output of the filter is the same type
 (topology/geometry) as the input.

 The filter works as follows. It operates like any other filter (i.e.,
 checking and managing modified and execution times, processing Update()
 and Execute() methods, managing release of data, etc.), but the difference
 is that the Execute() method simply invokes a user-specified function with
 an optional (void *) argument (typically the "this" pointer in C++). It is
 also possible to specify a function to delete the argument via
 ExecuteMethodArgDelete().

 To use the filter, you write a procedure to process the input datasets,
 process the data, and generate output data. Typically, this means grabbing
 the input point or cell data (using GetInput() and maybe GetInputList()),
 operating on it (creating new point and cell attributes such as scalars,
 vectors, etc.), and then setting the point and/or cell attributes in the
 output dataset (you'll need to use GetOutput() to access the output).
 (Note: besides C++, it is possible to do the same thing in Tcl, Java, or
 other languages that wrap the C++ core.) Remember, proper filter protocol
 requires that you don't modify the input data - you create new output data
 from the input.


Caveats:

 This filter operates on any combination of the filter input plus a list of
 additional inputs (at a minimum you must set the filter input via
 SetInput()).  It is up to you check whether the input is valid, and to
 insure that the output is valid. Also, you have to write the control
 structure for the traversal and operation on the point and cell attribute
 data.

 By default the output point and cell data will be copied through from the
 input point data (using ref ...
 [Truncated]


"""
class vtkProgrammableDataObjectSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProgrammableDataObjectSource - generate source data object via a user-specified function

Super Class:

 vtkDataObjectAlgorithm

 vtkProgrammableDataObjectSource is a source object that is programmable by
 the user. The output of the filter is a data object (vtkDataObject) which
 represents data via an instance of field data. To use this object, you
 must specify a function that creates the output.  

 Example use of this filter includes reading tabular data and encoding it
 as vtkFieldData. You can then use filters like vtkDataObjectToDataSetFilter
 to convert the data object to a dataset and then visualize it.  Another
 important use of this class is that it allows users of interpreters (e.g.,
 Tcl or Java) the ability to write source objects without having to
 recompile C++ code or generate new libraries.
 

See Also:

 vtkProgrammableFilter vtkProgrammableAttributeDataFilter
 vtkProgrammableSource vtkDataObjectToDataSetFilter


"""
class vtkProgrammableFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProgrammableFilter - a user-programmable filter

Super Class:

 vtkDataSetAlgorithm

 vtkProgrammableFilter is a filter that can be programmed by the user.  To
 use the filter you define a function that retrieves input of the correct
 type, creates data, and then manipulates the output of the filter.  Using
 this filter avoids the need for subclassing - and the function can be
 defined in an interpreter wrapper language such as Tcl or Java.

 The trickiest part of using this filter is that the input and output
 methods are unusual and cannot be compile-time type checked. Instead, as a
 user of this filter it is your responsibility to set and get the correct
 input and output types.

Caveats:

 The filter correctly manages modified time and network execution in most
 cases. However, if you change the definition of the filter function,
 you'll want to send a manual Modified() method to the filter to force it
 to reexecute.

See Also:

 vtkProgrammablePointDataFilter vtkProgrammableSource


"""
class vtkProgrammableGlyphFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProgrammableGlyphFilter - control the generation and placement of glyphs at input points

Super Class:

 vtkPolyDataAlgorithm

 vtkProgrammableGlyphFilter is a filter that allows you to place a glyph at
 each input point in the dataset. In addition, the filter is programmable
 which means the user has control over the generation of the glyph. The
 glyphs can be controlled via the point data attributes (e.g., scalars,
 vectors, etc.) or any other information in the input dataset.

 This is the way the filter works. You must define an input dataset which
 at a minimum contains points with associated attribute values. Also, the
 Source instance variable must be set which is of type vtkPolyData. Then,
 for each point in the input, the PointId is set to the current point id,
 and a user-defined function is called (i.e., GlyphMethod). In this method
 you can manipulate the Source data (including changing to a different
 Source object). After the GlyphMethod is called,
 vtkProgrammableGlyphFilter will invoke an Update() on its Source object,
 and then copy its data to the output of the
 vtkProgrammableGlyphFilter. Therefore the output of this filter is of type
 vtkPolyData.

 Another option to this filter is the way you color the glyphs. You can use
 the scalar data from the input or the source. The instance variable
 ColorMode controls this behavior.

Caveats:

 This filter operates on point data attributes. If you want to use cell
 data attributes, use a filter like vtkCellCenters to generate points at
 the centers of cells, and then use these points.

 Note that the data attributes (cell and point) are passed to the output of
 this filter from the Source object. This works well as long as you are not
 changing the class of the Source object during execution. However, if the
 class of the Source object changes, then the pot ...
 [Truncated]

See Also:

 vtkGlyph3D vtkTensorGlyph vtkCellCenters


"""
class vtkProgrammableSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProgrammableSource - generate source dataset via a user-specified function

Super Class:

 vtkDataSetAlgorithm

 vtkProgrammableSource is a source object that is programmable by the
 user. To use this object, you must specify a function that creates the
 output.  It is possible to generate an output dataset of any (concrete) 
 type; it is up to the function to properly initialize and define the 
 output. Typically, you use one of the methods to get a concrete output 
 type (e.g., GetPolyDataOutput() or GetStructuredPointsOutput()), and 
 then manipulate the output in the user-specified function.

 Example use of this include writing a function to read a data file or
 interface to another system. (You might want to do this in favor of
 deriving a new class.) Another important use of this class is that it
 allows users of interpreters (e.g., Tcl or Java) the ability to write
 source objects without having to recompile C++ code or generate new
 libraries.

See Also:

 vtkProgrammableFilter vtkProgrammableAttributeDataFilter
 vtkProgrammableDataObjectSource


"""
class vtkProjectedTerrainPath:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProjectedTerrainPath - project a polyline onto a terrain

Super Class:

 vtkPolyDataAlgorithm

 vtkProjectedTerrainPath projects an input polyline onto a terrain. (The
 terrain is defined by a 2D height image and is the second input to the
 filter.) The polyline projection is controlled via several modes as
 follows. 1) Simple mode projects the polyline points onto the terrain,
 taking into account the height offset instance variable. 2) Non-occluded
 mode insures that no parts of the polyline are occluded by the terrain
 (e.g. a line passes through a mountain). This may require recursive
 subdivision of the polyline. 3) Hug mode insures that the polyine points
 remain within a constant distance from the surface. This may also require
 recursive subdivision of the polyline. Note that both non-occluded mode
 and hug mode also take into account the height offset, so it is possible 
 to create paths that hug terrain a certain distance above it. To use this
 filter, define two inputs: 1) a polyline, and 2) an image whose scalar
 values represent a height field. Then specify the mode, and the height
 offset to use.

 An description of the algorithm is as follows. The filter begins by
 projecting the polyline points to the image (offset by the specified
 height offset).  If the mode is non-occluded or hug, then the maximum
 error along each line segment is computed and placed into a priority
 queue. Each line segment is then split at the point of maximum error, and
 the two new line segments are evaluated for maximum error. This process
 continues until the line is not occluded by the terrain (non-occluded
 mode) or satisfies the error on variation from the surface (hug
 mode). (Note this process is repeated for each polyline in the
 input. Also, the maximum error is computed in two parts: a maximum
 positive error and maximum negative error. If the polyline is above the
 terrain--i.e., the height offset is positive--in non-occluded or hug mode
 all negative errors are eliminated. If the polyline is below the
 terrain--i.e., the height offset is negative--in non-occluded or hug mode
 all positive errors are eliminated.)
 

Caveats:

 This algorithm requires the entire input image to be in memory, hence it 
 may not work for extremely large images. 

 The input height image is assumed to be positioned in the x-y plane so the
 scalar value is the z-coordinate, height value.

 A priority queue is used so that the 1) the total number of line segments
 can be controlled, and 2) the algorithm can terminate when the errors in
 the queue are less than the specified error tolerance.


See Also:

 vtkGreedyTerrainDecimation


"""
class vtkProjectedTexture:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkProjectedTexture - assign texture coordinates for a projected texture

Super Class:

 vtkDataSetAlgorithm

 vtkProjectedTexture assigns texture coordinates to a dataset as if
 the texture was projected from a slide projected located somewhere in the
 scene.  Methods are provided to position the projector and aim it at a 
 location, to set the width of the projector's frustum, and to set the
 range of texture coordinates assigned to the dataset.  

 Objects in the scene that appear behind the projector are also assigned
 texture coordinates; the projected image is left-right and top-bottom 
 flipped, much as a lens' focus flips the rays of light that pass through
 it.  A warning is issued if a point in the dataset falls at the focus
 of the projector.


"""
class vtkPruneTreeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkPruneTreeFilter - prune a subtree out of a vtkTree

Super Class:

 vtkTreeAlgorithm

 Removes a subtree rooted at a particular vertex in a vtkTree.



"""
class vtkQuadricClustering:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkQuadricClustering - reduce the number of triangles in a mesh

Super Class:

 vtkPolyDataAlgorithm

 vtkQuadricClustering is a filter to reduce the number of triangles in a
 triangle mesh, forming a good approximation to the original geometry.  The
 input to vtkQuadricClustering is a vtkPolyData object, and all types of
 polygonal data are handled.

 The algorithm used is the one described by Peter Lindstrom in his Siggraph
 2000 paper, "Out-of-Core Simplification of Large Polygonal Models."  The
 general approach of the algorithm is to cluster vertices in a uniform
 binning of space, accumulating the quadric of each triangle (pushed out to
 the triangles vertices) within each bin, and then determining an optimal
 position for a single vertex in a bin by using the accumulated quadric. In
 more detail, the algorithm first gets the bounds of the input poly data.
 It then breaks this bounding volume into a user-specified number of
 spatial bins.  It then reads each triangle from the input and hashes its
 vertices into these bins.  (If this is the first time a bin has been
 visited, initialize its quadric to the 0 matrix.) The algorithm computes
 the error quadric for this triangle and adds it to the existing quadric of
 the bin in which each vertex is contained. Then, if 2 or more vertices of
 the triangle fall in the same bin, the triangle is dicarded.  If the
 triangle is not discarded, it adds the triangle to the list of output
 triangles as a list of vertex identifiers.  (There is one vertex id per
 bin.)  After all the triangles have been read, the representative vertex
 for each bin is computed (an optimal location is found) using the quadric
 for that bin.  This determines the spatial location of the vertices of
 each of the triangles in the output.

 To use this filter, specify the divisions defining the spatial subdivision
 in the x, y, and z directions. You must also specify an input vtkPolyData.
 Then choose to either 1) use the original points that minimize the quadric
 error to produce the output triangles or 2) compute an optimal position in
 each bin to produce the output triangles (recommended and default behavior).

 This filter can take multiple inputs.  To do this, the user must explicity
 call StartAppend, Append (once for each input), and EndAppend.  StartAppend
 sets up the data structure to hold the quadric matrices.  Append processes
 each triangle in the input poly data it was called on, hashes its vertices
 to the appropriate bins, determines whether to keep this triangle, and
 updates the appropriate quadric matrices.  EndAppend determines the spatial
 location of each of the representative vertices for the visited bins. While
 this approach does not fit into the visualization architecture and requires
 manual control, it has the advantage that extremely large data can be 
 processed in pieces and appended to the filter piece-by-piece.

Caveats:

 This filter can drastically affect topology, i.e., topology is not 
 preserved.

 The filter handles input triangle strips and arbitrary polygons. Arbitrary
 polygons are assumed convex: during insertion they are triangulated using
 a fan of triangles from the first point in the polygons. If the polygon is
 concave, this can produce bad results. In this case, use vtkTriangleFilter
 to triangulate the polygons first.

See Also:

 vtkQuadricDecimation vtkDecimatePro vtkDecimate


"""
class vtkQuadricDecimation:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkQuadricDecimation - reduce the number of triangles in a mesh

Super Class:

 vtkPolyDataAlgorithm

 vtkQuadricDecimation is a filter to reduce the number of triangles in
 a triangle mesh, forming a good approximation to the original geometry. 
 The input to vtkQuadricDecimation is a vtkPolyData object, and only
 triangles are treated. If you desire to decimate polygonal meshes, first
 triangulate the polygons with vtkTriangleFilter.

 The algorithm is based on repeated edge collapses until the requested mesh
 reduction is achieved. Edges are placed in a priority queue based on the
 "cost" to delete the edge. The cost is an approximate measure of error
 (distance to the original surface)--described by the so-called quadric
 error measure. The quadric error measure is associated with each vertex of
 the mesh and represents a matrix of planes incident on that vertex. The
 distance of the planes to the vertex is the error in the position of the
 vertex (originally the vertex error iz zero). As edges are deleted, the
 quadric error measure associated with the two end points of the edge are
 summed (this combines the plane equations) and an optimal collapse point
 can be computed. Edges connected to the collapse point are then reinserted
 into the queue after computing the new cost to delete them. The process
 continues until the desired reduction level is reached or topological
 constraints prevent further reduction. Note that this basic algorithm can
 be extended to higher dimensions by
 taking into account variation in attributes (i.e., scalars, vectors, and
 so on).

 This paper is based on the work of Garland and Heckbert who first
 presented the quadric error measure at Siggraph '97 "Surface
 Simplification Using Quadric Error Metrics". For details of the algorithm
 Michael Garland's Ph.D. thesis is also recommended. Hughues Hoppe's Vis
 '99 paper, "New Quadric Metric for Simplifying Meshes with Appearance
 Attributes" is also a good take on the subject especially as it pertains
 to the error metric applied to attributes.

 .SECTION Thanks
 Thanks to Bradley Lowekamp of the National Library of Medicine/NIH for
 contributing this class.


"""
class vtkQuantizePolyDataPoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkQuantizePolyDataPoints - quantizes x,y,z coordinates of points

Super Class:

 vtkCleanPolyData

 vtkQuantizePolyDataPoints is a subclass of vtkCleanPolyData and
 inherits the functionality of vtkCleanPolyData with the addition that
 it quantizes the point coordinates before inserting into the point list.
 The user should set QFactor to a positive value (0.25 by default) and all
 {x,y,z} coordinates will be quantized to that grain size.

 A tolerance of zero is expected, though positive values may be used, the
 quantization will take place before the tolerance is applied.


Caveats:

 Merging points can alter topology, including introducing non-manifold
 forms. Handling of degenerate cells is controlled by switches in
 vtkCleanPolyData.


See Also:

 vtkCleanPolyData


"""
class vtkRTXMLPolyDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkRTXMLPolyDataReader - Read RealTime VTK XML PolyData files.

Super Class:

 vtkXMLPolyDataReader

 vtkRTXMLPolyDataReader reads the VTK XML PolyData file format in real time.  

See Also:



"""
class vtkRandomGraphSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRandomGraphSource - a graph with random edges

Super Class:

 vtkGraphAlgorithm

 Generates a graph with a specified number of vertices, with the density of
 edges specified by either an exact number of edges or the probability of
 an edge.  You may additionally specify whether to begin with a random
 tree (which enforces graph connectivity).



"""
class vtkRearrangeFields:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRearrangeFields - Move/copy fields between field data, point data and cell data

Super Class:

 vtkDataSetAlgorithm

 vtkRearrangeFields is used to copy/move fields (vtkDataArrays) between
 data object's field data, point data and cell data. To specify which
 fields are copied/moved, the user adds operations. There are two types
 of operations: 1. the type which copies/moves an attribute's data
 (i.e. the field will be copied but will not be an attribute in the
 target), 2. the type which copies/moves fields by name. For example:
 @verbatim
 rf->AddOperation(vtkRearrangeFields::COPY, "foo", 
                  vtkRearrangeFields::DATA_OBJECT, 
                  vtkRearrangeFields::POINT_DATA);
 @endverbatim
 adds an operation which copies a field (data array) called foo from
 the data object's field data to point data.
 From Tcl, the same operation can be added as follows:
 @verbatim
 rf AddOperation COPY foo DATA_OBJECT POINT_DATA
 @endverbatim
 The same can be done using Python and Java bindings by passing
 strings as arguments.
 @verbatim
 Operation types: COPY, MOVE
 AttributeTypes: SCALARS, VECTORS, NORMALS, TCOORDS, TENSORS
 Field data locations: DATA_OBJECT, POINT_DATA, CELL_DATA
 @endverbatim

Caveats:

 When using Tcl, Java, Python or Visual Basic bindings, the array name 
 can not be one of the  AttributeTypes when calling AddOperation() which 
 takes strings as arguments. The Tcl (Java etc.) command will
 always assume the string corresponds to an attribute type when
 the argument is one of the AttributeTypes. In this situation,
 use the AddOperation() which takes enums.

See Also:

 vtkFieldData vtkDataSet vtkDataObjectToDataSetFilter
 vtkDataSetAttributes vtkDataArray vtkAssignAttribute
 vtkSplitField vtkMergeFields


"""
class vtkRectangularButtonSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRectangularButtonSource - create a rectangular button

Super Class:

 vtkButtonSource

 vtkRectangularButtonSource creates a rectangular shaped button with
 texture coordinates suitable for application of a texture map. This
 provides a way to make nice looking 3D buttons. The buttons are 
 represented as vtkPolyData that includes texture coordinates and
 normals. The button lies in the x-y plane.

 To use this class you must define its width, height and length. These
 measurements are all taken with respect to the shoulder of the button.
 The shoulder is defined as follows. Imagine a box sitting on the floor.
 The distance from the floor to the top of the box is the depth; the other
 directions are the length (x-direction) and height (y-direction). In
 this particular widget the box can have a smaller bottom than top. The
 ratio in size between bottom and top is called the box ratio (by 
 default=1.0). The ratio of the texture region to the shoulder region
 is the texture ratio. And finally the texture region may be out of plane
 compared to the shoulder. The texture height ratio controls this.

Caveats:

 The button is defined in the x-y plane. Use vtkTransformPolyDataFilter
 or vtkGlyph3D to orient the button in a different direction.

See Also:

 vtkButtonSource vtkEllipticalButtonSource


"""
class vtkRectilinearGridAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRectilinearGridAlgorithm - Superclass for algorithms that produce only rectilinear grid as output

Super Class:

 vtkAlgorithm


"""
class vtkRectilinearGridClip:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRectilinearGridClip - Reduces the image extent of the input.

Super Class:

 vtkRectilinearGridAlgorithm

 vtkRectilinearGridClip  will make an image smaller.  The output must have
 an image extent which is the subset of the input.  The filter has two 
 modes of operation: 
 1: By default, the data is not copied in this filter. 
 Only the whole extent is modified.  
 2: If ClipDataOn is set, then you will get no more that the clipped
 extent.


"""
class vtkRectilinearGridGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRectilinearGridGeometryFilter - extract geometry for a rectilinear grid

Super Class:

 vtkPolyDataAlgorithm

 vtkRectilinearGridGeometryFilter is a filter that extracts geometry from a
 rectilinear grid. By specifying appropriate i-j-k indices, it is possible
 to extract a point, a curve, a surface, or a "volume". The volume
 is actually a (n x m x o) region of points.

 The extent specification is zero-offset. That is, the first k-plane in
 a 50x50x50 rectilinear grid is given by (0,49, 0,49, 0,0).

Caveats:

 If you don't know the dimensions of the input dataset, you can use a large
 number to specify extent (the number will be clamped appropriately). For 
 example, if the dataset dimensions are 50x50x50, and you want a the fifth 
 k-plane, you can use the extents (0,100, 0,100, 4,4). The 100 will 
 automatically be clamped to 49.

See Also:

 vtkGeometryFilter vtkExtractGrid


"""
class vtkRectilinearGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkRectilinearGridReader - read vtk rectilinear grid data file

Super Class:

 vtkDataReader

 vtkRectilinearGridReader is a source object that reads ASCII or binary 
 rectilinear grid data files in vtk format (see text for format details).
 The output of this reader is a single vtkRectilinearGrid data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkRectilinearGrid vtkDataReader


"""
class vtkRectilinearGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkRectilinearGridWriter - write vtk rectilinear grid data file

Super Class:

 vtkDataWriter

 vtkRectilinearGridWriter is a source object that writes ASCII or binary 
 rectilinear grid data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkRectilinearSynchronizedTemplates:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRectilinearSynchronizedTemplates - generate isosurface from rectilinear grid

Super Class:

 vtkPolyDataAlgorithm

 vtkRectilinearSynchronizedTemplates is a 3D implementation (for rectilinear
 grids) of the synchronized template algorithm. Note that vtkContourFilter
 will automatically use this class when appropriate.

Caveats:

 This filter is specialized to rectilinear grids.

See Also:

 vtkContourFilter vtkSynchronizedTemplates2D vtkSynchronizedTemplates3D


"""
class vtkRecursiveDividingCubes:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRecursiveDividingCubes - create points lying on isosurface (using recursive approach)

Super Class:

 vtkPolyDataAlgorithm

 vtkRecursiveDividingCubes is a filter that generates points lying on a 
 surface of constant scalar value (i.e., an isosurface). Dense point 
 clouds (i.e., at screen resolution) will appear as a surface. Less dense 
 clouds can be used as a source to generate streamlines or to generate 
 "transparent" surfaces.

 This implementation differs from vtkDividingCubes in that it uses a 
 recursive procedure. In many cases this can result in generating 
 more points than the procedural implementation of vtkDividingCubes. This is
 because the recursive procedure divides voxels by multiples of powers of 
 two. This can over-constrain subdivision. One of the advantages of the 
 recursive technique is that the recursion is terminated earlier, which in
 some cases can be more efficient.

See Also:

 vtkDividingCubes vtkContourFilter vtkMarchingCubes


"""
class vtkReflectionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkReflectionFilter - reflects a data set across a plane

Super Class:

 vtkUnstructuredGridAlgorithm

 The vtkReflectionFilter reflects a data set across one of the
 planes formed by the data set's bounding box.
 Since it converts data sets into unstructured grids, it is not effeicient
 for structured data sets.


"""
class vtkRegularPolygonSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRegularPolygonSource - create a regular, n-sided polygon and/or polyline

Super Class:

 vtkPolyDataAlgorithm

 vtkRegularPolygonSource is a source object that creates a single n-sided polygon and/or 
 polyline. The polygon is centered at a specified point, orthogonal to
 a specified normal, and with a circumscribing radius set by the user. The user can
 also specify the number of sides of the polygon ranging from [3,N].

 This object can be used for seeding streamlines or defining regions for clipping/cutting.


"""
class vtkRenderLargeImage:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRenderLargeImage - Use tiling to generate a large rendering

Super Class:

 vtkAlgorithm

 vtkRenderLargeImage provides methods needed to read a region from a file.


"""
class vtkRendererSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRendererSource - take a renderer into the pipeline

Super Class:

 vtkAlgorithm

 vtkRendererSource is a source object that gets its input from a 
 renderer and converts it to structured points. This can then be 
 used in a visualization pipeline. You must explicitly send a 
 Modify() to this object to get it to reload its data from the
 renderer. Consider using vtkWindowToImageFilter instead of this
 class.

 The data placed into the output is the renderer's image rgb values.
 Optionally, you can also grab the image depth (e.g., z-buffer) values, and
 place then into the output (point) field data.

See Also:

 vtkWindowToImageFilter vtkRenderer vtkStructuredPoints


"""
class vtkReverseSense:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkReverseSense - reverse the ordering of polygonal cells and/or vertex normals

Super Class:

 vtkPolyDataAlgorithm

 
 vtkReverseSense is a filter that reverses the order of polygonal cells
 and/or reverses the direction of point and cell normals. Two flags are
 used to control these operations. Cell reversal means reversing the order
 of indices in the cell connectivity list. Normal reversal means
 multiplying the normal vector by -1 (both point and cell normals, 
 if present).

Caveats:

 Normals can be operated on only if they are present in the data.


"""
class vtkRibbonFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRibbonFilter - create oriented ribbons from lines defined in polygonal dataset

Super Class:

 vtkPolyDataAlgorithm

 vtkRibbonFilter is a filter to create oriented ribbons from lines defined
 in polygonal dataset. The orientation of the ribbon is along the line 
 segments and perpendicular to "projected" line normals. Projected line 
 normals are the original line normals projected to be perpendicular to 
 the local line segment. An offset angle can be specified to rotate the 
 ribbon with respect to the normal.


Caveats:

 The input line must not have duplicate points, or normals at points that
 are parallel to the incoming/outgoing line segments. (Duplicate points
 can be removed with vtkCleanPolyData.) If a line does not meet this
 criteria, then that line is not tubed.

See Also:

 vtkTubeFilter


"""
class vtkRotationFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRotationFilter - Duplicates a data set by rotation about an axis

Super Class:

 vtkUnstructuredGridAlgorithm

 The vtkRotationFilter duplicates a data set by rotation about one of the
 3 axis of the dataset's reference.
 Since it converts data sets into unstructured grids, it is not efficient
 for structured data sets.

 .SECTION Thanks
 Theophane Foggia of The Swiss National Supercomputing Centre (CSCS)
 for creating and contributing this filter


"""
class vtkRotationalExtrusionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRotationalExtrusionFilter - sweep polygonal data creating "skirt" from free edges and lines, and lines from vertices

Super Class:

 vtkPolyDataAlgorithm

 vtkRotationalExtrusionFilter is a modeling filter. It takes polygonal 
 data as input and generates polygonal data on output. The input dataset 
 is swept around the z-axis to create new polygonal primitives. These 
 primitives form a "skirt" or swept surface. For example, sweeping a
 line results in a cylindrical shell, and sweeping a circle creates a 
 torus.

 There are a number of control parameters for this filter. You can 
 control whether the sweep of a 2D object (i.e., polygon or triangle 
 strip) is capped with the generating geometry via the "Capping" instance
 variable. Also, you can control the angle of rotation, and whether 
 translation along the z-axis is performed along with the rotation.
 (Translation is useful for creating "springs".) You also can adjust 
 the radius of the generating geometry using the "DeltaRotation" instance 
 variable.

 The skirt is generated by locating certain topological features. Free 
 edges (edges of polygons or triangle strips only used by one polygon or
 triangle strips) generate surfaces. This is true also of lines or 
 polylines. Vertices generate lines.

 This filter can be used to model axisymmetric objects like cylinders,
 bottles, and wine glasses; or translational/rotational symmetric objects
 like springs or corkscrews.

Caveats:

 If the object sweeps 360 degrees, radius does not vary, and the object 
 does not translate, capping is not performed. This is because the cap 
 is unnecessary.

 Some polygonal objects have no free edges (e.g., sphere). When swept,
 this will result in two separate surfaces if capping is on, or no surface
 if capping is off.

See Also:

 vtkLinearExtrusionFilter


"""
class vtkRuledSurfaceFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkRuledSurfaceFilter - generates a surface from a set of lines

Super Class:

 vtkPolyDataAlgorithm

 vtkRuledSurfaceFilter is a filter that generates a surface from a set of
 lines. The lines are assumed to be "parallel" in the sense that they do
 not intersect and remain somewhat close to one another. A surface is
 generated by connecting the points defining each pair of lines with
 straight lines. This creates a strip for each pair of lines (i.e., a
 triangulation is created from two generating lines). The filter can handle
 an arbitrary number of lines, with lines i and i+1 assumed connected.
 Note that there are several different approaches for creating the ruled
 surface, the method for creating the surface can either use the input
 points or resample from the polylines (using a user-specified resolution).

 This filter offers some other important features. A DistanceFactor ivar is
 used to decide when two lines are too far apart to connect. (The factor is
 a multiple of the distance between the first two points of the two lines
 defining the strip.) If the distance between the two generating lines
 becomes too great, then the surface is not generated in that
 region. (Note: if the lines separate and then merge, then a hole can be
 generated in the surface.) In addition, the Offset and OnRation ivars can
 be used to create nifty striped surfaces. Closed surfaces (e.g., tubes) can
 be created by setting the CloseSurface ivar. (The surface can be closed
 in the other direction by repeating the first and last point in the
 polylines defining the surface.)

 An important use of this filter is to combine it with vtkStreamLine to
 generate stream surfaces. It can also be used to create surfaces from
 contours.

Caveats:

 The number of lines must be greater than two if a surface is to be
 generated.  sides (i.e., a ribbon), use vtkRibbonFilter.

See Also:

 vtkRibbonFilter vtkStreamLine


"""
class vtkSESAMEReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkSESAMEReader - read SESAME files

Super Class:

 vtkRectilinearGridSource

 vtkSESAMEReader is a source object that reads SESAME files.
 Currently supported tables include 301, 304, 502, 503, 504, 505, 602

 SESAMEReader creates rectilinear grid datasets. The dimension of the 
 dataset depends upon the number of densities and temperatures in the table.
 Values at certain temperatures and densities are stored as scalars.



"""
class vtkSLCReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkSLCReader - read an SLC volume file.

Super Class:

 vtkImageReader2

 vtkSLCReader reads an SLC file and creates a structured point dataset.
 The size of the volume and the data spacing is set from the SLC file
 header.


"""
class vtkSQLTableReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkSQLTableReader - executes an sql query and retrieves results into a table

Super Class:

 vtkTableAlgorithm

 vtkSQLTableReader creates a vtkTable with the results of an arbitrary SQL
 query.  To use this filter, you first need an instance of a vtkSQLDatabase
 subclass.  You may use the database class to obtain a vtkSQLQuery instance.
 Set that query on this filter to extract the query as a table.

 .SECTION Thanks
 Thanks to Andrew Wilson from Sandia National Laboratories for his work
 on the database classes.


See Also:

 vtkSQLDatabase vtkSQLQuery


"""
class vtkSTLReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkSTLReader - read ASCII or binary stereo lithography files

Super Class:

 vtkPolyDataAlgorithm

 vtkSTLReader is a source object that reads ASCII or binary stereo 
 lithography files (.stl files). The FileName must be specified to
 vtkSTLReader. The object automatically detects whether the file is
 ASCII or binary.

 .stl files are quite inefficient since they duplicate vertex 
 definitions. By setting the Merging boolean you can control whether the 
 point data is merged after reading. Merging is performed by default, 
 however, merging requires a large amount of temporary storage since a 
 3D hash table must be constructed.

Caveats:

 Binary files written on one system may not be readable on other systems.
 vtkSTLWriter uses VAX or PC byte ordering and swaps bytes on other systems.


"""
class vtkSTLWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkSTLWriter - write stereo lithography files

Super Class:

 vtkPolyDataWriter

 vtkSTLWriter writes stereo lithography (.stl) files in either ASCII or
 binary form. Stereo lithography files only contain triangles. If polygons
 with more than 3 vertices are present, only the first 3 vertices are
 written.  Use vtkTriangleFilter to convert polygons to triangles.

Caveats:

 Binary files written on one system may not be readable on other systems.
 vtkSTLWriter uses VAX or PC byte ordering and swaps bytes on other systems.


"""
class vtkSampleFunction:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSampleFunction - sample an implicit function over a structured point set

Super Class:

 vtkImageAlgorithm

 vtkSampleFunction is a source object that evaluates an implicit function
 and normals at each point in a vtkStructuredPoints. The user can specify
 the sample dimensions and location in space to perform the sampling. To
 create closed surfaces (in conjunction with the vtkContourFilter), capping
 can be turned on to set a particular value on the boundaries of the sample
 space.

See Also:

 vtkImplicitModeller


"""
class vtkSelectPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSelectPolyData - select portion of polygonal mesh; generate selection scalars

Super Class:

 vtkPolyDataAlgorithm

 vtkSelectPolyData is a filter that selects polygonal data based on
 defining a "loop" and indicating the region inside of the loop. The
 mesh within the loop consists of complete cells (the cells are not
 cut). Alternatively, this filter can be used to generate scalars.
 These scalar values, which are a distance measure to the loop, can
 be used to clip, contour. or extract data (i.e., anything that an
 implicit function can do). 

 The loop is defined by an array of x-y-z point coordinates.
 (Coordinates should be in the same coordinate space as the input
 polygonal data.) The loop can be concave and non-planar, but not
 self-intersecting. The input to the filter is a polygonal mesh
 (only surface primitives such as triangle strips and polygons); the
 output is either a) a portion of the original mesh laying within
 the selection loop (GenerateSelectionScalarsOff); or b) the same
 polygonal mesh with the addition of scalar values
 (GenerateSelectionScalarsOn).

 The algorithm works as follows. For each point coordinate in the
 loop, the closest point in the mesh is found. The result is a loop
 of closest point ids from the mesh. Then, the edges in the mesh
 connecting the closest points (and laying along the lines forming
 the loop) are found. A greedy edge tracking procedure is used as
 follows. At the current point, the mesh edge oriented in the
 direction of and whose end point is closest to the line is
 chosen. The edge is followed to the new end point, and the
 procedure is repeated. This process continues until the entire loop
 has been created. 
 
 To determine what portion of the mesh is inside and outside of the
 loop, three options are possible. 1) the smallest connected region,
 2) the largest connected region, and 3) the connected region
 closest to a user specified point. (Set the ivar SelectionMode.)
 
 Once the loop is computed as above, the GenerateSelectionScalars
 controls the output of the filter. If on, then scalar values are
 generated based on distance to the loop lines. Otherwise, the cells
 laying inside the selection loop are output. By default, the mesh
 lying within the loop is output; however, if InsideOut is on, then
 the portion of the mesh lying outside of the loop is output.

 The filter can be configured to generate the unselected portions of
 the mesh as output by setting GenerateUnselectedOutput. Use the
 method GetUnselectedOutput to access this output. (Note: this flag
 is pertinent only when GenerateSelectionScalars is off.)

Caveats:

 Make sure that the points you pick are on a connected surface. If
 not, then the filter will generate an empty or partial result. Also,
 self-intersecting loops will generate unpredictable results.

 During processing of the data, non-triangular cells are converted to
 triangles if GenerateSelectionScalars is off.

See Also:

 vtkImplicitSelectionLoop


"""
class vtkSelectVisiblePoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSelectVisiblePoints - extract points that are visible (based on z-buffer calculation)

Super Class:

 vtkPolyDataAlgorithm

 vtkSelectVisiblePoints is a filter that selects points based on
 whether they are visible or not. Visibility is determined by
 accessing the z-buffer of a rendering window. (The position of each
 input point is converted into display coordinates, and then the
 z-value at that point is obtained. If within the user-specified
 tolerance, the point is considered visible.)

 Points that are visible (or if the ivar SelectInvisible is on,
 invisible points) are passed to the output. Associated data
 attributes are passed to the output as well.

 This filter also allows you to specify a rectangular window in display
 (pixel) coordinates in which the visible points must lie. This can be
 used as a sort of local "brushing" operation to select just data within
 a window.
 

Caveats:

 You must carefully synchronize the execution of this filter. The
 filter refers to a renderer, which is modified every time a render
 occurs. Therefore, the filter is always out of date, and always
 executes. You may have to perform two rendering passes, or if you
 are using this filter in conjunction with vtkLabeledDataMapper,
 things work out because 2D rendering occurs after the 3D rendering.


"""
class vtkSelectionAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSelectionAlgorithm - Superclass for algorithms that produce only Selection as output

Super Class:

 vtkAlgorithm

 vtkSelectionAlgorithm is a convenience class to make writing algorithms
 easier. It is also designed to help transition old algorithms to the new
 pipeline edgehitecture. There are some assumptions and defaults made by this
 class you should be aware of. This class defaults such that your filter
 will have one input port and one output port. If that is not the case
 simply change it with SetNumberOfInputPorts etc. See this class
 constructor for the default. This class also provides a FillInputPortInfo
 method that by default says that all inputs will be Selection. If that
 isn't the case then please override this method in your subclass. This
 class breaks out the downstream requests into separate functions such as
 ExecuteData and ExecuteInformation.  For new algorithms you should
 implement RequestData( request, inputVec, outputVec) but for older filters
 there is a default implementation that calls the old ExecuteData(output)
 signature. For even older filters that don't implement ExecuteData the
 default implementation calls the even older Execute() signature.

 .SECTION Thanks
 Thanks to Patricia Crossno, Ken Moreland, Andrew Wilson and Brian Wylie from
 Sandia National Laboratories for their help in developing this class.


"""
class vtkSelectionLink:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSelectionLink - An algorithm for linking selections among objects

Super Class:

 vtkSelectionAlgorithm

 vtkSelectionLink is a simple source filter which outputs the selection
 object stored internally.  Multiple objects may share
 the same selection link filter and connect it to an internal pipeline so
 that if one object changes the selection, it will be pulled into all
 the other objects when their pipelines update.


"""
class vtkSelectionSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSelectionSource - Generate selection from given set of ids

Super Class:

 vtkSelectionAlgorithm

None provided.


"""
class vtkShepardMethod:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkShepardMethod - sample unstructured points onto structured points using the method of Shepard

Super Class:

 vtkImageAlgorithm

 vtkShepardMethod is a filter used to visualize unstructured point data using
 Shepard's method. The method works by resampling the unstructured points 
 onto a structured points set. The influence functions are described as 
 "inverse distance weighted". Once the structured points are computed, the 
 usual visualization techniques (e.g., iso-contouring or volume rendering)
 can be used visualize the structured points.

Caveats:

 The input to this filter is any dataset type. This filter can be used 
 to resample any form of data, i.e., the input data need not be 
 unstructured. 

 The bounds of the data (i.e., the sample space) is automatically computed
 if not set by the user.

 If you use a maximum distance less than 1.0, some output points may
 never receive a contribution. The final value of these points can be 
 specified with the "NullValue" instance variable.


"""
class vtkShrinkFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkShrinkFilter - shrink cells composing an arbitrary data set

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkShrinkFilter shrinks cells composing an arbitrary data set
 towards their centroid. The centroid of a cell is computed as the
 average position of the cell points. Shrinking results in
 disconnecting the cells from one another. The output of this filter
 is of general dataset type vtkUnstructuredGrid.

Caveats:

 It is possible to turn cells inside out or cause self intersection
 in special cases.

See Also:

 vtkShrinkPolyData


"""
class vtkShrinkPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkShrinkPolyData - shrink cells composing PolyData

Super Class:

 vtkPolyDataAlgorithm

 vtkShrinkPolyData shrinks cells composing a polygonal dataset (e.g., 
 vertices, lines, polygons, and triangle strips) towards their centroid. 
 The centroid of a cell is computed as the average position of the
 cell points. Shrinking results in disconnecting the cells from
 one another. The output dataset type of this filter is polygonal data.

 During execution the filter passes its input cell data to its
 output. Point data attributes are copied to the points created during the
 shrinking process.

Caveats:

 It is possible to turn cells inside out or cause self intersection
 in special cases.
 Users should use the vtkTriangleFilter to triangulate meshes that 
 contain triangle strips.

See Also:

 vtkShrinkFilter


"""
class vtkSimpleElevationFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSimpleElevationFilter - generate scalars along a specified direction

Super Class:

 vtkDataSetAlgorithm

 vtkSimpleElevationFilter is a filter to generate scalar values from a
 dataset.  The scalar values are generated by dotting a user-specified
 vector against a vector defined from the input dataset points to the
 origin. 

See Also:

 vtkElevationFilter


"""
class vtkSimpleImageFilterExample:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSimpleImageFilterExample - Simple example of an image-image filter.

Super Class:

 vtkSimpleImageToImageFilter

 This is an example of a simple image-image filter. It copies it's input
 to it's output (point by point). It shows how templates can be used
 to support various data types.
 .SECTION See also
 vtkSimpleImageToImageFilter


"""
class vtkSimplePointsReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkSimplePointsReader - Read a list of points from a file.

Super Class:

 vtkPolyDataAlgorithm

 vtkSimplePointsReader is a source object that reads a list of
 points from a file.  Each point is specified by three
 floating-point values in ASCII format.  There is one point per line
 of the file.  A vertex cell is created for each point in the
 output.  This reader is meant as an example of how to write a
 reader in VTK.


"""
class vtkSmoothPolyDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSmoothPolyDataFilter - adjust point positions using Laplacian smoothing

Super Class:

 vtkPolyDataAlgorithm

 vtkSmoothPolyDataFilter is a filter that adjusts point coordinates using 
 Laplacian smoothing. The effect is to "relax" the mesh, making the cells 
 better shaped and the vertices more evenly distributed. Note that this
 filter operates on the lines, polygons, and triangle strips composing an
 instance of vtkPolyData. Vertex or poly-vertex cells are never modified.
 
 The algorithm proceeds as follows. For each vertex v, a topological and
 geometric analysis is performed to determine which vertices are connected
 to v, and which cells are connected to v. Then, a connectivity array is
 constructed for each vertex. (The connectivity array is a list of lists
 of vertices that directly attach to each vertex.) Next, an iteration
 phase begins over all vertices. For each vertex v, the coordinates of v
 are modified according to an average of the connected vertices.  (A
 relaxation factor is available to control the amount of displacement of
 v).  The process repeats for each vertex. This pass over the list of
 vertices is a single iteration. Many iterations (generally around 20 or
 so) are repeated until the desired result is obtained.
 
 There are some special instance variables used to control the execution
 of this filter. (These ivars basically control what vertices can be
 smoothed, and the creation of the connectivity array.) The
 BoundarySmoothing ivar enables/disables the smoothing operation on
 vertices that are on the "boundary" of the mesh. A boundary vertex is one
 that is surrounded by a semi-cycle of polygons (or used by a single
 line).
 
 Another important ivar is FeatureEdgeSmoothing. If this ivar is
 enabled, then interior vertices are classified as either "simple",
 "interior edge", or "fixed", and smoothed differently. (Interior
 vertices are manifold vertices surrounded by a cycle of polygons; or used
 by two line cells.) The classification is based on the number of feature 
 edges attached to v. A feature edge occurs when the angle between the two
 surface normals of a polygon sharing an edge is greater than the
 FeatureAngle ivar. Then, vertices used by no feature edges are classified
 "simple", vertices used by exactly two feature edges are classified
 "interior edge", and all others are "fixed" vertices.

 Once the classification is known, the vertices are smoothed
 differently. Corner (i.e., fixed) vertices are not smoothed at all. 
 Simple vertices are smoothed as before (i.e., average of connected 
 vertex coordinates). Interior edge vertices are smoothed only along 
 their two connected edges, and only if the angle between the edges 
 is less than the EdgeAngle ivar.

 The total smoothing can be controlled by using two ivars. The 
 NumberOfIterations is a cap on the maximum number of smoothing passes.
 The Convergence ivar is a limit on the maximum point motion. If the 
 maximum motion during an iteration is less than Convergence, then the 
 smoothing process terminates. (Convergence is expressed as a fraction of 
 the diagonal of the bounding box.)

 There are two instance variables that control the generation of error
 data. If the ivar GenerateErrorScalars is on, then a scalar value indicating
 the distance of each vertex from its original position is computed. If the
 ivar GenerateErrorVectors is on, then a vector representing change in 
 position is computed.

 Optionally you can further control the smoothing process by defining a
 second input: the Source. If defined, the input mesh is constrained to
 lie on the surface defined by the Source ivar.


Caveats:

 
 The Laplacian operation reduces high frequency information in the geometry
 of the mesh. With excessive smoothing important details may be lost, and
 the surface may shrink towards the centroid. Enabling FeatureEdgeSmoothing
 helps reduce this effect, but cannot entirely eliminate it. You may also
 wish to try vtkWindowedSincPolyDataFilter. It does a better job of 
 minimizing shrinkage.


See Also:

 vtkWindowedSincPolyDataFilter vtkDecimate vtkDecimatePro


"""
class vtkSpatialRepresentationFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSpatialRepresentationFilter - generate polygonal model of spatial search object (i.e., a vtkLocator)

Super Class:

 vtkPolyDataSource

 vtkSpatialRepresentationFilter generates an polygonal representation of a
 spatial search (vtkLocator) object. The representation varies depending
 upon the nature of the spatial search object. For example, the
 representation for vtkOBBTree is a collection of oriented bounding
 boxes. Ths input to this filter is a dataset of any type, and the output
 is polygonal data. You must also specify the spatial search object to
 use.

 Generally spatial search objects are used for collision detection and
 other geometric operations, but in this filter one or more levels of
 spatial searchers can be generated to form a geometric approximation to
 the input data. This is a form of data simplification, generally used to
 accelerate the rendering process. Or, this filter can be used as a
 debugging/ visualization aid for spatial search objects.
 
 This filter can generate one or more output vtkPolyData corresponding to
 different levels in the spatial search tree. The output data is retrieved 
 using the GetOutput(id) method, where id ranges from 0 (root level) 
 to Level. Note that the output for level "id" is not computed unless a 
 GetOutput(id) method is issued. Thus, if you desire three levels of output 
 (say 2,4,7), you would have to invoke GetOutput(2), GetOutput(4), and 
 GetOutput(7). (Also note that the Level ivar is computed automatically 
 depending on the size and nature of the input data.) There is also 
 another GetOutput() method that takes no parameters. This method returns 
 the leafs of the spatial search tree, which may be at different levels.

Caveats:

 You can specify the number of levels of to generate with the MaxLevels
 ivar. However, when the spatial search tree is built, this number of levels 
 may not actually be generated. The actual number available can be found in 
 the Levels ivar. Note that the value of Levels may change after filter
 execution.

See Also:

 vtkLocator vtkPointLocator vtkCellLocator vtkOBBTree 


"""
class vtkSpherePuzzle:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSpherePuzzle - create a polygonal sphere centered at the origin

Super Class:

 vtkPolyDataAlgorithm

 vtkSpherePuzzle creates 


"""
class vtkSpherePuzzleArrows:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSpherePuzzleArrows - Visualize permutation of the sphere puzzle.

Super Class:

 vtkPolyDataAlgorithm

 vtkSpherePuzzleArrows creates 


"""
class vtkSphereSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSphereSource - create a polygonal sphere centered at the origin

Super Class:

 vtkPolyDataAlgorithm

 vtkSphereSource creates a sphere (represented by polygons) of specified
 radius centered at the origin. The resolution (polygonal discretization)
 in both the latitude (phi) and longitude (theta) directions can be
 specified. It also is possible to create partial spheres by specifying
 maximum phi and theta angles. By default, the surface tessellation of
 the sphere uses triangles; however you can set LatLongTessellation to
 produce a tessellation using quadrilaterals.

Caveats:

 Resolution means the number of latitude or longitude lines for a complete 
 sphere. If you create partial spheres the number of latitude/longitude 
 lines may be off by one. 


"""
class vtkSplineFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSplineFilter - generate uniformly subdivided polylines from a set of input polyline using a vtkSpline

Super Class:

 vtkPolyDataAlgorithm

 vtkSplineFilter is a filter that generates an output polylines from an
 input set of polylines. The polylines are uniformly subdivided and produced
 with the help of a vtkSpline class that the user can specify (by default a
 vtkCardinalSpline is used). The number of subdivisions of the line can be
 controlled in several ways. The user can either specify the number of
 subdivisions or a length of each subdivision can be provided (and the
 class will figure out how many subdivisions is required over the whole
 polyline). The maximum number of subdivisions can also be set.

 The output of this filter is a polyline per input polyline (or line). New
 points and texture coordinates are created. Point data is interpolated and
 cell data passed on. Any polylines with less than two points, or who have
 coincident points, are ignored.

See Also:

 vtkRibbonFilter vtkTubeFilter


"""
class vtkSplitField:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSplitField - Split a field into single component fields

Super Class:

 vtkDataSetAlgorithm

 vtkSplitField is used to split a multi-component field (vtkDataArray)
 into multiple single component fields. The new fields are put in
 the same field data as the original field. The output arrays
 are of the same type as the input array. Example:
 @verbatim
 sf->SetInputField("gradient", vtkSplitField::POINT_DATA);
 sf->Split(0, "firstcomponent");
 @endverbatim
 tells vtkSplitField to extract the first component of the field
 called gradient and create an array called firstcomponent (the
 new field will be in the output's point data).
 The same can be done from Tcl:
 @verbatim
 sf SetInputField gradient POINT_DATA
 sf Split 0 firstcomponent

 AttributeTypes: SCALARS, VECTORS, NORMALS, TCOORDS, TENSORS
 Field locations: DATA_OBJECT, POINT_DATA, CELL_DATA
 @endverbatim
 Note that, by default, the original array is also passed through.

Caveats:

 When using Tcl, Java, Python or Visual Basic bindings, the array name 
 can not be one of the  AttributeTypes when calling Split() which takes
 strings as arguments. The Tcl (Java etc.) command will
 always assume the string corresponds to an attribute type when
 the argument is one of the AttributeTypes. In this situation,
 use the Split() which takes enums.

See Also:

 vtkFieldData vtkDataSet vtkDataObjectToDataSetFilter
 vtkDataSetAttributes vtkDataArray vtkRearrangeFields
 vtkAssignAttribute vtkMergeFields


"""
class vtkStreamLine:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStreamLine - generate streamline in arbitrary dataset

Super Class:

 vtkStreamer

 vtkStreamLine is a filter that generates a streamline for an arbitrary 
 dataset. A streamline is a line that is everywhere tangent to the vector
 field. Scalar values also are calculated along the streamline and can be 
 used to color the line. Streamlines are calculated by integrating from
 a starting point through the vector field. Integration can be performed
 forward in time (see where the line goes), backward in time (see where the
 line came from), or in both directions. It also is possible to compute
 vorticity along the streamline. Vorticity is the projection (i.e., dot
 product) of the flow rotation on the velocity vector, i.e., the rotation
 of flow around the streamline.

 vtkStreamLine defines the instance variable StepLength. This parameter 
 controls the time increment used to generate individual points along
 the streamline(s). Smaller values result in more line 
 primitives but smoother streamlines. The StepLength instance variable is 
 defined in terms of time (i.e., the distance that the particle travels in
 the specified time period). Thus, the line segments will be smaller in areas
 of low velocity and larger in regions of high velocity. (NOTE: This is
 different than the IntegrationStepLength defined by the superclass
 vtkStreamer. IntegrationStepLength is used to control integration step 
 size and is expressed as a fraction of the cell length.) The StepLength
 instance variable is important because subclasses of vtkStreamLine (e.g.,
 vtkDashedStreamLine) depend on this value to build their representation.

See Also:

 vtkStreamer vtkDashedStreamLine vtkStreamPoints


"""
class vtkStreamPoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStreamPoints - generate points along streamer separated by constant time increment

Super Class:

 vtkStreamer

 vtkStreamPoints is a filter that generates points along a streamer.
 The points are separated by a constant time increment. The resulting visual
 effect (especially when coupled with vtkGlyph3D) is an indication of 
 particle speed.

See Also:

 vtkStreamer vtkStreamLine vtkDashedStreamLine


"""
class vtkStreamTracer:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStreamTracer - Streamline generator

Super Class:

 vtkPolyDataAlgorithm

 vtkStreamTracer is a filter that integrates a vector field to generate
 streamlines. The integration is performed using the provided integrator.
 The default is second order Runge-Kutta. 
 
 vtkStreamTracer generate polylines as output. Each cell (polyline) 
 corresponds to one streamline. The values associated with each streamline
 are stored in the cell data whereas the values associated with points
 are stored in point data.

 Note that vtkStreamTracer can integrate both forward and backward. 
 The length of the streamline is controlled by specifying either
 a maximum value in the units of length, cell length or elapsed time 
 (the elapsed time is the time each particle would have traveled if
 flow were steady). Otherwise, the integration terminates after exiting 
 the dataset or if the particle speed is reduced to a value less than 
 the terminal speed or when a maximum number of steps is reached. 
 The reason for the termination is stored in a cell array named 
 ReasonForTermination.

 The quality of integration can be controlled by setting integration
 step (InitialIntegrationStep) and in the case of adaptive solvers
 the maximum error, the minimum integration step and the maximum 
 integration step. All of these can have units of length, cell length 
 or elapsed time.

 The integration time, vorticity, rotation and angular velocity
 are stored in point arrays named "IntegrationTime", "Vorticity",
 "Rotation" and "AngularVelocity" respectively (vorticity, rotation
 and angular velocity are computed only when ComputeVorticity is on).
 All point attributes in the source data set are interpolated on the 
 new streamline points.

 vtkStreamTracer integrates through any type of dataset. As a result, if the 
 dataset contains 2D cells such as polygons or triangles, the integration is
 constrained to lie on the surface defined by the 2D cells.

 The starting point of traces may be defined in two different ways.
 Starting from global x-y-z "position" allows you to start a single trace
 at a specified x-y-z coordinate. If you specify a source object, 
 a trace will be generated for each point in the source that is 
 inside the dataset.


See Also:

 vtkRibbonFilter vtkRuledSurfaceFilter vtkInitialValueProblemSolver 
 vtkRungeKutta2 vtkRungeKutta4 vtkRungeKutta45 


"""
class vtkStringToNumeric:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStringToNumeric - Converts string arrays to numeric arrays

Super Class:

 vtkDataObjectAlgorithm

 vtkStringToNumeric is a filter for converting a string array
 into a numeric arrays.


"""
class vtkStringToTimePoint:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStringToTimePoint - Converts a string array to a integral time array

Super Class:

 vtkDataObjectAlgorithm


 vtkStringToTimePoint is a filter for converting a string array
 into a datetime, time or date array.  The input strings must
 conform to one of the ISO8601 formats defined in vtkTimePointUtility.

 The input array specified by SetInputArrayToProcess(...)
 indicates the array to process.  This array must be of type
 vtkStringArray.

 The output array will be of type vtkTypeUInt64Array.


"""
class vtkStripper:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStripper - create triangle strips and/or poly-lines

Super Class:

 vtkPolyDataAlgorithm

Caveats:

 If triangle strips or poly-lines exist in the input data they will
 be passed through to the output data. This filter will only construct
 triangle strips if triangle polygons are available; and will only 
 construct poly-lines if lines are available.

See Also:

 vtkTriangleFilter


"""
class vtkStructuredGridAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStructuredGridAlgorithm - Superclass for algorithms that produce only structured grid as output

Super Class:

 vtkAlgorithm


"""
class vtkStructuredGridClip:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStructuredGridClip - Reduces the image extent of the input.

Super Class:

 vtkStructuredGridAlgorithm

 vtkStructuredGridClip  will make an image smaller.  The output must have
 an image extent which is the subset of the input.  The filter has two 
 modes of operation: 
 1: By default, the data is not copied in this filter. 
 Only the whole extent is modified.  
 2: If ClipDataOn is set, then you will get no more that the clipped
 extent.


"""
class vtkStructuredGridGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStructuredGridGeometryFilter - extract geometry for structured grid

Super Class:

 vtkPolyDataAlgorithm

 vtkStructuredGridGeometryFilter is a filter that extracts geometry from a
 structured grid. By specifying appropriate i-j-k indices, it is possible
 to extract a point, a curve, a surface, or a "volume". Depending upon the
 type of data, the curve and surface may be curved or planar. (The volume
 is actually a (n x m x o) region of points.)

 The extent specification is zero-offset. That is, the first k-plane in
 a 50x50x50 structured grid is given by (0,49, 0,49, 0,0).

 The output of this filter is affected by the structured grid blanking.
 If blanking is on, and a blanking array defined, then those cells 
 attached to blanked points are not output. (Blanking is a property of
 the input vtkStructuredGrid.)

Caveats:

 If you don't know the dimensions of the input dataset, you can use a large
 number to specify extent (the number will be clamped appropriately). For 
 example, if the dataset dimensions are 50x50x50, and you want a the fifth 
 k-plane, you can use the extents (0,100, 0,100, 4,4). The 100 will 
 automatically be clamped to 49.

See Also:

 vtkGeometryFilter vtkExtractGrid vtkStructuredGrid


"""
class vtkStructuredGridOutlineFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkStructuredGridOutlineFilter - create wireframe outline for structured grid

Super Class:

 vtkPolyDataAlgorithm

 vtkStructuredGridOutlineFilter is a filter that generates a wireframe 
 outline of a structured grid (vtkStructuredGrid). Structured data is 
 topologically a cube, so the outline will have 12 "edges".


"""
class vtkStructuredGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkStructuredGridReader - read vtk structured grid data file

Super Class:

 vtkDataReader

 vtkStructuredGridReader is a source object that reads ASCII or binary 
 structured grid data files in vtk format. (see text for format details).
 The output of this reader is a single vtkStructuredGrid data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkStructuredGrid vtkDataReader


"""
class vtkStructuredGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkStructuredGridWriter - write vtk structured grid data file

Super Class:

 vtkDataWriter

 vtkStructuredGridWriter is a source object that writes ASCII or binary 
 structured grid data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkStructuredPointsReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkStructuredPointsReader - read vtk structured points data file

Super Class:

 vtkDataReader

 vtkStructuredPointsReader is a source object that reads ASCII or binary 
 structured points data files in vtk format (see text for format details).
 The output of this reader is a single vtkStructuredPoints data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkStructuredPoints vtkDataReader


"""
class vtkStructuredPointsWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkStructuredPointsWriter - write vtk structured points data file

Super Class:

 vtkDataWriter

 vtkStructuredPointsWriter is a source object that writes ASCII or binary 
 structured points data in vtk file format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkSubPixelPositionEdgels:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSubPixelPositionEdgels - adjust edgel locations based on gradients.

Super Class:

 vtkPolyDataAlgorithm

 vtkSubPixelPositionEdgels is a filter that takes a series of linked
 edgels (digital curves) and gradient maps as input. It then adjusts
 the edgel locations based on the gradient data. Specifically, the
 algorithm first determines the neighboring gradient magnitudes of
 an edgel using simple interpolation of its neighbors. It then fits
 the following three data points: negative gradient direction
 gradient magnitude, edgel gradient magnitude and positive gradient
 direction gradient magnitude to a quadratic function. It then
 solves this quadratic to find the maximum gradient location along
 the gradient orientation.  It then modifies the edgels location
 along the gradient orientation to the calculated maximum
 location. This algorithm does not adjust an edgel in the direction
 orthogonal to its gradient vector.

See Also:

 vtkImageData vtkImageGradient vtkLinkEdgels


"""
class vtkSubdivideTetra:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSubdivideTetra - subdivide one tetrahedron into twelve for every tetra

Super Class:

 vtkUnstructuredGridAlgorithm

 This filter subdivides tetrahedra in an unstructured grid into twelve tetrahedra.


"""
class vtkSuperquadricSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSuperquadricSource - create a polygonal superquadric centered 

Super Class:

 vtkPolyDataAlgorithm

 vtkSuperquadricSource creates a superquadric (represented by polygons) 
 of specified
 size centered at the origin. The resolution (polygonal discretization)
 in both the latitude (phi) and longitude (theta) directions can be
 specified. Roundness parameters (PhiRoundness and ThetaRoundness) control
 the shape of the superquadric.  The Toroidal boolean controls whether
 a toroidal superquadric is produced.  If so, the Thickness parameter
 controls the thickness of the toroid:  0 is the thinnest allowable
 toroid, and 1 has a minimum sized hole.  The Scale parameters allow 
 the superquadric to be scaled in x, y, and z (normal vectors are correctly
 generated in any case).  The Size parameter controls size of the 
 superquadric.

 This code is based on "Rigid physically based superquadrics", A. H. Barr,
 in "Graphics Gems III", David Kirk, ed., Academic Press, 1992.


Caveats:

 Resolution means the number of latitude or longitude lines for a complete 
 superquadric. The resolution parameters are rounded to the nearest 4
 in phi and 8 in theta.  

 Texture coordinates are not equally distributed around all superquadrics.
 
 The Size and Thickness parameters control coefficients of superquadric
 generation, and may do not exactly describe the size of the superquadric.



"""
class vtkSurfaceReconstructionFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSurfaceReconstructionFilter - reconstructs a surface from unorganized points

Super Class:

 vtkImageAlgorithm

 vtkSurfaceReconstructionFilter takes a list of points assumed to lie on
 the surface of a solid 3D object. A signed measure of the distance to the
 surface is computed and sampled on a regular grid. The grid can then be
 contoured at zero to extract the surface. The default values for
 neighborhood size and sample spacing should give reasonable results for
 most uses but can be set if desired. This procedure is based on the PhD
 work of Hugues Hoppe: http://www.research.microsoft.com/~hoppe


"""
class vtkSynchronizedTemplates2D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSynchronizedTemplates2D - generate isoline(s) from a structured points set

Super Class:

 vtkPolyDataAlgorithm

 vtkSynchronizedTemplates2D is a 2D implementation of the synchronized 
 template algorithm. Note that vtkContourFilter will automatically
 use this class when appropriate.

Caveats:

 This filter is specialized to 2D images.

See Also:

 vtkContourFilter vtkSynchronizedTemplates3D


"""
class vtkSynchronizedTemplates3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSynchronizedTemplates3D - generate isosurface from structured points

Super Class:

 vtkPolyDataAlgorithm

 vtkSynchronizedTemplates3D is a 3D implementation of the synchronized 
 template algorithm. Note that vtkContourFilter will automatically
 use this class when appropriate.

Caveats:

 This filter is specialized to 3D images (aka volumes).

See Also:

 vtkContourFilter vtkSynchronizedTemplates2D


"""
class vtkSynchronizedTemplatesCutter3D:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkSynchronizedTemplatesCutter3D - generate cut surface from structured points

Super Class:

 vtkSynchronizedTemplates3D

 vtkSynchronizedTemplatesCutter3D is an implementation of the synchronized 
 template algorithm. Note that vtkCutFilter will automatically
 use this class when appropriate.

See Also:

 vtkContourFilter vtkSynchronizedTemplates3D


"""
class vtkTIFFReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkTIFFReader - read TIFF files

Super Class:

 vtkImageReader2

 vtkTIFFReader is a source object that reads TIFF files.
 It should be able to read almost any TIFF file


See Also:

 vtkTIFFWriter


"""
class vtkTIFFWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkTIFFWriter - write out image data as a TIFF file

Super Class:

 vtkImageWriter

 vtkTIFFWriter writes image data as a TIFF data file. Data can be written
 uncompressed or compressed. Several forms of compression are supported
 including packed bits, JPEG, deflation, and LZW. (Note: LZW compression
 is currently under patent in the US and is disabled until the patent
 expires. However, the mechanism for supporting this compression is available
 for those with a valid license or to whom the patent does not apply.)


"""
class vtkTableAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTableAlgorithm - Superclass for algorithms that produce only vtkTables as output

Super Class:

 vtkAlgorithm

 vtkTableAlgorithm is a convenience class to make writing algorithms
 easier. It is also designed to help transition old algorithms to the new
 pipeline architecture. There are some assumptions and defaults made by this
 class you should be aware of. This class defaults such that your filter
 will have one input port and one output port. If that is not the case
 simply change it with SetNumberOfInputPorts etc. See this class
 constructor for the default. This class also provides a FillInputPortInfo
 method that by default says that all inputs will be Tree. If that
 isn't the case then please override this method in your subclass. This
 class breaks out the downstream requests into separate functions such as
 ExecuteData and ExecuteInformation.  For new algorithms you should
 implement RequestData( request, inputVec, outputVec) but for older filters
 there is a default implementation that calls the old ExecuteData(output)
 signature. For even older filters that don't implement ExecuteData the
 default implementation calls the even older Execute() signature.

 .SECTION Thanks
 Thanks to Brian Wylie for creating this class.


"""
class vtkTableReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkTableReader - read vtkTable data file

Super Class:

 vtkDataReader

 vtkTableReader is a source object that reads ASCII or binary 
 vtkTable data files in vtk format. (see text for format details).
 The output of this reader is a single vtkTable data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkTable vtkDataReader vtkTableWriter


"""
class vtkTableToGraphFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTableToGraphFilter - convert a vtkTable into a vtkGraph

Super Class:

 vtkGraphAlgorithm


 Creates a vtkGraph using one or two vtkTables.  The first (required)
 input table must have one row for each arc in the graph.
 The table must have two columns which represent the source and target
 node ids.  Use 

 SetInputArrayToProcess(i,0,0,vtkDataObject::FIELD_ASSOCIATION_NONE,"name")

 to specify these fields, where i=0 is the source field, and i=1 is the
 target field.

 The second (optional) vtkTable has one row for each node in the graph.
 The table must have a field whose values match those in the arc table.
 Use 

 SetInputArrayToProcess(2,1,0,vtkDataObject::FIELD_ASSOCIATION_NONE,"name")

 to specify the node index field. If the node table is not given, 
 a node will be created for each unique source or target identifier 
 in the arc table.

 Input arrays 0, 1 and 2 must be of the same type, and must be either
 vtkStringArray or a subclass of vtkDataArray.

 All columns in the tables, including the source, target, and node index
 fields, are copied into the arc data and node data of the resulting
 vtkGraph.  If the node table is not given, the node data will contain
 a single "id" column with the same type as the source/target id arrays.

 If parallel arcs are collected, not all the arc data is not copied into 
 the output.  Only the source and target id arrays will be transferred.
 An additional vtkIdTypeArray column called "weight" is created which 
 contains the number of times each arc appeared in the input.

 If the node table contains positional data, the user may specify these
 with input arrays 3, 4 and 5 for x, y, and z-coordinates, respectively.
 These arrays must be data arrays.  The z-coordinate array is optional,
 and if not given the z-coordinates are set to zero.


"""
class vtkTableToTreeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTableToTreeFilter - Filter that converts a vtkTable to a vtkTree

Super Class:

 vtkTreeAlgorithm


 vtkTableToTreeFilter is a filter for converting a vtkTable data structure
 into a vtkTree datastructure.  Currently, this will convert the table into
 a star, with each row of the table as a child of a new root node.
 The columns of the table are passed as node fields of the tree.


"""
class vtkTableWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkTableWriter - write vtkTable to a file

Super Class:

 vtkDataWriter

 vtkTableWriter is a sink object that writes ASCII or binary 
 vtkTable data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkTemporalDataSetAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTemporalDataSetAlgorithm - Superclass for algorithms that produce only vtkTemporalDataSet as output

Super Class:

 vtkAlgorithm

 Algorithms that take any type of data object (including composite dataset)
 and produce a vtkTemporalDataSet in the output can subclass from this
 class.


"""
class vtkTemporalDataSetCache:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTemporalDataSetCache - cache time steps

Super Class:

 vtkTemporalDataSetAlgorithm

 vtkTemporalDataSetCache cache time step requests of a temporal dataset,
 when cached data is requested it is returned using a shallow copy.


"""
class vtkTemporalInterpolator:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTemporalInterpolator - interpolate temporal datasets

Super Class:

 vtkTemporalDataSetAlgorithm

 vtkTemporalInterpolator interpolates between two time steps to
 produce new data for an arbitrary T.
 vtkTemporalInterpolator has two modes of operation. The default
 mode is to produce a continuous range of time values as output
 which enables a filter downstream to request Any value of T within
 the range. The interpolator will produce the requested T.
 The second mode of operation is enabled by setting
 DiscreteTimeStepInterval to a non zero value. When this mode is
 activated, the filter will report a finite number of Time steps
 separated by deltaT between the original range of values.
 This mode is useful when a dataset of N time steps has one (or more)
 missing datasets for certain T values and you simply wish to smooth
 over the missing steps but otherwise use the original data.


"""
class vtkTemporalShiftScale:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTemporalShiftScale - modify the time range/steps of temporal data

Super Class:

 vtkTemporalDataSetAlgorithm

 vtkTemporalShiftScale  modify the time range or time steps of
 the data without changing the data itself. The data is not resampled
 by this filter, only the information accompanying the data is modified.


"""
class vtkTemporalSnapToTimeStep:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTemporalSnapToTimeStep - modify the time range/steps of temporal data

Super Class:

 vtkTemporalDataSetAlgorithm

 vtkTemporalSnapToTimeStep  modify the time range or time steps of
 the data without changing the data itself. The data is not resampled
 by this filter, only the information accompanying the data is modified.


"""
class vtkTensorGlyph:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTensorGlyph - scale and orient glyph(s) according to tensor eigenvalues and eigenvectors

Super Class:

 vtkPolyDataAlgorithm

 vtkTensorGlyph is a filter that copies a geometric representation
 (specified as polygonal data) to every input point. The geometric
 representation, or glyph, can be scaled and/or rotated according to
 the tensor at the input point. Scaling and rotation is controlled
 by the eigenvalues/eigenvectors of the tensor as follows. For each
 tensor, the eigenvalues (and associated eigenvectors) are sorted to
 determine the major, medium, and minor eigenvalues/eigenvectors.

 If the boolean variable ThreeGlyphs is not set the major eigenvalue 
 scales the glyph in the x-direction, the medium in the y-direction, 
 and the minor in the  z-direction. Then, the glyph is rotated so 
 that the glyph's local x-axis lies along the major eigenvector, 
 y-axis along the medium eigenvector, and z-axis along the minor. 

 If the boolean variable ThreeGlyphs is set three glyphs are produced, 
 each of them oriented along an eigenvector and scaled according to the 
 corresponding eigenvector.

 If the boolean variable Symmetric is set each glyph is mirrored (2 or 6 
 glyphs will be produced)

 The x-axis of the source glyph will correspond to the eigenvector 
 on output. Point (0,0,0) in the source will be placed in the data point.
 Variable Length will normally correspond to the distance from the 
 origin to the tip of the source glyph along the x-axis, 
 but can be changed to produce other results when Symmetric is on,
 e.g. glyphs that do not touch or that overlap.

 Please note that when Symmetric is false it will generally be better 
 to place the source glyph from (-0.5,0,0) to (0.5,0,0), i.e. centred
 at the origin. When symmetric is true the placement from (0,0,0) to
 (1,0,0) will generally be more convenient.

 A scale factor is provided to control the amount of scaling. Also, you 
 can turn off scaling completely if desired. The boolean variable 
 ClampScaling controls the maximum scaling (in conjunction with
 MaxScaleFactor.) This is useful in certain applications where 
 singularities or large order of magnitude differences exist in 
 the eigenvalues.

 If the boolean variable ColorGlyphs is set to true the glyphs are
 colored.  The glyphs can be colored using the input scalars
 (SetColorModeToScalars), which is the default, or colored using the
 eigenvalues (SetColorModeToEigenvalues).

 Another instance variable, ExtractEigenvalues, has been provided to
 control extraction of eigenvalues/eigenvectors. If this boolean is
 false, then eigenvalues/eigenvectors are not extracted, and the
 columns of the tensor are taken as the eigenvectors (the norm of
 column, always positive, is the eigenvalue).  This allows
 additional capability over the vtkGlyph3D object. That is, the
 glyph can be oriented in three directions instead of one.

See Also:

 vtkGlyph3D vtkPointLoad vtkHyperStreamline


"""
class vtkTessellatorFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTessellatorFilter - approximate nonlinear FEM elements with simplices

Super Class:

 vtkUnstructuredGridAlgorithm

 This class approximates nonlinear FEM elements with linear simplices.

 <b>Warning</b>: This class is temporary and will go away at some point
 after ParaView 1.4.0.

 This filter rifles through all the cells in an input vtkDataSet. It
 tesselates each cell and uses the vtkStreamingTessellator and
 vtkDataSetEdgeSubdivisionCriterion classes to generate simplices that
 approximate the nonlinear mesh using some approximation metric (encoded
 in the particular vtkDataSetEdgeSubdivisionCriterion::EvaluateEdge
 implementation). The simplices are placed into the filter's output
 vtkDataSet object by the callback routines AddATetrahedron,
 AddATriangle, and AddALine, which are registered with the triangulator.

 The output mesh will have geometry and any fields specified as
 attributes in the input mesh's point data.  The attribute's copy flags
 are honored, except for normals.

 .SECTION Internals

 The filter's main member function is RequestData(). This function first
 calls SetupOutput() which allocates arrays and some temporary variables
 for the primitive callbacks (OutputTriangle and OutputLine which are
 called by AddATriangle and AddALine, respectively).  Each cell is given
 an initial tesselation, which results in one or more calls to
 OutputTetrahedron, OutputTriangle or OutputLine to add elements to the
 OutputMesh. Finally, Teardown() is called to free the filter's working
 space.


See Also:

 vtkDataSetToUnstructuredGridFilter vtkDataSet vtkStreamingTessellator
 vtkDataSetEdgeSubdivisionCriterion


"""
class vtkTextSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTextSource - create polygonal text

Super Class:

 vtkPolyDataAlgorithm

 vtkTextSource converts a text string into polygons.  This way you can 
 insert text into your renderings. It uses the 9x15 font from X Windows.
 You can specify if you want the background to be drawn or not. The
 characters are formed by scan converting the raster font into
 quadrilaterals. Colors are assigned to the letters using scalar data.
 To set the color of the characters with the source's actor property, set
 BackingOff on the text source and ScalarVisibilityOff on the associated
 vtkPolyDataMapper. Then, the color can be set using the associated actor's
 property.

 vtkVectorText generates higher quality polygonal representations of
 characters.

See Also:

 vtkVectorText


"""
class vtkTexture:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkOpenGLTexture - OpenGL texture map

Super Class:

 vtkTexture

 vtkOpenGLTexture is a concrete implementation of the abstract class 
 vtkTexture. vtkOpenGLTexture interfaces to the OpenGL rendering library.


"""
class vtkTextureMapToCylinder:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTextureMapToCylinder - generate texture coordinates by mapping points to cylinder

Super Class:

 vtkDataSetAlgorithm

 vtkTextureMapToCylinder is a filter that generates 2D texture coordinates
 by mapping input dataset points onto a cylinder. The cylinder can either be
 user specified or generated automatically. (The cylinder is generated 
 automatically by computing the axis of the cylinder.)  Note that the
 generated texture coordinates for the s-coordinate ranges from (0-1) 
 (corresponding to angle of 0->360 around axis), while the mapping of 
 the t-coordinate is controlled by the projection of points along the axis.

 To specify a cylinder manually, you must provide two points that
 define the axis of the cylinder. The length of the axis will affect the
 t-coordinates.
 
 A special ivar controls how the s-coordinate is generated. If PreventSeam
 is set to true, the s-texture varies from 0->1 and then 1->0 (corresponding
 to angles of 0->180 and 180->360).

Caveats:

 Since the resulting texture s-coordinate will lie between (0,1), and the
 origin of the texture coordinates is not user-controllable, you may want
 to use the class vtkTransformTexture to linearly scale and shift the origin
 of the texture coordinates.

See Also:

 vtkTextureMapToPlane vtkTextureMapToSphere vtkTextureMapToBox
 vtkTransformTexture vtkThresholdTextureCoords


"""
class vtkTextureMapToPlane:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTextureMapToPlane - generate texture coordinates by mapping points to plane

Super Class:

 vtkDataSetAlgorithm

 vtkTextureMapToPlane is a filter that generates 2D texture coordinates
 by mapping input dataset points onto a plane. The plane can either be
 user specified or generated automatically. (A least squares method is
 used to generate the plane automatically.)

 There are two ways you can specify the plane. The first is to provide a
 plane normal. In this case the points are projected to a plane, and the
 points are then mapped into the user specified s-t coordinate range. For
 more control, you can specify a plane with three points: an origin and two
 points defining the two axes of the plane. (This is compatible with the
 vtkPlaneSource.) Using the second method, the SRange and TRange vectors
 are ignored, since the presumption is that the user does not want to scale
 the texture coordinates; and you can adjust the origin and axes points to
 achieve the texture coordinate scaling you need. Note also that using the
 three point method the axes do not have to be orthogonal.

See Also:

 vtkTextureMapToBox vtkPlaneSource vtkTextureMapToCylinder
 vtkTextureMapToSphere vtkThresholdTextureCoords


"""
class vtkTextureMapToSphere:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTextureMapToSphere - generate texture coordinates by mapping points to sphere

Super Class:

 vtkDataSetAlgorithm

 vtkTextureMapToSphere is a filter that generates 2D texture coordinates by
 mapping input dataset points onto a sphere. The sphere can either be user
 specified or generated automatically. (The sphere is generated
 automatically by computing the center (i.e., averaged coordinates) of the
 sphere.)  Note that the generated texture coordinates range between
 (0,1). The s-coordinate lies in the angular direction around the z-axis,
 measured counter-clockwise from the x-axis. The t-coordinate lies in the
 angular direction measured down from the north pole towards the south
 pole.

 A special ivar controls how the s-coordinate is generated. If PreventSeam
 is set to true, the s-texture varies from 0->1 and then 1->0 (corresponding
 to angles of 0->180 and 180->360).

Caveats:

 The resulting texture coordinates will lie between (0,1), and the texture
 coordinates are determined with respect to the modeler's x-y-z coordinate
 system. Use the class vtkTransformTextureCoords to linearly scale and
 shift the origin of the texture coordinates (if necessary).

See Also:

 vtkTextureMapToPlane vtkTextureMapToCylinder vtkTextureMapToBox
 vtkTransformTexture vtkThresholdTextureCoords


"""
class vtkTexturedSphereSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTexturedSphereSource - create a sphere centered at the origin

Super Class:

 vtkPolyDataAlgorithm

 vtkTexturedSphereSource creates a polygonal sphere of specified radius 
 centered at the origin. The resolution (polygonal discretization) in both 
 the latitude (phi) and longitude (theta) directions can be specified. 
 It also is possible to create partial sphere by specifying maximum phi and 
 theta angles.


"""
class vtkThreshold:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkThreshold - extracts cells where scalar value in cell satisfies threshold criterion

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkThreshold is a filter that extracts cells from any dataset type that
 satisfy a threshold criterion. A cell satisfies the criterion if the
 scalar value of (every or any) point satisfies the criterion. The
 criterion can take three forms: 1) greater than a particular value; 2)
 less than a particular value; or 3) between two values. The output of this
 filter is an unstructured grid.

 Note that scalar values are available from the point and cell attribute
 data.  By default, point data is used to obtain scalars, but you can
 control this behavior. See the AttributeMode ivar below.

 By default only the first scalar value is used in the decision. Use the ComponentMode
 and SelectedComponent ivars to control this behavior.

See Also:

 vtkThresholdPoints vtkThresholdTextureCoords


"""
class vtkThresholdPoints:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkThresholdPoints - extracts points whose scalar value satisfies threshold criterion

Super Class:

 vtkPolyDataAlgorithm

 vtkThresholdPoints is a filter that extracts points from a dataset that 
 satisfy a threshold criterion. The criterion can take three forms:
 1) greater than a particular value; 2) less than a particular value; or
 3) between a particular value. The output of the filter is polygonal data.

See Also:

 vtkThreshold


"""
class vtkThresholdTable:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkThresholdTable - Thresholds table rows.

Super Class:

 vtkTableAlgorithm

 vtkThresholdTable uses minimum and/or maximum values to threshold
 table rows based on the values in a particular column.
 The column to threshold is specified using SetInputArrayToProcess(0, ...).


"""
class vtkThresholdTextureCoords:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkThresholdTextureCoords - compute 1D, 2D, or 3D texture coordinates based on scalar threshold

Super Class:

 vtkDataSetAlgorithm

 vtkThresholdTextureCoords is a filter that generates texture coordinates for
 any input dataset type given a threshold criterion. The criterion can take 
 three forms: 1) greater than a particular value (ThresholdByUpper()); 
 2) less than a particular value (ThresholdByLower(); or 3) between two 
 values (ThresholdBetween(). If the threshold criterion is satisfied, 
 the "in" texture coordinate will be set (this can be specified by the
 user). If the threshold criterion is not satisfied the "out" is set.

Caveats:

 There is a texture map - texThres.vtk - that can be used in conjunction
 with this filter. This map defines a "transparent" region for texture 
 coordinates 0<=r<0.5, and an opaque full intensity map for texture 
 coordinates 0.5<r<=1.0. There is a small transition region for r=0.5.

See Also:

 vtkThreshold vtkThresholdPoints vtkTextureMapToPlane vtkTextureMapToSphere
 vtkTextureMapToCylinder vtkTextureMapToBox


"""
class vtkTimePointToString:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTimePointToString - Converts a timestamp array to a string array

Super Class:

 vtkDataObjectAlgorithm


 vtkTimePointToString is a filter for converting a timestamp array
 into string array using one of the formats defined in vtkTimePointUtility.h.

 Use SetInputArrayToProcess to indicate the array to process.  
 This array must be an unsigned 64-bit integer array for 
 DATETIME formats, and may be either an unsigned 32-bit or 
 unsigned 64-bit array for DATE and TIME formats.

 If the new array name is not specified, the array name will be
 the old name appended by " [to string]".


"""
class vtkTimeSourceExample:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTimeSource - creates a simple time varying data set.

Super Class:

 vtkImageAlgorithm

 Creates a small easily understood time varying data set for testing.
 The output is a vtkImageData in which the point and cell values vary
 over time in a sin wave. The analytic ivar controls whether the output 
 corresponds to a step function over time or is continuous.
 The X and Y Amplitude ivars make the output move in the X and Y directions 
 over time. The Growing ivar makes the number of cells in the output grow 
 and then shrink over time.


"""
class vtkTransformFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTransformFilter - transform points and associated normals and vectors

Super Class:

 vtkPointSetAlgorithm

 vtkTransformFilter is a filter to transform point coordinates, and 
 associated point normals and vectors. Other point data is passed
 through the filter.

 An alternative method of transformation is to use vtkActor's methods
 to scale, rotate, and translate objects. The difference between the
 two methods is that vtkActor's transformation simply effects where
 objects are rendered (via the graphics pipeline), whereas
 vtkTransformFilter actually modifies point coordinates in the 
 visualization pipeline. This is necessary for some objects 
 (e.g., vtkProbeFilter) that require point coordinates as input.

See Also:

 vtkAbstractTransform vtkTransformPolyDataFilter vtkActor


"""
class vtkTransformPolyDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTransformPolyDataFilter - transform points and associated normals and vectors for polygonal dataset

Super Class:

 vtkPolyDataAlgorithm

 vtkTransformPolyDataFilter is a filter to transform point
 coordinates and associated point and cell normals and
 vectors. Other point and cell data is passed through the filter
 unchanged. This filter is specialized for polygonal data. See
 vtkTransformFilter for more general data.

 An alternative method of transformation is to use vtkActor's methods
 to scale, rotate, and translate objects. The difference between the
 two methods is that vtkActor's transformation simply effects where
 objects are rendered (via the graphics pipeline), whereas
 vtkTransformPolyDataFilter actually modifies point coordinates in the 
 visualization pipeline. This is necessary for some objects 
 (e.g., vtkProbeFilter) that require point coordinates as input.

See Also:

 vtkTransform vtkTransformFilter vtkActor


"""
class vtkTransformTextureCoords:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTransformTextureCoords - transform (scale, rotate, translate) texture coordinates

Super Class:

 vtkDataSetAlgorithm

 vtkTransformTextureCoords is a filter that operates on texture
 coordinates. It ingests any type of dataset, and outputs a dataset of the
 same type. The filter lets you scale, translate, and rotate texture
 coordinates. For example, by using the the Scale ivar, you can shift
 texture coordinates that range from (0->1) to range from (0->10) (useful
 for repeated patterns).
 
 The filter operates on texture coordinates of dimension 1->3. The texture 
 coordinates are referred to as r-s-t. If the texture map is two dimensional,
 the t-coordinate (and operations on the t-coordinate) are ignored.

See Also:

 vtkTextureMapToPlane vtkTextureMapToBox vtkTextureMapToCylinder 
 vtkTextureMapToSphere vtkThresholdTextureCoords vtkTexture


"""
class vtkTransformToGrid:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTransformToGrid - create a grid for a vtkGridTransform

Super Class:

 vtkAlgorithm

 vtkTransformToGrid takes any transform as input and produces a grid
 for use by a vtkGridTransform.  This can be used, for example, to 
 invert a grid transform, concatenate two grid transforms, or to
 convert a thin plate spline transform into a grid transform.

See Also:

 vtkGridTransform vtkThinPlateSplineTransform vtkAbstractTransform


"""
class vtkTreeAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTreeAlgorithm - Superclass for algorithms that produce only Tree as output

Super Class:

 vtkAlgorithm

 vtkTreeAlgorithm is a convenience class to make writing algorithms
 easier. It is also designed to help transition old algorithms to the new
 pipeline edgehitecture. There are some assumptions and defaults made by this
 class you should be aware of. This class defaults such that your filter
 will have one input port and one output port. If that is not the case
 simply change it with SetNumberOfInputPorts etc. See this class
 constructor for the default. This class also provides a FillInputPortInfo
 method that by default says that all inputs will be Tree. If that
 isn't the case then please override this method in your subclass. This
 class breaks out the downstream requests into separate functions such as
 ExecuteData and ExecuteInformation.  For new algorithms you should
 implement RequestData( request, inputVec, outputVec) but for older filters
 there is a default implementation that calls the old ExecuteData(output)
 signature. For even older filters that don't implement ExecuteData the
 default implementation calls the even older Execute() signature.


"""
class vtkTreeFieldAggregator:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTreeFieldAggregator - aggregate field values from the leaves up the tree

Super Class:

 vtkTreeAlgorithm

 vtkTreeFieldAggregator may be used to assign sizes to all the vertices in the
 tree, based on the sizes of the leaves.  The size of a vertex will equal
 the sum of the sizes of the child vertices.  If you have a data array with
 values for all leaves, you may specify that array, and the values will
 be filled in for interior tree vertices.  If you do not yet have an array,
 you may tell the filter to create a new array, assuming that the size
 of each leaf vertex is 1.  You may optionally set a flag to first take the
 log of all leaf values before aggregating.


"""
class vtkTreeLevelsFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTreeLevelsFilter - adds level and leaf fields to a vtkTree

Super Class:

 vtkTreeAlgorithm

 The filter currently add two arrays to the incoming vtkTree datastructure.
 1) "levels" this is the distance from the root of the vertex. Root = 0
 and you add 1 for each level down from the root
 2) "leaf" this array simply indicates whether the vertex is a leaf or not

 .SECTION Thanks
 Thanks to Brian Wylie from Sandia National Laboratories for creating this
 class.


"""
class vtkTreeMapLayout:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTreeMapLayout - layout a vtkTree into a tree map

Super Class:

 vtkTreeAlgorithm

 vtkTreeMapLayout assigns rectangular regions to each vertex in the tree,
 creating a tree map.  The data is added as a data array with four
 components per tuple representing the location and size of the
 rectangle using the format (Xmin, Xmax, Ymin, Ymax).

 This algorithm relies on a helper class to perform the actual layout.
 This helper class is a subclass of vtkTreeMapLayoutStrategy.

 .SECTION Thanks
 Thanks to Brian Wylie and Ken Moreland from Sandia National Laboratories
 for help developing this class.
 
 Tree map concept comes from:
 Shneiderman, B. 1992. Tree visualization with tree-maps: 2-d space-filling approach. 
 ACM Trans. Graph. 11, 1 (Jan. 1992), 92-99. 


"""
class vtkTreeMapToPolyData:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTreeMapToPolyData - converts a tree to a polygonal data representing a tree map

Super Class:

 vtkPolyDataAlgorithm

 This algorithm requires that the vtkTreeMapLayout filter has already applied to the
 data in order to create the quadruple array (min x, max x, min y, max y) of
 bounds for each vertex of the tree.


"""
class vtkTreeReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkTreeReader - read vtkTree data file

Super Class:

 vtkDataReader

 vtkTreeReader is a source object that reads ASCII or binary 
 vtkTree data files in vtk format. (see text for format details).
 The output of this reader is a single vtkTree data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkTree vtkDataReader vtkTreeWriter


"""
class vtkTreeWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkTreeWriter - write vtkTree data to a file

Super Class:

 vtkDataWriter

 vtkTreeWriter is a sink object that writes ASCII or binary 
 vtkTree data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkTriangleFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTriangleFilter - create triangle polygons from input polygons and triangle strips

Super Class:

 vtkPolyDataAlgorithm

 vtkTriangleFilter generates triangles from input polygons and triangle 
 strips. The filter also will pass through vertices and lines, if
 requested.


"""
class vtkTriangularTCoords:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTriangularTCoords - 2D texture coordinates based for triangles.

Super Class:

 vtkPolyDataAlgorithm

 vtkTriangularTCoords is a filter that generates texture coordinates
 for triangles. Texture coordinates for each triangle are:
 (0,0), (1,0) and (.5,sqrt(3)/2). This filter assumes that the triangle
 texture map is symmetric about the center of the triangle. Thus the order
 Of the texture coordinates is not important. The procedural texture
 in vtkTriangularTexture is designed with this symmetry. For more information
 see the paper "Opacity-modulating Triangular Textures for Irregular 
 Surfaces,"  by Penny Rheingans, IEEE Visualization '96, pp. 219-225.

See Also:

 vtkTriangularTexture vtkThresholdPoints vtkTextureMapToPlane 
 vtkTextureMapToSphere vtkTextureMapToCylinder vtkTextureMapToBox


"""
class vtkTriangularTexture:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTriangularTexture - generate 2D triangular texture map

Super Class:

 vtkImageAlgorithm

 vtkTriangularTexture is a filter that generates a 2D texture map based on 
 the paper "Opacity-modulating Triangular Textures for Irregular Surfaces,"
 by Penny Rheingans, IEEE Visualization '96, pp. 219-225.
 The textures assume texture coordinates of (0,0), (1.0) and
 (.5, sqrt(3)/2). The sequence of texture values is the same along each
 edge of the triangular texture map. So, the assignment order of texture
 coordinates is arbitrary.

See Also:

 vtkTriangularTCoords


"""
class vtkTrivialProducer:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTrivialProducer - Producer for stand-alone data objects.

Super Class:

 vtkAlgorithm

 vtkTrivialProducer allows stand-alone data objects to be connected
 as inputs in a pipeline.  All data objects that are connected to a
 pipeline involving vtkAlgorithm must have a producer.  This trivial
 producer allows data objects that are hand-constructed in a program
 without another vtk producer to be connected.


"""
class vtkTubeFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkTubeFilter - filter that generates tubes around lines

Super Class:

 vtkPolyDataAlgorithm

 vtkTubeFilter is a filter that generates a tube around each input line. 
 The tubes are made up of triangle strips and rotate around the tube with
 the rotation of the line normals. (If no normals are present, they are
 computed automatically.) The radius of the tube can be set to vary with 
 scalar or vector value. If the radius varies with scalar value the radius
 is linearly adjusted. If the radius varies with vector value, a mass
 flux preserving variation is used. The number of sides for the tube also 
 can be specified. You can also specify which of the sides are visible. This
 is useful for generating interesting striping effects. Other options
 include the ability to cap the tube and generate texture coordinates.
 Texture coordinates can be used with an associated texture map to create
 interesting effects such as marking the tube with stripes corresponding
 to length or time.

 This filter is typically used to create thick or dramatic lines. Another
 common use is to combine this filter with vtkStreamLine to generate
 streamtubes.

Caveats:

 The number of tube sides must be greater than 3. If you wish to use fewer
 sides (i.e., a ribbon), use vtkRibbonFilter.

 The input line must not have duplicate points, or normals at points that
 are parallel to the incoming/outgoing line segments. (Duplicate points
 can be removed with vtkCleanPolyData.) If a line does not meet this
 criteria, then that line is not tubed.

See Also:

 vtkRibbonFilter vtkStreamLine


"""
class vtkUGFacetReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkUGFacetReader - read EDS Unigraphics facet files

Super Class:

 vtkPolyDataAlgorithm

 vtkUGFacetReader is a source object that reads Unigraphics facet files.
 Unigraphics is a solid modeling system; facet files are the polygonal
 plot files it uses to create 3D plots.


"""
class vtkUnstructuredGridAlgorithm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkUnstructuredGridAlgorithm - Superclass for algorithms that produce only unstructured grid as output

Super Class:

 vtkAlgorithm


"""
class vtkUnstructuredGridGeometryFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkUnstructuredGridGeometryFilter - extract geometry from an unstructured grid

Super Class:

 vtkUnstructuredGridAlgorithm

 vtkUnstructuredGridGeometryFilter is a filter to extract
 geometry (and associated data) from an unstructured grid. It differs from
 vtkGeometryFilter by not tessellating higher order faces: 2D faces of
 quadratic 3D cells will be quadratic. A quadratic edge is extracted as a
 quadratic edge. For that purpose, the output of this filter is an
 unstructured grid, not a polydata.
 Also, the face of a voxel is pixel, not a quad.
 Geometry is obtained as follows: all 0D, 1D, and 2D cells are extracted.
 All 2D faces that are used by only one 3D cell (i.e., boundary faces) are
 extracted. It also is possible to specify conditions on point ids, cell ids,
 and on bounding box (referred to as "Extent") to control the extraction
 process.


Caveats:

 When vtkUnstructuredGridGeometryFilter extracts cells (or boundaries of
 cells) it will (by default) merge duplicate vertices. This may cause
 problems in some cases. Turn merging off to prevent this from occurring.

See Also:

 vtkGeometryFilter


"""
class vtkUnstructuredGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkUnstructuredGridReader - read vtk unstructured grid data file

Super Class:

 vtkDataReader

 vtkUnstructuredGridReader is a source object that reads ASCII or binary 
 unstructured grid data files in vtk format. (see text for format details).
 The output of this reader is a single vtkUnstructuredGrid data object.
 The superclass of this class, vtkDataReader, provides many methods for
 controlling the reading of the data file, see vtkDataReader for more
 information.

Caveats:

 Binary files written on one system may not be readable on other systems.

See Also:

 vtkUnstructuredGrid vtkDataReader


"""
class vtkUnstructuredGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkUnstructuredGridWriter - write vtk unstructured grid data file

Super Class:

 vtkDataWriter

 vtkUnstructuredGridWriter is a source object that writes ASCII or binary 
 unstructured grid data files in vtk format. See text for format details.

Caveats:

 Binary files written on one system may not be readable on other systems.


"""
class vtkVectorDot:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVectorDot - generate scalars from dot product of vectors and normals (e.g., show displacement plot)

Super Class:

 vtkDataSetAlgorithm

 vtkVectorDot is a filter to generate scalar values from a dataset.
 The scalar value at a point is created by computing the dot product 
 between the normal and vector at that point. Combined with the appropriate
 color map, this can show nodal lines/mode shapes of vibration, or a 
 displacement plot.


"""
class vtkVectorNorm:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVectorNorm - generate scalars from Euclidean norm of vectors

Super Class:

 vtkDataSetAlgorithm

 vtkVectorNorm is a filter that generates scalar values by computing
 Euclidean norm of vector triplets. Scalars can be normalized 
 0<=s<=1 if desired.

 Note that this filter operates on point or cell attribute data, or
 both.  By default, the filter operates on both point and cell data
 if vector point and cell data, respectively, are available from the
 input. Alternatively, you can choose to generate scalar norm values
 for just cell or point data.


"""
class vtkVectorText:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVectorText - create polygonal text

Super Class:

 vtkPolyDataAlgorithm

See Also:

 vtkTextMapper vtkCaptionActor2D


"""
class vtkVertexDegree:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVertexDegree - Adds an attribute array with the degree of each vertex

Super Class:

 vtkAbstractGraphAlgorithm

 Adds an attribute array with the degree of each vertex.


"""
class vtkVertexGlyphFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVertexGlyphFilter - Make a vtkPolyData with a vertex on each point.

Super Class:

 vtkPolyDataAlgorithm


 This filter throws away all of the cells in the input and replaces them with
 a vertex on each point.  The intended use of this filter is roughly
 equivalent to the vtkGlyph3D filter, except this filter is specifically for
 data that has many vertices, making the rendered result faster and less
 cluttered than the glyph filter.



"""
class vtkVideoSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVideoSource - Superclass of video input devices for VTK

Super Class:

 vtkImageAlgorithm

 vtkVideoSource is a superclass for video input interfaces for VTK.
 The goal is to provide an interface which is very similar to the
 interface of a VCR, where the 'tape' is an internal frame buffer
 capable of holding a preset number of video frames.  Specialized
 versions of this class record input from various video input sources.
 This base class records input from a noise source.

Caveats:

 You must call the ReleaseSystemResources() method before the application
 exits.  Otherwise the application might hang while trying to exit.

See Also:

 vtkWin32VideoSource vtkMILVideoSource


"""
class vtkVolume16Reader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkVolume16Reader - read 16 bit image files

Super Class:

 vtkVolumeReader

 vtkVolume16Reader is a source object that reads 16 bit image files.

 Volume16Reader creates structured point datasets. The dimension of the 
 dataset depends upon the number of files read. Reading a single file 
 results in a 2D image, while reading more than one file results in a 
 3D volume.

 File names are created using FilePattern and FilePrefix as follows:
 sprintf (filename, FilePattern, FilePrefix, number);
 where number is in the range ImageRange[0] to ImageRange[1]. If
 ImageRange[1] <= ImageRange[0], then slice number ImageRange[0] is
 read. Thus to read an image set ImageRange[0] = ImageRange[1] = slice 
 number. The default behavior is to read a single file (i.e., image slice 1).

 The DataMask instance variable is used to read data files with imbedded
 connectivity or segmentation information. For example, some data has
 the high order bit set to indicate connected surface. The DataMask allows
 you to select this data. Other important ivars include HeaderSize, which
 allows you to skip over initial info, and SwapBytes, which turns on/off
 byte swapping.

 The Transform instance variable specifies a permutation transformation
 to map slice space into world space. vtkImageReader has replaced the
 functionality of this class and should be used instead.

See Also:

 vtkSliceCubes vtkMarchingCubes vtkImageReader


"""
class vtkVoxelContoursToSurfaceFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVoxelContoursToSurfaceFilter - create surface from contours

Super Class:

 vtkPolyDataAlgorithm

 vtkVoxelContoursToSurfaceFilter is a filter that takes contours and
 produces surfaces. There are some restrictions for the contours:

   - The contours are input as vtkPolyData, with the contours being
     polys in the vtkPolyData.
   - The contours lie on XY planes - each contour has a constant Z
   - The contours are ordered in the polys of the vtkPolyData such 
     that all contours on the first (lowest) XY plane are first, then
     continuing in order of increasing Z value. 
   - The X, Y and Z coordinates are all integer values.
   - The desired sampling of the contour data is 1x1x1 - Aspect can
     be used to control the aspect ratio in the output polygonal
     dataset.

 This filter takes the contours and produces a structured points
 dataset of signed floating point number indicating distance from
 a contour. A contouring filter is then applied to generate 3D
 surfaces from a stack of 2D contour distance slices. This is 
 done in a streaming fashion so as not to use to much memory.

See Also:

 vtkPolyDataAlgorithm


"""
class vtkVoxelModeller:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkVoxelModeller - convert an arbitrary dataset to a voxel representation

Super Class:

 vtkImageAlgorithm

 vtkVoxelModeller is a filter that converts an arbitrary data set to a
 structured point (i.e., voxel) representation. It is very similar to 
 vtkImplicitModeller, except that it doesn't record distance; instead it
 records occupancy. As such, it stores its results in the more compact
 form of 0/1 bits.

See Also:

 vtkImplicitModeller


"""
class vtkWarpLens:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWarpLens - deform geometry by applying lens distortion

Super Class:

 vtkPointSetAlgorithm

 vtkWarpLens is a filter that modifies point coordinates by moving
 in accord with a lens distortion model.


"""
class vtkWarpScalar:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWarpScalar - deform geometry with scalar data

Super Class:

 vtkPointSetAlgorithm

 vtkWarpScalar is a filter that modifies point coordinates by moving
 points along point normals by the scalar amount times the scale factor.
 Useful for creating carpet or x-y-z plots.

 If normals are not present in data, the Normal instance variable will
 be used as the direction along which to warp the geometry. If normals are
 present but you would like to use the Normal instance variable, set the 
 UseNormal boolean to true.

 If XYPlane boolean is set true, then the z-value is considered to be 
 a scalar value (still scaled by scale factor), and the displacement is
 along the z-axis. If scalars are also present, these are copied through
 and can be used to color the surface.

 Note that the filter passes both its point data and cell data to
 its output, except for normals, since these are distorted by the
 warping.


"""
class vtkWarpTo:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWarpTo - deform geometry by warping towards a point

Super Class:

 vtkPointSetAlgorithm

 vtkWarpTo is a filter that modifies point coordinates by moving the
 points towards a user specified position.


"""
class vtkWarpVector:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWarpVector - deform geometry with vector data

Super Class:

 vtkPointSetAlgorithm

 vtkWarpVector is a filter that modifies point coordinates by moving
 points along vector times the scale factor. Useful for showing flow
 profiles or mechanical deformation.

 The filter passes both its point data and cell data to its output.


"""
class vtkWeightedTransformFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWeightedTransformFilter - transform based on per-point or per-cell weighting functions.

Super Class:

 vtkPointSetAlgorithm

Caveats:

 Weighted combination of normals and vectors are probably not appropriate
 in many cases.  Surface normals are treated somewhat specially, but
 in many cases you may need to regenerate the surface normals.

 Cell data can only be transformed if all transforms are linear.



See Also:

 vtkAbstractTransform vtkLinearTransform vtkTransformPolyDataFilter vtkActor


"""
class vtkWin32VideoSource:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWin32VideoSource - Video-for-Windows video digitizer

Super Class:

 vtkVideoSource

 vtkWin32VideoSource grabs frames or streaming video from a
 Video for Windows compatible device on the Win32 platform. 

Caveats:

 With some capture cards, if this class is leaked and ReleaseSystemResources 
 is not called, you may have to reboot before you can capture again.
 vtkVideoSource used to keep a global list and delete the video sources
 if your program leaked, due to exit crashes that was removed.


See Also:

 vtkVideoSource vtkMILVideoSource


"""
class vtkWindowToImageFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWindowToImageFilter - Use a vtkWindow as input to image pipeline

Super Class:

 vtkAlgorithm

 vtkWindowToImageFilter provides methods needed to read the data in
 a vtkWindow and use it as input to the imaging pipeline. This is
 useful for saving an image to a file for example. The window can
 be read as either RGB or RGBA pixels;  in addition, the depth buffer
 can also be read.   RGB and RGBA pixels are of type unsigned char,
 while Z-Buffer data is returned as floats.  Use this filter
 to convert RenderWindows or ImageWindows to an image format.  


Caveats:

 A vtkWindow doesn't behave like other parts of the VTK pipeline: its
 modification time doesn't get updated when an image is rendered.  As a
 result, naive use of vtkWindowToImageFilter will produce an image of
 the first image that the window rendered, but which is never updated
 on subsequent window updates.  This behavior is unexpected and in 
 general undesirable. 

 To force an update of the output image, call vtkWindowToImageFilter's 
 Modified method after re ...
 [Truncated]

See Also:

 vtkWindow vtkRenderLargeImage


"""
class vtkWindowedSincPolyDataFilter:
    kits = ['vtk_kit']
    cats = ['VTK basic filters']

    help = \
         """vtkWindowedSincPolyDataFilter - adjust point positions using a windowed sinc function interpolation kernel

Super Class:

 vtkPolyDataAlgorithm

 vtkWindowedSincPolyDataFiler adjust point coordinate using a windowed
 sinc function interpolation kernel.  The effect is to "relax" the mesh,
 making the cells better shaped and the vertices more evenly distributed.
 Note that this filter operates the lines, polygons, and triangle strips
 composing an instance of vtkPolyData.  Vertex or poly-vertex cells are
 never modified.

 The algorithm proceeds as follows. For each vertex v, a topological and
 geometric analysis is performed to determine which vertices are connected
 to v, and which cells are connected to v. Then, a connectivity array is
 constructed for each vertex. (The connectivity array is a list of lists
 of vertices that directly attach to each vertex.) Next, an iteration
 phase begins over all vertices. For each vertex v, the coordinates of v
 are modified using a windowed sinc function interpolation kernel.
 Taubin describes this methodology is the IBM tech report RC-20404
 (#90237, dated 3/12/96) "Optimal Surface Smoothing as Filter Design"
 G. Taubin, T. Zhang and G. Golub. (Zhang and Golub are at Stanford
 University).

 This report discusses using standard signal processing low-pass filters
 (in particular windowed sinc functions) to smooth polyhedra. The
 transfer functions of the low-pass filters are approximated by
 Chebyshev polynomials. This facilitates applying the filters in an
 iterative diffusion process (as opposed to a kernel convolution).  The
 more smoothing iterations applied, the higher the degree of polynomial
 approximating the low-pass filter transfer function. Each smoothing
 iteration, therefore, applies the next higher term of the Chebyshev
 filter approximation to the polyhedron. This decoupling of the filter
 into an iteratively applied polynomial is possible since the Chebyshev
 polynomials are orthogonal, i.e. increasing the order of the
 approximation to the filter transfer function does not alter the
 previously calculated coefficients for the low order terms. 

 Note: Care must be taken to avoid smoothing with too few iterations.
 A Chebyshev approximation with too few terms is an poor approximation.
 The first few smoothing iterations represent a severe scaling and
 translation of the data.  Subsequent iterations cause the smoothed
 polyhedron to converge to the true location and scale of the object.
 We have attempted to protect against this by automatically adjusting
 the filter, effectively widening the pass band. This adjustment is only
 possible if the number of iterations is greater than 1.  Note that this
 sacrifices some degree of smoothing for model integrity. For those
 interested, the filter is adjusted by searching for a value sigma
 such that the actual pass band is k_pb + sigma and such that the
 filter transfer function evaluates to unity at k_pb, i.e. f(k_pb) = 1

 To improve the numerical stability of the solution and minimize the
 scaling the translation effects, the algorithm can translate and
 scale the position coordinates to within the unit cube [-1, 1],
 perform the smoothing, and translate and scale the position
 coordinates back to the original coordinate frame.  This mode is
 controlled with the NormalizeCoordinatesOn() /
 NormalizeCoordinatesOff() methods.  For legacy reasons, the default
 is NormalizeCoordinatesOff.

 This implementation is currently limited to using an interpolation
 kernel based on Hamming windows.  Other windows (such as Hann, Blackman,
 Kaiser, Lanczos, Gaussian, and exponential windows) could be used
 instead.

 There are some special instance variables used to control the execution
 of this filter. (These ivars basically control what vertices can be
 smoothed, and the creation of the connectivity array.) The
 BoundarySmoothing ivar enables/disables the smoothing operation on
 vertices that are on the "boundary" of the mesh. A boundary vertex is one
 that is surrounded by a semi-cycle of polygons (or used by a single
 line).
 
 Another important ivar is FeatureEdgeSmoothing. If this ivar is
 enabled, then interior vertices are classified as either "simple",
 "interior edge", or "fixed", and smoothed differently. (Interior
 vertices are manifold vertices surrounded by a cycle of polygons; or used
 by two line cells.) The classification is based on the number of feature 
 edges attached to v. A feature edge occurs when the angle between the two
 surface normals of a polygon sharing an edge is greater than the
 FeatureAngle ivar. Then, vertices used by no feature edges are classified
 "simple", vertices used by exactly two feature edges are classified
 "interior edge", and all others are "fixed" vertices.

 Once the classification is known, the vertices are smoothed
 differently. Corner (i.e., fixed) vertices are not smoothed at all. 
 Simple vertices are smoothed as before . Interior edge vertices are
 smoothed only along their two connected edges, and only if the angle
 between the edges is less than the EdgeAngle ivar.

 The total smoothing can be controlled by using two ivars. The 
 NumberOfIterations determines the maximum number of smoothing passes.
 The NumberOfIterations corresponds to the degree of the polynomial that
 is used to approximate the windowed sinc function. Ten or twenty
 iterations is all the is usually necessary. Contrast this with
 vtkSmoothPolyDataFilter which usually requires 100 to 200 smoothing
 iterations. vtkSmoothPolyDataFilter is also not an approximation to
 an ideal low-pass filter, which can cause the geometry to shrink as the
 amount of smoothing increases.

 The second ivar is the specification of the PassBand for the windowed
 sinc filter.  By design, the PassBand is specified as a doubleing point
 number between 0 and 2.  Lower PassBand values produce more smoothing.
 A good default value for the PassBand is 0.1 (for those interested, the
 PassBand (and frequencies) for PolyData are based on the valence of the
 vertices, this limits all the frequency modes in a polyhedral mesh to
 between 0 and 2.)

 There are two instance variables that control the generation of error
 data. If the ivar GenerateErrorScalars is on, then a scalar value indicating
 the distance of each vertex from its original position is computed. If the
 ivar GenerateErrorVectors is on, then a vector representing change in 
 position is computed.


Caveats:

 The smoothing operation reduces high frequency information in the
 geometry of the mesh. With excessive smoothing important details may be
 lost. Enabling FeatureEdgeSmoothing helps reduce this effect, but cannot
 entirely eliminate it.


See Also:

 vtkSmoothPolyDataFilter vtkDecimate vtkDecimatePro


"""
class vtkXMLDataSetWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLDataSetWriter - Write any type of VTK XML file.

Super Class:

 vtkXMLWriter

 vtkXMLDataSetWriter is a wrapper around the VTK XML file format
 writers.  Given an input vtkDataSet, the correct writer is
 automatically selected based on the type of input.

See Also:

 vtkXMLImageDataWriter vtkXMLStructuredGridWriter
 vtkXMLRectilinearGridWriter vtkXMLPolyDataWriter
 vtkXMLUnstructuredGridWriter


"""
class vtkXMLHierarchicalBoxDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLHierarchicalBoxDataReader - Reader for hierarchical datasets

Super Class:

 vtkXMLHierarchicalDataReader

 vtkXMLHierarchicalBoxDataReader reads the VTK XML hierarchical data file
 format. XML hierarchical data files are meta-files that point to a list
 of serial VTK XML files. When reading in parallel, it will distribute
 sub-blocks among processor. If the number of sub-blocks is less than
 the number of processors, some processors will not have any sub-blocks
 for that level. If the number of sub-blocks is larger than the
 number of processors, each processor will possibly have more than
 1 sub-block.


"""
class vtkXMLHierarchicalDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLHierarchicalDataReader - Reader for hierarchical datasets

Super Class:

 vtkXMLMultiGroupDataReader

 vtkXMLHierarchicalDataReader reads the VTK XML hierarchical data file
 format. XML hierarchical data files are meta-files that point to a list
 of serial VTK XML files. When reading in parallel, it will distribute
 sub-blocks among processor. If the number of sub-blocks is less than
 the number of processors, some processors will not have any sub-blocks
 for that level. If the number of sub-blocks is larger than the
 number of processors, each processor will possibly have more than
 1 sub-block.


"""
class vtkXMLHyperOctreeReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLHyperOctreeReader - Read VTK XML HyperOctree files.

Super Class:

 vtkXMLDataReader

 vtkXMLHyperOctreeReader reads the VTK XML HyperOctree file
 format.  One rectilinear grid file can be read to produce one
 output.  Streaming is supported.  The standard extension for this
 reader's file format is "vto".  This reader is also used to read a
 single piece of the parallel file format.

See Also:

 vtkXMLPHyperOctreeReader


"""
class vtkXMLHyperOctreeWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLHyperOctreeWriter - Write VTK XML HyperOctree files.

Super Class:

 vtkXMLWriter

 vtkXMLHyperOctreeWriter writes the VTK XML HyperOctree file
 format.  One HyperOctree input can be written into one file in
 any number of streamed pieces.  The standard extension for this
 writer's file format is "vto".  This writer is also used to write a
 single piece of the parallel file format.

See Also:

 vtkXMLPHyperOctreeWriter


"""
class vtkXMLImageDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLImageDataReader - Read VTK XML ImageData files.

Super Class:

 vtkXMLStructuredDataReader

 vtkXMLImageDataReader reads the VTK XML ImageData file format.  One
 image data file can be read to produce one output.  Streaming is
 supported.  The standard extension for this reader's file format is
 "vti".  This reader is also used to read a single piece of the
 parallel file format.

See Also:

 vtkXMLPImageDataReader


"""
class vtkXMLImageDataWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLImageDataWriter - Write VTK XML ImageData files.

Super Class:

 vtkXMLStructuredDataWriter

 vtkXMLImageDataWriter writes the VTK XML ImageData file format.
 One image data input can be written into one file in any number of
 streamed pieces.  The standard extension for this writer's file
 format is "vti".  This writer is also used to write a single piece
 of the parallel file format.

See Also:

 vtkXMLPImageDataWriter


"""
class vtkXMLMultiBlockDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLMultiBlockDataReader - Reader for multi-block datasets

Super Class:

 vtkXMLMultiGroupDataReader

 vtkXMLMultiBlockDataReader reads the VTK XML multi-block data file
 format. XML multi-block data files are meta-files that point to a list
 of serial VTK XML files. When reading in parallel, it will distribute
 sub-blocks among processor. If the number of sub-blocks is less than
 the number of processors, some processors will not have any sub-blocks
 for that block. If the number of sub-blocks is larger than the
 number of processors, each processor will possibly have more than
 1 sub-block.


"""
class vtkXMLMultiGroupDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLMultiGroupDataReader - Reader for multi-group datasets

Super Class:

 vtkXMLReader

 vtkXMLMultiGroupDataReader reads the VTK XML multi-group data file
 format. XML multi-group data files are meta-files that point to a list
 of serial VTK XML files. When reading in parallel, it will distribute
 sub-blocks among processor. If the number of sub-blocks is less than
 the number of processors, some processors will not have any sub-blocks
 for that group. If the number of sub-blocks is larger than the
 number of processors, each processor will possibly have more than
 1 sub-block.


"""
class vtkXMLMultiGroupDataWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLMultiGroupDataWriter - Writer for multi-group datasets

Super Class:

 vtkXMLWriter

 vtkXMLMultiGroupDataWriter writes (serially) the VTK XML multi-group,
 multi-block hierarchical and hierarchical box files. XML multi-group
 data files are meta-files that point to a list of serial VTK XML files.

See Also:

 vtkXMLPMultiGroupDataWriter


"""
class vtkXMLPDataSetWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPDataSetWriter - Write any type of PVTK XML file.

Super Class:

 vtkXMLPDataWriter

 vtkXMLPDataSetWriter is a wrapper around the PVTK XML file format
 writers.  Given an input vtkDataSet, the correct writer is
 automatically selected based on the type of input.

See Also:

 vtkXMLPImageDataWriter vtkXMLPStructuredGridWriter
 vtkXMLPRectilinearGridWriter vtkXMLPPolyDataWriter
 vtkXMLPUnstructuredGridWriter


"""
class vtkXMLPImageDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLPImageDataReader - Read PVTK XML ImageData files.

Super Class:

 vtkXMLPStructuredDataReader

 vtkXMLPImageDataReader reads the PVTK XML ImageData file format.
 This reads the parallel format's summary file and then uses
 vtkXMLImageDataReader to read data from the individual ImageData
 piece files.  Streaming is supported.  The standard extension for
 this reader's file format is "pvti".

See Also:

 vtkXMLImageDataReader


"""
class vtkXMLPImageDataWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPImageDataWriter - Write PVTK XML ImageData files.

Super Class:

 vtkXMLPStructuredDataWriter

 vtkXMLPImageDataWriter writes the PVTK XML ImageData file format.
 One image data input can be written into a parallel file format
 with any number of pieces spread across files.  The standard
 extension for this writer's file format is "pvti".  This writer
 uses vtkXMLImageDataWriter to write the individual piece files.

See Also:

 vtkXMLImageDataWriter


"""
class vtkXMLPPolyDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLPPolyDataReader - Read PVTK XML PolyData files.

Super Class:

 vtkXMLPUnstructuredDataReader

 vtkXMLPPolyDataReader reads the PVTK XML PolyData file format.
 This reads the parallel format's summary file and then uses
 vtkXMLPolyDataReader to read data from the individual PolyData
 piece files.  Streaming is supported.  The standard extension for
 this reader's file format is "pvtp".

See Also:

 vtkXMLPolyDataReader


"""
class vtkXMLPPolyDataWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPPolyDataWriter - Write PVTK XML PolyData files.

Super Class:

 vtkXMLPUnstructuredDataWriter

 vtkXMLPPolyDataWriter writes the PVTK XML PolyData file format.
 One poly data input can be written into a parallel file format with
 any number of pieces spread across files.  The standard extension
 for this writer's file format is "pvtp".  This writer uses
 vtkXMLPolyDataWriter to write the individual piece files.

See Also:

 vtkXMLPolyDataWriter


"""
class vtkXMLPRectilinearGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLPRectilinearGridReader - Read PVTK XML RectilinearGrid files.

Super Class:

 vtkXMLPStructuredDataReader

 vtkXMLPRectilinearGridReader reads the PVTK XML RectilinearGrid
 file format.  This reads the parallel format's summary file and
 then uses vtkXMLRectilinearGridReader to read data from the
 individual RectilinearGrid piece files.  Streaming is supported.
 The standard extension for this reader's file format is "pvtr".

See Also:

 vtkXMLRectilinearGridReader


"""
class vtkXMLPRectilinearGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPRectilinearGridWriter - Write PVTK XML RectilinearGrid files.

Super Class:

 vtkXMLPStructuredDataWriter

 vtkXMLPRectilinearGridWriter writes the PVTK XML RectilinearGrid
 file format.  One rectilinear grid input can be written into a
 parallel file format with any number of pieces spread across files.
 The standard extension for this writer's file format is "pvtr".
 This writer uses vtkXMLRectilinearGridWriter to write the
 individual piece files.

See Also:

 vtkXMLRectilinearGridWriter


"""
class vtkXMLPStructuredGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLPStructuredGridReader - Read PVTK XML StructuredGrid files.

Super Class:

 vtkXMLPStructuredDataReader

 vtkXMLPStructuredGridReader reads the PVTK XML StructuredGrid file
 format.  This reads the parallel format's summary file and then
 uses vtkXMLStructuredGridReader to read data from the individual
 StructuredGrid piece files.  Streaming is supported.  The standard
 extension for this reader's file format is "pvts".

See Also:

 vtkXMLStructuredGridReader


"""
class vtkXMLPStructuredGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPStructuredGridWriter - Write PVTK XML StructuredGrid files.

Super Class:

 vtkXMLPStructuredDataWriter

 vtkXMLPStructuredGridWriter writes the PVTK XML StructuredGrid
 file format.  One structured grid input can be written into a
 parallel file format with any number of pieces spread across files.
 The standard extension for this writer's file format is "pvts".
 This writer uses vtkXMLStructuredGridWriter to write the individual
 piece files.

See Also:

 vtkXMLStructuredGridWriter


"""
class vtkXMLPUnstructuredGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLPUnstructuredGridReader - Read PVTK XML UnstructuredGrid files.

Super Class:

 vtkXMLPUnstructuredDataReader

 vtkXMLPUnstructuredGridReader reads the PVTK XML UnstructuredGrid
 file format.  This reads the parallel format's summary file and
 then uses vtkXMLUnstructuredGridReader to read data from the
 individual UnstructuredGrid piece files.  Streaming is supported.
 The standard extension for this reader's file format is "pvtu".

See Also:

 vtkXMLUnstructuredGridReader


"""
class vtkXMLPUnstructuredGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPUnstructuredGridWriter - Write PVTK XML UnstructuredGrid files.

Super Class:

 vtkXMLPUnstructuredDataWriter

 vtkXMLPUnstructuredGridWriter writes the PVTK XML UnstructuredGrid
 file format.  One unstructured grid input can be written into a
 parallel file format with any number of pieces spread across files.
 The standard extension for this writer's file format is "pvtu".
 This writer uses vtkXMLUnstructuredGridWriter to write the
 individual piece files.

See Also:

 vtkXMLUnstructuredGridWriter


"""
class vtkXMLPolyDataReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLPolyDataReader - Read VTK XML PolyData files.

Super Class:

 vtkXMLUnstructuredDataReader

 vtkXMLPolyDataReader reads the VTK XML PolyData file format.  One
 polygonal data file can be read to produce one output.  Streaming
 is supported.  The standard extension for this reader's file format
 is "vtp".  This reader is also used to read a single piece of the
 parallel file format.

See Also:

 vtkXMLPPolyDataReader


"""
class vtkXMLPolyDataWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLPolyDataWriter - Write VTK XML PolyData files.

Super Class:

 vtkXMLUnstructuredDataWriter

 vtkXMLPolyDataWriter writes the VTK XML PolyData file format.  One
 polygonal data input can be written into one file in any number of
 streamed pieces (if supported by the rest of the pipeline).  The
 standard extension for this writer's file format is "vtp".  This
 writer is also used to write a single piece of the parallel file
 format.

See Also:

 vtkXMLPPolyDataWriter


"""
class vtkXMLRectilinearGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLRectilinearGridReader - Read VTK XML RectilinearGrid files.

Super Class:

 vtkXMLStructuredDataReader

 vtkXMLRectilinearGridReader reads the VTK XML RectilinearGrid file
 format.  One rectilinear grid file can be read to produce one
 output.  Streaming is supported.  The standard extension for this
 reader's file format is "vtr".  This reader is also used to read a
 single piece of the parallel file format.

See Also:

 vtkXMLPRectilinearGridReader


"""
class vtkXMLRectilinearGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLRectilinearGridWriter - Write VTK XML RectilinearGrid files.

Super Class:

 vtkXMLStructuredDataWriter

 vtkXMLRectilinearGridWriter writes the VTK XML RectilinearGrid
 file format.  One rectilinear grid input can be written into one
 file in any number of streamed pieces.  The standard extension for
 this writer's file format is "vtr".  This writer is also used to
 write a single piece of the parallel file format.

See Also:

 vtkXMLPRectilinearGridWriter


"""
class vtkXMLStructuredGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLStructuredGridReader - Read VTK XML StructuredGrid files.

Super Class:

 vtkXMLStructuredDataReader

 vtkXMLStructuredGridReader reads the VTK XML StructuredGrid file
 format.  One structured grid file can be read to produce one
 output.  Streaming is supported.  The standard extension for this
 reader's file format is "vts".  This reader is also used to read a
 single piece of the parallel file format.

See Also:

 vtkXMLPStructuredGridReader


"""
class vtkXMLStructuredGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLStructuredGridWriter - Write VTK XML StructuredGrid files.

Super Class:

 vtkXMLStructuredDataWriter

 vtkXMLStructuredGridWriter writes the VTK XML StructuredGrid file
 format.  One structured grid input can be written into one file in
 any number of streamed pieces.  The standard extension for this
 writer's file format is "vts".  This writer is also used to write a
 single piece of the parallel file format.

See Also:

 vtkXMLPStructuredGridWriter


"""
class vtkXMLTreeReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLTreeReader - reads an XML file into a vtkTree

Super Class:

 vtkTreeAlgorithm

 vtkXMLTreeReader parses an XML file and uses the nesting structure of the
 XML tags to generate a tree.  Node attributes are assigned to node arrays,
 and the special arrays .tagname and .chardata contain the tag type and the
 text internal to the tag, respectively.  The arrays are of type
 vtkStringArray.  There is an array for each attribute type in the XML file,
 even if it appears in only one tag.  If an attribute is missing from a tag,
 its value is the empty string.

 If MaskArrays is on (the default is off), the filter will additionally make bit
 arrays whose names are prepended with ".valid." which are 1 if the element 
 contains that attribute, and 0 otherwise. 

 For example, the XML file containing the text:
 <node name="jeff" age="26">
   this is text in jeff's node
   <node name="joe">
     <node name="al" initials="amb" other="something"/>
     <node name="dave" age="30"/>
   </node>
   <node name="lisa">this is text in lisa's node</node>
   <node name="darlene" age="29"/>
 </node>

 would be parsed into a tree with the following node IDs and structure:

 0 (jeff) - children: 1 (joe), 4 (lisa), 5 (darlene)
 1 (joe)  - children: 2 (al), 3 (dave)
 2 (al)
 3 (dave)
 4 (lisa)
 5 (darlene)

 and the node data arrays would be as follows:

 name      initials  other     age       .tagname  .chardata
 ------------------------------------------------------------------------------------------------
 jeff      (empty)   (empty)   26         node     "  this is text in jeff's node\n  \n  \n  \n"
 joe       (empty)   (empty)   (empty)    node     "\n    \n    \n  "
 al        amb       something (empty)    node     (empty)
 dave      (empty)   (empty)   30         node     (empty)
 lisa      (empty)   (empty)   (empty)    node     "this is text in lisa's node"
 darlene   (empty)   (empty)   29         node     (empty)

 There would also be the following bit arrays if MaskArrays is on:

 .valid.name   .valid.initials   .valid.other   .valid.age
 ---------------------------------------------------------
 1             0                 0              1
 1             0                 0              0
 1             1                 1              0
 1             0                 0              1
 1             0                 0              0
 1             0                 0              1


"""
class vtkXMLUnstructuredGridReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXMLUnstructuredGridReader - Read VTK XML UnstructuredGrid files.

Super Class:

 vtkXMLUnstructuredDataReader

 vtkXMLUnstructuredGridReader reads the VTK XML UnstructuredGrid
 file format.  One unstructured grid file can be read to produce one
 output.  Streaming is supported.  The standard extension for this
 reader's file format is "vtu".  This reader is also used to read a
 single piece of the parallel file format.

See Also:

 vtkXMLPUnstructuredGridReader


"""
class vtkXMLUnstructuredGridWriter:
    kits = ['vtk_kit']
    cats = ['VTK basic writer']

    help = \
         """vtkXMLUnstructuredGridWriter - Write VTK XML UnstructuredGrid files.

Super Class:

 vtkXMLUnstructuredDataWriter

 vtkXMLUnstructuredGridWriter writes the VTK XML UnstructuredGrid
 file format.  One unstructured grid input can be written into one
 file in any number of streamed pieces (if supported by the rest of
 the pipeline).  The standard extension for this writer's file
 format is "vtu".  This writer is also used to write a single piece
 of the parallel file format.

See Also:

 vtkXMLPUnstructuredGridWriter


"""
class vtkXYZMolReader:
    kits = ['vtk_kit']
    cats = ['VTK basic readers']

    help = \
         """vtkXYZMolReader - read Molecular Data files

Super Class:

 vtkMoleculeReaderBase

 vtkXYZMolReader is a source object that reads Molecule files
 The FileName must be specified

 .SECTION Thanks
 Dr. Jean M. Favre who developed and contributed this class


"""